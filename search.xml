<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线性基]]></title>
    <url>%2F2020%2F12%2F02%2F%E7%BA%BF%E6%80%A7%E5%9F%BA%2F</url>
    <content type="text"><![CDATA[线性基线性基用于求解这样的问题：在n个数中选任意个数，求满足某个性质的异或和。什么是线性基？线性基是一个数集，其中若干个数异或起来可以得到原数集中任何一个数。 性质原数集中任意一个数都可以由线性基里面的一些数异或得到。线性基里面任意个数异或起来都不等于0.线性基里面数的个数唯一，且在保证前面性质的基础上个数最少。 构造这里直接给出线性基的构造方法 1234567891011void _insert(ll x) &#123; //插入数x for (ll i = 50; ~i; --i) &#123; if (!((x &gt;&gt; i) &amp; 1))continue; if (base[i])x ^= base[i]; else &#123; base[i] = x; break; &#125; &#125;&#125; 问题求解最大值直接从高位到低位贪心，如果异或当前的线性基可以使得答案变大就异或。即1234567ll getmax() &#123; ll ans = 0; for (ll i = 50; ~i; --i) if ((ans ^ base[i]) &gt; ans) ans ^= base[i]; return ans;&#125; 为什么这样做是对的呢？考虑我们上面的构造过程，P[i]一定是考虑了更高位的线性基的，所以只要保证当前位会使答案增加即可，低位的总贡献无论如何都不会比一个高位的贡献大。 区间查询最大值在求最大值的基础上，我们可以得到序列中求区间最大值的算法，该算法还支持动态扩大区间。我们构造前缀线性基，即对每个位置i构造[1,i]的线性基，并且记录线性基上插入的数字的位置，保证这个位置尽量靠后。更多实现细节看模板1234567891011121314151617181920212223242526272829303132void _insert(int x, int loc) &#123; //做前缀线性基，先复制[1,loc-1]的，在这个基础上插入x for (int i = 0; i &lt;= 31; ++i) base[loc][i] = base[loc - 1][i], pos[loc][i] = pos[loc - 1][i]; for (int i = 31, now = loc; ~i; --i) &#123; if (!(x &gt;&gt; i))continue; if (base[loc][i] == 0) &#123; base[loc][i] = x; pos[loc][i] = now; break; &#125; //pos记录线性基中插入的数在原序列的位置，尽量保留靠后的数 //由于其中保留的数只可能是之前插入的，所以保存的位置不会超过loc if (now &gt; pos[loc][i]) &#123; jh(now, pos[loc][i]); jh(x, base[loc][i]); &#125; x ^= base[loc][i]; &#125;&#125;int query(int l, int r) &#123; if (l &gt; r)jh(l, r); int ans = 0; //最终查询的时候，只需要查看r处的线性基，由于前面我们保证了线性基中的数位置尽量靠后 //所以只用看线性基中的数是否&gt;=l即可 for (int i = 31; ~i; --i) &#123; if (pos[r][i] &gt;= l &amp;&amp; (base[r][i] ^ ans) &gt; ans) ans ^= base[r][i]; &#125; return ans;&#125; 最小值这个很显然。如果是问线性基能异或出的最小值，那就是最小的base如果是问原数集能异或出的最小值，那就再看看有没有数不能插入线性基，如果有，最小值就是0。 第k小值在前面构造的线性基的基础上进行改进处理，使得每一位上的线性基最高位就是这一位。123456void presolve() &#123; for (ll i = 50; ~i; --i) for (int j = 0; j &lt; i; ++j) if (base[i] &gt;&gt; j) &amp; 1) base[i] ^= base[j];&#125; 查询的时候，就可以通过k的二进制来选择是否异或上某个线性基了。1234567891011121314ll query(int k) &#123; //tot为线性基中插入的元素个数 //如果插入元素比元素总数少，说明可以异或出0，特判一下 if (k == 1 &amp;&amp; tot &lt; n)return 0; //线性基求解的是不为0的第k小，因此如果有0就应该求第k-1小 if (tot &lt; n)--k; ll ans = 0; presolve(); for (ll i = 0; i &lt; 50; ++i) if (base[i]) &#123; if (k &amp; 1)ans ^= base[i]; k &gt;&gt;= 1; &#125;&#125; 判断一个数能否被线性基异或得出尝试将这个数插入线性基，能插入说明不能，不能插入说明能。]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论（三）]]></title>
    <url>%2F2020%2F11%2F25%2F%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[2-SATSAT问题指的是给出一些条件（未知量经过逻辑运算的结果），问是否存在一种合法的方案使得其满足所有条件。而2-SAT问题是一种特殊的SAT问题，它限制了每个逻辑运算的表达式中最多有两个未知量。 二元逻辑运算的转化为了解决2-SAT问题，我们需要将所有给出的二元逻辑运算式进行转化，变成形如“若A取值为x则B取值为y”这样的条件，通常情况下，我们将取值限定在0和1。那么对于各种逻辑运算我们就可以进行转化： A and B = 0 —&gt; 若A=1则B=0，若B=1则A=0 A or B = 1 —&gt; 若A=0则B=1，若B=0则A=1 … 诸如此类，我们可以将所有的二元逻辑运算式表述成如上的形式。特别地，如果有A=1这样的表达式，我们可以转化成“若A=0，则A=1”。 建图那么为什么要进行这样的转化呢？因为这样的话，我们就可以将“某元素取值为x”这样的一个表述抽象成一个点，通过连边的方式来构建不同元素取值之间的关系。具体地，根据上面的例子，我们将每个点a拆成两个点a0和a1，分别表示“a取值为0”和“a取值为1”，对于“若A=x则B=y”，我们连有向边(Ax, By)，这样的话如果我们能在图上从点P走到点Q，就说明若命题P成立则命题Q成立。那么显然，如果能从a0走到a1且能从a1走到a0，则必然矛盾，这一步我们可以用tarjan求强连通分量解决。反之，则一定存在合法方案满足所有的二元逻辑运算式。 求解O(N+M)求一组可行解首先当然是通过tarjan求强连通分量，最后如果有a0与a1在同一个强连通分量内，说明无解。那么缩完点后，我们如何来找到一组合法的解呢？这里先给出策略：缩点后按照逆拓扑序，即与拓扑序刚好相反的顺序找到一个未被染色的点并染成黑色，然后将与这个强连通分量中的点矛盾的所有强连通分量全部染成白色，重复这一过程，最后所有染成黑色的强连通分量里的点就是一组可行解。那么如何证明这种策略的正确性呢？首先通过前面的缩点我们保证了强连通分量内没有矛盾，那么我们只需要证明染色的过程没有矛盾。显然，我们在染黑色点的时候已然将其对立点所在联通块全部染成白色，染色过程不会产生矛盾，现在只需要说明我们的染色过程能够覆盖到每一个未知量。我们假设某一个未知量的两个对应元素都被染成了白色，那么考虑我们的染色过程，某个点被染成白色必然是因为其对立点被染成了黑色，这就产生了矛盾，所以不存在同一个未知量的两个对应元素都被染成白色，所以这两个点必然是一白一黑。如此，我们就证明了这个方法的正确性。 那么具体如何来操作呢？实际上非常方便，因为我们在缩点的过程中会对所有强连通分量进行编号，而这个编号我们从小到大来编，这样的话越靠后的强连通分量获得的编号实际上越小（因为tarjan是用dfs实现的），因此强连通分量的编号实际上就是上面提到的“逆拓扑序”。那么结果就很明显了，对于未知量a，若$ltk[a_0] &lt; ltk[a_1]$，则$a=0$；若$ltk[a_1]&lt;ltk[a_0]$，则$a=1$ O(NM)求最小字典序解我们只需要枚举每一个未知量，若其取值合法就继续下去，否则取另一个值并继续下去。 关于O(NM)做法的一个优化如果我们能在遍历到x时就能判断出x是否能走到x’，就可以O(n+m)求解了，而这个预处理我们通过传递闭包实现。 传递闭包什么是传递闭包？一个n顶点DAG的传递闭包可以定义为一个n阶布尔矩阵$T=\{t_{i,j}\}$，若从i到j存在一条路径，则$t_\{i,j\}=1$，否则$t_{i,j}=0$。实际上，传递闭包揭示的是两点间的传递关系，即两点间是否存在直接或间接的关系。]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>2-sat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算几何（一）]]></title>
    <url>%2F2020%2F11%2F19%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近点对问题平面直角坐标系上有若干个点，求其任意点对距离的最小值 模板12345678910111213141516171819202122232425262728293031323334353637383940struct Node &#123; double x, y; int tag; Node() &#123;&#125; Node(double x, double y, int tag = 0): x(x), y(y), tag(tag) &#123;&#125; bool operator &lt;(const Node s)const &#123; return x &lt; s.x || (x == s.x &amp;&amp; y &lt; s.y); &#125;&#125;p[N], tmp[N];bool cmp(Node x, Node y) &#123; return x.y &lt; y.y || (x.y == y.y &amp;&amp; x.x &lt; y.x); &#125;double getdis(Node x, Node y) &#123; return sqrt(pow(x.x - y.x, 2) + pow(x.y - y.y, 2)); &#125;double getmin(int l, int r) &#123; if (l == r)return 0; if (r - l == 1)return getdis(p[l], p[r]); if (r - l == 2) &#123; double ans = getdis(p[l], p[l + 1]); ans = min(ans, getdis(p[l + 1], p[r])); ans = min(ans, getdis(p[l], p[r])); return ans; &#125; int mid = l + r &gt;&gt; 1, tot = 0; double ans = min(getmin(l, mid), getmin(mid + 1, r)); for (int i = l; i &lt;= mid; ++i) if (p[mid].x - p[i].x &lt;= ans) tmp[tot++] = Node(p[i].x, p[i].y, 0); for (int i = mid + 1; i &lt;= r; ++i) if (p[i].x - p[mid].x &lt;= ans) tmp[tot++] = Node(p[i].x, p[i].y, 1); sort(tmp, tmp + tot, cmp); for (int i = 0; i &lt; tot; ++i) &#123; if (tmp[i].tag)continue; for (int j = 1; j &lt;= 7 &amp;&amp; i + j &lt; tot; ++j) &#123; if (!tmp[j].tag)continue; ans = min(ans, getdis(tmp[i], tmp[i + j])); &#125; &#125; return ans;&#125;void init(int n) &#123; for (int i = 0; i &lt; n; ++i)p[i] = Node(fast_IO::read(), fast_IO::read()); sort(p, p + n);&#125;]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学（二）]]></title>
    <url>%2F2020%2F11%2F18%2F%E6%95%B0%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[BSGSBSGS用于求解形如$A^x\equiv B\pmod{P}$的高次剩余问题。在这里我们先引入一些基础的数论知识。 欧拉函数及欧拉定理欧拉函数$\phi(x)$表示x内与x互质的数的个数，比如$\phi(6)=2$，$\phi(8)=4$欧拉定理：$若a,n互质，则a^{\phi(n)}\equiv 1\pmod{n}$ 整数的阶设a与n是互质的整数，其中$a\not=0,n&gt;0$，使得$a^x\equiv 1\pmod{n}$成立的最小正整数x称为a模n的阶，符号为${ \rm { ord } }_na$根据欧拉定理，$\phi(n)$是$a^x\equiv 1\pmod{n}$的一个解，但未必是最小，所以$\phi(n)$未必是阶。下面给出阶相关的几个定理： $若\gcd(a,n)=1，则x_0是方程a^x\equiv 1\pmod{n}的一个解的充要条件是{ \rm{ ord } }_na|x_0$ $若\gcd(a,n)=1，则{ \rm {ord} }_na|\phi(n)$ $若\gcd(a,n)=1，则a^i\equiv a^j\pmod{n}的充要条件是i\equiv j\pmod{ { \rm {ord} }_na }$ $若\;{ \rm {ord} }_na=t，且u为正整数，则有{ \rm {ord} }_n(a^u)=\dfrac{t}{\gcd(t, u)}$ 原根当$ { \rm {ord} }_na=\phi(n)$时，称a为n的原根。咕咕咕 BSGS算法懂了这些基础知识后，我们来看看BSGS算法是怎样求解的首先使用BSGS的前提条件是P为素数，于是我们知道${ \rm {ord} }_PA\le \phi(P)$，所以我们就考虑$0\sim\phi(P)$的解。我们知道，小于P的数可以表示成$x=a\lceil\sqrt{P}\rceil+b,0\le a,b &lt; \lceil\sqrt{P}\rceil$那么原式子就可以变形为$A^{a\lceil\sqrt{P}\rceil}\equiv B\times A^{-b}\pmod P$那么我们只需要枚举所有的b将$B\times A^{-b}$插入哈希表，然后枚举a在哈希表中查找$A^{a\lceil\sqrt{P}\rceil}$就行了。复杂度为$O(\sqrt{P})$当然，如果我们将x表示成$x=a\lceil\sqrt{P}\rceil-b,1\le a \le \lceil\sqrt{P}\rceil,0\le b&lt; \lceil\sqrt{P}\rceil$，就不用求A的逆元了此时原式子变形为$A^{a\lceil\sqrt{P}\rceil}\equiv B\times A^b\pmod P$ 123456789101112131415161718192021ll ksm(ll a, ll b, ll p) &#123; ll ans = 1; for (; b; (a *= a) %= p, b &gt;&gt;= 1) if (b &amp; 1)(ans *= a) %= p; return ans;&#125;ll BSGS(ll A, ll B, ll P) &#123; unordered_map&lt;ll, ll&gt;mp; unordered_map&lt;ll, bool&gt;mmp; B %= P; ll s = ceil(sqrt(P)); for (ll i = 0; i &lt; s; ++i) mp[B * ksm(A, i, P) % P] = i, mmp[B * ksm(A, i, P) % P] = true; A = ksm(A, s, P); for (ll i = 1; i &lt;= s; ++i) &#123; ll now = ksm(A, i, P); if (mmp[now] &amp;&amp; i * s - mp[now] &gt;= 0)return i * s - mp[now]; &#125; return -1;&#125; exBSGS当P不为素数时，直接BSGS就有问题了，因为可能会出现$A^k\equiv 0\pmod{P}$当$\gcd(A,P)\not|B$时，仅当$B=1$时有解（显然至少有一个解为0），其余均无解，而当$\gcd(A,P)=1$时直接进行BSGS，否则 A^x\equiv B\pmod{P}\\ A^{x-1}\times\dfrac{A}{\gcd(A,P)}\equiv \dfrac{B}{\gcd(A,P)}\pmod{\dfrac{P}{\gcd(A,P)}}\\ A^{x-1}\equiv \dfrac{B}{\gcd(A,P)}\times(\dfrac{A}{\gcd(A,P)})^{-1}\pmod{\dfrac{P}{\gcd(A,P)}}\\而这个式子可看作 A'\equiv B'\pmod{P'}反复进行直到$\gcd(A’,P’)=1$，再进行BSGS就可以了。注意，最终我们BSGS求出的是$x-t$，我们在前面的过程中记录t的大小，最后加上BSGS的答案即可 1234567891011121314ll exBSGS(ll A, ll B, ll P) &#123; ll x, y, gcd, add = 0; if (B == 1)return 0; for (; (gcd = exGCD(A, P, x, y)) != 1; ++add) &#123; if (B % gcd)return -1; B /= gcd, P /= gcd; exGCD(A / gcd, P, x, y); x = (x % P + P) % P; B = B * x % P; &#125; ll ans = BSGS(A, B, P); if (~ans)return ans + add; return -1;&#125; Lucas卢卡斯定理用于求解当$p$为素数时$x\equiv C_n^m\pmod{p}$。定理： C_n^m\equiv C_{\lfloor n/p\rfloor}^{\lfloor m/p\rfloor}\times C_{n\bmod p}^{m\bmod p}\pmod{p}证明：首先我们需要证明$C_n^m=\dfrac{n}{m}\times C_{n-1}^{m-1}$对$1\le m\le n - 1$恒成立。 C_n^m=\dfrac{n!}{m!\times(n-m)!}=\dfrac{n}{m}\times\dfrac{(n-1)!}{(m-1)!\times(n-m)!}=\dfrac{n}{m}\times C_{n-1}^{m-1}再结合$(1+x)^n$的二项式展开，有 (1+x)^p=1+C_p^1 x+C_p^2 x^2+...+C_p^{p-1} x^{p-1}+x^p=1+\dfrac{p}{1}C_{p-1}^0 x+\dfrac{p}{2}C_{p-1}^1 x^2+...+\dfrac{p}{p-1}C_{p-1}^{p-2} x^{p-1}+x^p\equiv 1+x^p\pmod{p}对于$(1+x)^n$，有 (1+x)^n=((1+x)^p)^{\lfloor n/p\rfloor}\cdot(1+x)^{n\bmod p}\equiv (1+x^p)^{\lfloor n/p\rfloor}\cdot(1+x)^{n\bmod p}\pmod{p}然后我们考虑上面得到的式子以及$(1+x)^n$中$x^m$的系数是什么，很容易得到 C_n^mx^m\equiv C_{\lfloor n/p\rfloor}^{\lfloor m/p\rfloor}x^{\lfloor m/p\rfloor \times p}\cdot C_{n\bmod p}^{m\bmod p}x^{m\bmod p}\pmod{p}\\ 即C_n^m\equiv C_{\lfloor n/p\rfloor}^{\lfloor m/p\rfloor}\times C_{n\bmod p}^{m\bmod p}\pmod{p}所以我们只需要递归求解即可，注意边界条件1234567891011121314151617ll dfs(ll n, ll m, ll p) &#123; if (n &lt; m)return 0; if (n &lt; p)return mul[n] * inv[m] % p * inv[n - m] % p; return dfs(n / p, m / p, p) * dfs(n % p, m % p, p) % p;&#125;ll Lucas(ll n, ll m, ll p) &#123; mul[0] = mul[1] = 1; inv[0] = inv[1] = 1; for (int i = 2; i &lt;= n; ++i) mul[i] = mul[i - 1] * i % p; //线性递推求逆元 for (int i = 2; i &lt;= n; ++i) inv[i] = (p - p / i) * inv[p % i] % p; for (int i = 2; i &lt;= n; ++i) (inv[i] *= inv[i - 1]) %= p; return dfs(n, m, p);&#125; exLucas当p不为素数的时候，我们就不能用Lucas求了，于是我们引入扩展卢卡斯定理。首先声明一点，exLucas和Lucas没有本质联系，只是求解的问题类型相同。我们可以将p进行质因数分解，得到$p=p_1^{k_1}\cdot p_2^{k_2}\cdot…\cdot p_t^{k_t}$那么对于下面的模方程 \begin{cases} x\equiv C_n^m\pmod{p_1^{k_1}}\\ x\equiv C_n^m\pmod{p_2^{k_2}}\\ ...\\ x\equiv C_n^m\pmod{p_t^{k_t}} \end{cases}我们可以用CRT进行求解，最终得到的x就是$C_n^m\pmod{p}$因此扩展卢卡斯定理的重点在于如何求解 \begin{cases} C_n^m\pmod{p_1^{k_1}}\\ C_n^m\pmod{p_2^{k_2}}\\ ...\\ C_n^m\pmod{p_t^{k_t}} \end{cases}假设我们当前要求$C_n^m\pmod{p^{k}}$即$\dfrac{n!}{m!(n-m)!}\pmod{p^k}$那么这东西可以直接求解吗？显然是不能的，因为a对p的逆元存在的前提条件是gcd(a,p)=1所以我们对这个式子变形，改成如下形式 C_n^m\equiv\dfrac{\dfrac{n!}{p^x}}{\dfrac{m!}{p^y}\times\dfrac{(n-m)!}{p^z}}\times p^{x-y-z}\pmod{p}其中$\dfrac{x!}{p^y}$表示x!除掉其中所有的质因子p，且质因子p的个数为y。不难证明，$x\ge y+z$，因此我们提出来的p的幂用快速幂求解即可。现在的问题只剩下如何求解$\dfrac{x!}{p^y}\pmod{p^k}$了而x!中p的倍数显然有$\lfloor\dfrac{x}{p}\rfloor$个，于是我们就得到 \dfrac{x!}{p^{\lfloor\frac{x}{p}\rfloor}}=(\lfloor\dfrac{x}{p}\rfloor)!\prod\limits_{i=1,i\not\equiv 0\pmod{p}}^{n}i而最终我们要的结果是在模$p^k$意义下的，所以对于最右边求积的部分，我们可以将其改写成 \prod\limits_{i=1,i\not\equiv 0\pmod{p}}^{n}i=(\prod\limits_{i=1,i\not\equiv0\pmod{p}}^{p^k}i)^{\lfloor \frac{n}{p^k}\rfloor}(\prod\limits_{i=p^k\times\lfloor \frac{n}{p^k}\rfloor,i\not\equiv0\pmod{p}}^{n}i)对后面的部分求解完后，看看前面的，$(\lfloor\dfrac{x}{p}\rfloor)!$中可能还有p这个质因子，因此我们递归下去继续求解。到此，整个求解过程就结束了。 下面给出模板123456789101112131415161718192021222324252627282930313233343536373839404142ll inv(ll n, ll p) &#123; //exgcd求逆元 ll x, y; exGCD(n, p, x, y); return (x % p + p) % p;&#125;ll fac(ll n, ll p, ll mul) &#123; //求%mul意义下的阶乘 if (!n)return 1; ll ans = 1; for (ll i = 2; i &lt;= mul; ++i) if (i % p)(ans *= i) %= mul; //循环节 ans = ksm(ans, n / mul, mul); //余项 for (ll i = 2; i &lt;= n % mul; ++i) if (i % p)(ans *= i) %= mul; return ans * fac(n / p, p, mul) % mul;//递归求解&#125;ll C(ll n, ll m, ll p, ll mul) &#123; //求%mul意义下的组合数C(n,m) ll up = fac(n, p, mul), d1 = fac(m, p, mul), d2 = fac(n - m, p, mul); ll k = 0; for (ll i = n; i; i /= p)k += i / p;//x for (ll i = m; i; i /= p)k -= i / p;//y for (ll i = n - m; i; i /= p)k -= i / p;//z return up * inv(d1, mul) % mul * inv(d2, mul) % mul * ksm(p, k, mul) % mul;&#125;ll exLucas(ll n, ll m, ll mod) &#123; ll lim = sqrt(mod), tmp = mod; *p = 0; for (int i = 2; i &lt;= lim; ++i) &#123; if (tmp % i == 0) &#123; p[++*p] = i; mulp[*p] = 1; while (tmp % i == 0)mulp[*p] *= i, tmp /= i; &#125; &#125; if (tmp != 1)p[++*p] = tmp, mulp[*p] = tmp; for (int i = 1; i &lt;= *p; ++i) b[i] = mulp[i], a[i] = (C(n, m, p[i], mulp[i]) % b[i] + b[i]) % b[i]; return CRT(*p);//构成的模方程组为x=a(mod b)&#125;]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫环问题]]></title>
    <url>%2F2020%2F11%2F17%2F%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[经典问题简述有n个人，按编号1,2,3,…,n围成一圈，1与n相邻，现在从1开始往2的方向报数，报到m的人出列，然后下一个人从1开始重新报数，最后留下的人编号是几？ O(nm)暴力模拟最朴素的想法，我们直接模拟报数的过程，暴力比较简单这里不多做解释。 O(n)解法我们考虑能不能通过递推的方式求解，为了方便计算，我们先将所有人的编号用0~n-1表示，然后考虑每次有人出列后，将所有人的编号重排。比如对于n=5,m=3，其原编号为0 1 2 3 4在2出列后，编号为0 1 x 3 4重排后为2 3 x 0 1我们观察一下出列后重排前后序列之间的关系我们设出列时的人编号为k，重排前某人编号为p(p!=k)，重排后同一人编号为q，出列前总人数N那么显然有q=(p-(k+1)+N)%N，且k=(m-1)%N，我们只需要看，0向后移动了k+1位，就可以很容易推出该结论所以p=(q+k)%N=(q+m)%N，参照我们上面的定义，其实递推式已经很明显了为了方便描述，设$f(i,m)$为i人按题目的游戏规则最后出列人的编号(0~i-1)，则有 \begin{cases} f(1,m)=0\\ f(i,m)=(f(i-1,m)+m)\bmod i \end{cases}于是我们的问题就能线性求解了 123for (int i = 2; i &lt;= n; ++i) ans = (ans + m) % i;++ans;//我们的编号是0~n-1，题目要求是1~n O(logn)解法O(n)的解法似乎已经是最优解了，但人类不愿止步于此，于是又搞出来一个$O(\log n)$解法，当然，这里的$O(\log n)$是针对m比较小的情况，也就是认为m是一个常数，实际上m如果太大复杂度依然和$O(n)$或者$O(m)$差不多。 第一个解法我们考虑改变递推的策略，考虑当一圈人报数回到0时是什么样子，当人数减小到$m$时对剩下的部分按$O(n)$递推方法求解，换句话说，我们加速上述算法中$n&gt;m$的部分。我们依然是0~n-1表示当前人的编号，报过一圈后从最后一个出列的人开始从0起重编。例如n=8，m=3，那么初始序列为0 1 2 3 4 5 6 7报数后为0 1 x 3 4 x 6 7重排后为2 3 x 4 5 x 0 1现在我们依然是想通过$i-1$的答案推出$i$的答案，所以我们看看重排后的序列与重排前有什么关系我们设$i-1$规模的答案为q，%i%规模的答案为p首先我们观察到，最后一个x后人的个数为i%m，那么如果q &lt; i % m，则$p=q+(i-i\bmod m)$，也就是将直到最后一个x的部分的人数加回来否则，$p=q-i\bmod m+\lfloor\dfrac{q-i\bmod m}{m-1}\rfloor$，也就是说先减掉后面0~i%m-1的部分，然后加上前面删掉的人数，这里由于我们用的q是删后的序号，所以应该是除以$m-1$而不是除以$m$来得到删掉的人数。12345678int getans(int n, int m) &#123; if (n == 1)return 0; if (n &lt;= m)return (getans(n - 1, m) + m) % n; int s = getans(n - n / m, m) - n % m; if (s &lt; 0)s += n; else s += s / (m - 1); return s;&#125; 第二个解法（有问题）该解法可以求出第k(从0开始计数)个出列的人的编号，令k=n-1则得到原问题的答案。显然我们可以知道，第k个出列的人是第$k\cdot m+m-1$次报数的人（这里以及以后所有的“第”后面都是从0开始计数的，便于计算）那么我们通过这次报数往回追踪，每次计算上一次他是第几个报的数，就能找到最初当这个人报的数在$0~n-1$时报的数，即他的原始编号（从0计）。此处我们利用的是总报数的次数与编号的关系，所以没有重排。我们设报第p次的人为x，下一次他报数的次数为第q次，显然p可以表示为$p=a\cdot m+b,(0\le b&lt; m)$那么显然经过p次报数，出列了a个人，这时还剩n-a人，所以q=p+n-a，反过来就是p=q-n+a现在的问题就是a是多少，我们需要建立a与q的关系，这样才能由q算出p，由上面的算式可以推出$q=p+n-a=a\cdot(m-1)+n+b$由于x在报数后存活，所以b &lt; m-1，因此$a=\lfloor\dfrac{q-n}{m-1}\rfloor$（这一步我觉得有问题）最终算式就是$p=q-n+\dfrac{q-n}{m-1}$所以我们的策略就很明显了 12345int getans(int n, int m, int k) &#123; if (m == 1)return n - 1; for (k = k * m + m - 1; k &gt;= n; k = k - n + (k - n) / (m - 1)); return k;&#125;]]></content>
      <categories>
        <category>专题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>约瑟夫环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串（二）]]></title>
    <url>%2F2020%2F11%2F12%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[后缀数组（SA）首先需要了解几个字符串中的基本定义： 子串：字符串s中任意截取的一段字符串t称t为s的子串 后缀：字符串s中从任一位置到字符串末尾的子串称为后缀，记为suf(i) 后缀数组：将s的所有后缀按照字典序进行排序，后缀对应的下标组成后缀数组，记sa[i]表示排名为i的后缀起始位置，rk[i]表示起始位置为i的后缀排名 SA求法这里给出一种常用解法。 基本思想：我们通过倍增的思想，对每个位置以长度为1的子串开始排序，每次将排序的长度翻倍，这样的话就能利用上一次排序的结果通过$\log n$次双关键字排序得到新的排序结果，而这里的排序我们选择基数排序来降低复杂度。 12345678910111213141516171819202122232425262728void radix_sort() &#123; memset(tong, 0, sizeof(int) * (m + 1)); //b存储第一关键字，其内顺序由第二关键字决定 for (int i = 1; i &lt;= n; ++i)++tong[rk[b[i]]]; for (int i = 1; i &lt;= m; ++i)tong[i] += tong[i - 1]; for (int i = n; i; --i)sa[tong[rk[b[i]]]--] = b[i];&#125;void getsa() &#123; m = 27; for (int i = 1; i &lt;= n; ++i) b[i] = i, rk[i] = s[i] - 'a' + 1; radix_sort(); for (int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; int tot = 0; for (int i = n - k + 1; i &lt;= n; ++i)b[++tot] = i;//没有第二关键字的排名靠前 for (int i = 1; i &lt;= n; ++i) if (sa[i] &gt; k)//枚举第二关键字 b[++tot] = sa[i] - k;//sa[i] - k是第一关键字 radix_sort();//求出sa swap(b, rk);//b是旧的rk，以此计算新的rk存储在rk中 rk[sa[tot = 1]] = 1; for (int i = 2; i &lt;= n; ++i) if (b[sa[i]] == b[sa[i - 1]] &amp;&amp; b[sa[i] + k] == b[sa[i - 1] + k])rk[sa[i]] = tot;//两个关键字都与前一个相同，排名也相同 else rk[sa[i]] = ++tot; if (tot == n)break; m = tot; &#125;&#125; LCP求法后缀数组最重要的作用就是可以求LCPLCP，即最长公共前缀，也就是两个字符串的前缀中相同且最长的子串长度。在这里，我们定义LCP(i,j)为suf(sa[i])和suf(sa[j])的LCP，即排名分别为i和j的两个后缀的LCP。显然我们有： $LCP(i,j)=LCP(j,i)$ $LCP(i,i)=n-sa[i]+1$ 接下来就需要证明几个重要的定理 LCP Lemma LCP(i,k)=\min\{LCP(i,j),LCP(j,k)|1\le i\le j\le k\}设$x=suf(sa[i]),y=suf(sa[j]),z=suf(sa[k]),p=min(LCP(i,j),LCP(j,k))$显然x与y的前p个字符相等，y与z的前p个字符相等，因此x与z的前p个字符相等，即$LCP(i,k)\ge p$j在i和k之间，根据字典序，LCP(i,j)与LCP(j,k)都大于等于LCP(i,k)，因此$LCP(i,k)\le p$综上，$LCP(i,k)=p=min(LCP(i,j),LCP(j,k))$ LCP Theorem根据LCP Lemma，我们不难得出 LCP(i,k)=\min\{LCP(i,i+1),LCP(i+1,k)\}=...=\min\{LCP(j,j-1)|1\le i< j\le k\}Height数组height数组是求LCP中最重要的一环。我们定义height[i]=LCP(i,i-1)，为了描述方便，设h[i]=height[rk[i]]则有 h[i]\ge h[i-1]-1我们设k=sa[rk[i-1]-1]，显然LCP(rk[i-1],rk[k])=h[i-1]现在我们来看看suf(k+1)与suf(i): $s[k]\not=s[i-1]$此时h[i-1]=0，LCP Theorem显然成立 $s[k]=s[i-1]$此时suf(i)是suf(i-1)去掉首字符得到的，suf(k+1)是suf(k)去掉首字符得到的，因此suf(i)和suf(k+1)之间的排名关系与suf(i-1)和suf(k)之间的排名关系相同，所以rk[k+1]&lt; rk[i]，而且，LCP(rk[k+1],rk[i])=LCP(rk[k],rk[i-1])-1=h[i-1]-1根据定义，h[i]=LCP(rk[i],rk[i]-1)接下来只要证明$\max\{LCP(rk[i], j)|j&lt; rk[i]\}=LCP(rk[i],rk[i]-1)$又因为rk[k+1]&lt;=rk[i]-1，就可得出h[i]&gt;=LCP(rk[k+1],rk[i])=h[i-1]-1而这个证明非常简单，根据字典序，suf(sa[j])的前h[i]个字符只能是suf(sa[rk[i]-1])的前h[i]个字符变小形成，这就保证了j减小的过程中LCP(rk[i],j)不会变大。 求LCP有了上面的性质和定理，我们就可以在线性复杂度内求出height数组123456789101112void getheight() &#123; int k = 0; for (int i = 1; i &lt;= n; ++i)rk[sa[i]] = i; for (int i = 1; i &lt;= n; ++i) &#123; //这里i枚举的是位置而不是排名 if (rk[i] == 1)continue; int j = sa[rk[i] - 1]; if (k)--k;//h[i]&gt;=h[i-1]-1，因此从h[i-1]-1开始检验 while (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k])++k;//直接找 height[rk[i]] = k; &#125;&#125; 根据LCP Theorem和height的定义，$LCP(i,j)=\min\{height[k]|i&lt;k\le j\}$我们用ST表来维护height的区间最小值，即可做到O(1)查询LCP 12345678910111213int LCP(int l, int r) &#123;//l和r都是rk值 if (l == r)return n - sa[l] + 1; if (l &gt; r)swap(l, r); ++l; int k = r - l + 1; return min(ST[l][k], ST[r - (1 &lt;&lt; k) + 1][k]);&#125;void init(int n) &#123; for (int i = 1; i &lt;= n; ++i)ST[i][0] = height[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) ST[i][j] = min(ST[i][j - 1], ST[i + (1 &lt;&lt; j - 1)][j - 1]);&#125; 后缀自动机、后缀树（SAM）]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>后缀数组SA</tag>
        <tag>后缀自动机SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划（二）]]></title>
    <url>%2F2020%2F11%2F05%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[DP的优化形式优化有时在解决DP问题时会遇到时间或空间复杂度过高的情况，这时候从DP的形式上进行优化是从根本上改进复杂度，典型的处理方式有预处理、分阶段DP等： 预处理：在DP过程中出现的大量重复的计算，往往可以通过预处理来节省重复计算的时间，通常我们在DP前预处理，或者在DP过程中处理出最值。 分阶段DP：在某些DP中将DP拆分成若干个不相关的转移，分开考虑，也许可以降低复杂度。 例题一、最长公共子序列给定长度为N,M的数组A,B，求最长公共上升子序列的长度。 $N,M\le 5000$ Solution设dp[i,j]表示数组A考虑到i，数组B考虑到j且以B[j]结尾的最长公共上升子序列长度。那么显然，当$A_i=B_j$时，我们有$dp[i][j] = \max\{dp[i-1][k]|k&lt;j,B_k&lt;B_j\}+1$但是呢，这样转移总时间复杂度是$O(n^3)$的，因此我们需要对我们的DP形式进行优化。考虑到$A_i=B_j$，那么实际上对于同一个$A_i$，对k的限制是相同的，因此我们只需要在枚举j的过程中动态维护$\max\{dp[i-1][k]|B_k&lt;A_i\}$，直接转移即可。 决策单调性优化四边形不等式优化对于如下形式的dp： f(i,j)=f(i,k-1)+f(k,j)+w_{i,j}若$w$满足四边形不等式： 任意$i\le i’\le j\le j’$，有$w_{i,j}+w_{i’,j’}\le w_{i’,j} + w_{i,j’}$ 任意$i’\le i\le j\le j’$，有$w_{i,j}\le _{i’,j’}$ 则 f(i,j)+f(i',j')\le f(i',j)+f(i,j')可得$f(i,j)$的决策一定在$f(i,j-1)$的决策与$f(i-1,j)$的决策之间。 1D/1D动态规划方程优化对于形如 f(i)=\min\{f(j)+w_{j,i}|j\le i\}若$w$满足四边形不等式，则$f(i)$的决策也一定单调。这里的决策也就是j的实际取值 例题一、诗人小G题面 Solution由题意推得 f(i)=\min\{f(j)+\left|sum_i-sum_j+(i-j-1)-L\right|^p|j]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划（一）]]></title>
    <url>%2F2020%2F10%2F28%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[DP类型DP的一般形式是表示出能代表出与后续或答案有关的当前的状态，并在这些状态中进行转移DP的难点在于状态的设计和转移的优化。由于DP属于一种思想，不同的情况下状态设计和转移都不一样，下面对于每种DP都会给出问题来讲解。 序列DP将问题放在序列上，在序列上设计状态和转移，是一种非常常见的DP。题目：洛谷P2519 [HAOI2011]problem a 模型建立求最少有多少人没说真话，可以先求最多有多少人说真话。我们考虑将所有人的成绩排序后的一个序列A。第i个人说的是真话，当且仅当$A_{a_i+1}=…=A_{n-b_i}$，将这个区间看成一条线段，这样的话n个人就是n条线段。不难发现，如果两条线段相交但不重合，说明两个人中至少一人说了谎，而且对某一线段重合的线段个数不能超过线段的长度（包含的点数）。这样的话，我们的问题就转化成，对于n个线段，选出最多的线段个数，使得这些线段要么不相交，要么完全重合且对于同一个线段重合的线段个数不超过该线段的长度。 状态设计及转移优化重合的线段我们都放到一起，记一个总数并与长度取较小值，这样的话任意两条线段都是不重合的，那么就只用考虑不相交了如何我们以右端点为第一关键字，以左端点为第二关键字进行排序，显然我们遍历所有线段，那么如何设计状态呢？设dp[i]为前i个线段中能选的线段的最多个数，那么转移方程显然为$dp[i]=dp[last]+cnt$，其中last为右端点小于i左端点的最后一个线段，cnt为前面提到的总数。对每个i枚举j，复杂度为$O(n^2)$，所以我们要对这部分进行优化。考虑到我们的线段是以r为右端点为第一关键字排序的，也就是说线段的右端点是有序的，那么我们就可以二分找到右端点比i的左端点小的最靠后的线段，将dp记录成前缀最大值，就可以$O(\log n)$查找线段，$O(1)$转移了。 Solution(Accepted)1234567891011121314151617181920212223242526272829303132333435363738struct Segment &#123; int l, r, cnt; Segment() &#123;&#125; Segment(int l, int r): l(l), r(r) &#123; cnt = 1; &#125; bool operator &lt;(const Segment s)const &#123; return r &lt; s.r || (r == s.r &amp;&amp; l &lt; s.l); &#125;&#125;s[N], S[N];int dp[N];//二分查找，找到需要的线段int bin(int l, int r, int x) &#123; while (l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if (S[mid].r &lt;= x)l = mid + 1; else r = mid - 1; &#125; return r;&#125;int main(void) &#123; int n = fast_IO::read(), tot = 0; for (int i = 1; i &lt;= n; ++i) s[i] = Segment(fast_IO::read() + 1, n - fast_IO::read()); sort(s + 1, s + n + 1); for (int i = 1; i &lt;= n; ++i) &#123; if (s[i].l &gt; s[i].r)continue; if (s[i].l == s[i - 1].l &amp;&amp; s[i].r == s[i - 1].r) &#123; if (S[tot].cnt &lt; S[tot].r - S[tot].l + 1) ++S[tot].cnt; &#125; else S[++tot] = s[i]; &#125; dp[1] = S[1].cnt; for (int i = 2; i &lt;= tot; ++i) &#123; int pre = bin(1, i - 1, S[i].l - 1); dp[i] = max(dp[i - 1], dp[pre] + S[i].cnt);//转移 &#125; fast_IO::write(n - dp[tot]); return 0;&#125; 区间DP区间DP的状态一般表示为$dp[i][j][…]$，即区间$[i,j]$这一段的答案。 例题CF1132F. Clear the String题目大意是给你一个长度为$n\le 500$的字符串，每次可以删去一段由相同字符构成的连续子串，问删完所有字符最少需要多少次操作。 Solution这是一道非常模板的区间DP，我们设$dp[l][r]$为删去区间$[l,r]$的所有字符需要的最少操作次数。至于转移，区间DP常用的方法是枚举区间大小进行转移，这里也是如此。我们从小到大枚举区间的大小，然后枚举该大小的区间： 若区间两端相等，说明可以通过删去中间后两端连在一起删 若区间两端不相等，我们将区间分成两段，分别去删，取最小的次数。 于是我们的转移方程就出来了： $s[l]=s[r],dp[l][r]=min\{dp[l+1][r],dp[l][r-1]\}$ $s[l]\not=s[r],dp[l][r]=min\{dp[l][r],dp[l][k]+dp[k+1][r]|l\le k&lt; r\}$ 123456789for (int len = 2; len &lt;= n; ++len) &#123; for (int l = 1, r = len; r &lt;= n; ++l, ++r) &#123; if (s[l] == s[r])dp[l][r] = min(dp[l + 1][r], dp[l][r - 1]); else &#123; for (int k = l; k &lt; r; ++k) dp[l][r] = min(dp[l][r], dp[l][k] + dp[k + 1][r]); &#125; &#125;&#125; 数位DP数位DP常用于统计或查找一个区间满足条件的数，然后按数位顺序DP，一般需要仔细分情况讨论。常见处理方式有：拆成[1,R]和[1,L)，记忆化，预处理等。洛谷P2657 [SCOI2009] windy 数 状态建立及转移一道相当常规的数位DP，我们可以将[L,R]的答案拆成[1,R]-[1,L-1]的答案，这样的话我们只要能计算1到x的windy数就可以了。我们设dp[i][j]表示i位数最高位为j时的windy数，显然的转移是$dp[i][j]=sum(dp[i-1][k])$，其中k满足$abs(k-j)\ge 2$接下来我们就用dp来求解[1,x]的所有windy数12345678910111213141516171819202122232425262728293031323334353637383940414243444546int dp[N][N], num[N];void presolve() &#123; for (int i = 0; i &lt;= 9; ++i)dp[1][i] = 1; //这里要包括0的原因是我们dp的过程中，类似于20 30这些数依然是windy数，所以0虽然不是windy数，但却能产生贡献 for (int i = 2; i &lt;= 10; ++i) &#123; for (int j = 0; j &lt;= 9; ++j) &#123; for (int k = 0; k &lt;= 9; ++k) &#123; if (abs(j - k) &lt;= 1)continue; dp[i][j] += dp[i - 1][k]; //为什么这里j k要从0开始呢？这是考虑到我们会求在高位都一定时，从某位开始的所有windy数 //此时这些位就可能是0了 &#125; &#125; &#125;&#125;int solve(int x) &#123; if (!x)return 0; int ans = 0; for (*num = 0; x; x /= 10) num[++*num] = x % 10; for (int i = *num - 1; i &gt;= 1; --i) for (int j = 1; j &lt;= 9; ++j)//这里j不从0开始的原因很简单，j为0的话实际上数字就不是i位了，会重复计算 ans += dp[i][j]; //唯独*num位数最麻烦 for (int i = 1; i &lt; num[*num]; ++i) ans += dp[*num][i]; //接下来专注于最高位为num[*num]时的*num位数 for (int i = *num - 1; i &gt;= 1; --i) &#123; //从次高位开始一直到最低位，每一步计算当前位比num[i]小的数的所有贡献（因为后面的所有数都能取到， //只用考虑当前位与高一位是否冲突），之后只剩这一位为num[i]的情况，我们就再去求下一位的所有贡献 for (int j = 0; j &lt; num[i]; ++j) &#123; if (abs(j - num[i + 1]) &gt;= 2) ans += dp[i][j]; &#125; if (abs(num[i + 1] - num[i]) &lt; 2)return ans; //这时已经不可能再有多的贡献，因为在接下来的计算中我们的前提就是前面的所有位都是确定的，所以此处必然使剩下的所有数不成立 &#125; return ans + 1;//上面的计算并没有包括自身，此处要加上自身&#125;int main(void) &#123; presolve(); int l = fast_IO::read(), r = fast_IO::read(); fast_IO::write(solve(r) - solve(l - 1)); return 0;&#125; 概率DP概率DP是求事件概率或期望的DP的总称。对于求概率问题，有时利用补集转化，或者将其转化为计数问题；对于求期望问题，大多时候利用期望的线性性来解决问题。 贝叶斯公式条件概率$P(y|x)$联合概率$P(y,x)$$P(x,y)=P(y|x)P(x)=P(x)P(y)$$P(x,y)=P(x|y)P(y)$贝叶斯公式：$P(y|x)=\dfrac{P(x|y)P(y)}{P(x)}$ 例题：期望的线性性洛谷P3239 [HNOI2015]亚瑟王题目概述：给你$N$张牌，每张牌有一个发动概率$P_i$以及伤害$D_i$。共有$R$回合，每回合会按编号从小到大依次考虑本次游戏中还未发动的卡牌，依次尝试发动；如果发动成功，进入下一回合。求期望伤害之和。共$T$组数据。$T\le 444,N\le 220,R\le 132$ 这个题如果直接去算每一局的期望，非常难设状态（需要状压），而根据期望的线性性，我们考虑每张牌被发动的概率，那么总伤害就为每张牌造成的期望伤害之和。我们设dp[i][j]表示前i张牌中一共出了j张的概率，sump[x]表示x这张牌在整局游戏中被打出来的概率。对于转移，首先我们来看sump的转移，我们枚举前i-1张牌中出牌数j，由题意可知i之前打出的j张牌都不会考虑到第i张牌（因为打出去以后本轮就结束了），同时也说明有r-j轮可能会考虑到第i张牌，于是我们的转移方程就出来了，$sump[i]=\sum\limits_{j=0}^rdp[i-1][j]\cdot(1-(1-p[i])^{r-j})$，此处要注意，我们将“中间某处选第i张牌”采用了补集转换的思想，因为求出“中间没有任何一处选第i张牌”显然是更方便的。再来看看dp[i][j]的转移，这里显然要分两种情况讨论：是否选择了当前的第i张牌： 没有选择，那么$dp[i][j]=dp[i-1][j]\cdot (1-p[i])^{r-j}$，与上面类似，这里是后面r-j轮都不选i 若选择了，那么$dp[i][j]=dp[i-1][j-1]\cdot(1-(1-p[i])^{r-j+1})$，也是类似，前j-1张不可能选到i 最后答案即为$\sum\limits_{i=1}^nsump[i]\times d[i]$ 1234567891011121314151617181920212223242526272829303132double p[N], dp[N][N], sump[N], sum[N][N];int d[N];int main() &#123; int T = fast_IO::read(); while (T--) &#123; memset(dp, 0, sizeof(dp)); memset(sump, 0 , sizeof(sump)); int n = fast_IO::read(), r = fast_IO::read(); for (int i = 1; i &lt;= n; ++i) scanf("%lf%d", p + i, d + i); for (int i = 1; i &lt;= n; ++i) &#123; sum[i][0] = 1; for (int j = 1; j &lt;= r; ++j) sum[i][j] = sum[i][j - 1] * (1 - p[i]); //注意到我们后面总是用到1-p[i]的幂，先预处理 &#125; dp[1][0] = sum[1][r]; dp[1][1] = sump[1] = 1 - sum[1][r]; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= r; ++j) &#123; sump[i] += dp[i - 1][j] * (1 - sum[i][r - j]); dp[i][j] += dp[i - 1][j] * sum[i][r - j]; if (j)dp[i][j] += dp[i - 1][j - 1] * (1 - sum[i][r - j + 1]); &#125; &#125; double ans = 0; for (int i = 1; i &lt;= n; ++i)ans += sump[i] * d[i]; printf("%.10f\n", ans); &#125; return 0;&#125; 树形DP树形DP是指基于树形结构的动态规划，一般有： 树的直径：DP记录子树内的最长路 树的重心：DP记录子树大小 树上点权独立集：DP记录子树的根是否选择 树形依赖背包：在dfs序上DP，或通过将父节点的DP值传入孩子DP 虚树：后面会重点讲 … 虚树在原树上保留需要的点和它们的LCA的树成为虚树，换句话说，我们尽可能合并了中间的点。 状压DPDP套DP背包专题背包是线性DP中的重要模型 0/1背包所谓0/1背包，就是一堆物品分别有价值w[i]和占用空间v[i]，每种物品都是一个，现在要用空间大小为m的背包装物品，求出所装物品的价值和最大值是多少。而最基础的想法，就是直接设状态$dp[i][j]$表示前i个物品中用大小为j的背包能得到的最大价值，转移也很明显$dp[i][j]=max\{dp[i-1][j-v[i]]+w[i]|v[i]\le j\le m\}$。我们发现每次转移只和上一行有关，于是可以用滚动数组优化空间。更仔细地观察发现，我们都是用前面的值去更新后面的值，于是我们改变j的枚举顺序，从大到小枚举，就可以只用一维数组来达到目的。这样的话空间复杂度$O(m)$，时间复杂度$O(nm)$ 123for (i = 1; i &lt;= n; ++i) for (j = m; j &gt;= v[i]; --j) dp[j] = max(dp[j], dp[j - v[i]] + w[i]); 完全背包完全背包就是在0/1背包的基础上对物品的个数没有限制，求相同的问题。其实只要我们把上面优化过的0/1背包改变枚举顺序，就是完全背包了，因为我们允许对同一个物品重复选择。123for (i = 1; i &lt;= n; ++i) for (j = v[i]; j &lt;= m; ++j) dp[j] = max(dp[j], dp[j - v[i]] + w[i]); 多重背包上面两种背包都是非常特殊的情况，更一般的，我们考虑每个物品i分别有$C[i]$个，那么问题就变成了多重背包。一种非常暴力的做法就是将$C[i]$个物品全部拆开，将问题变成0/1背包，这样的话时间复杂度是$O(\sum\limits_{i=1}^nC[i]m)$。这个复杂度是比较高的，那么有没有什么更好的办法呢？ 二进制拆分我们还是考虑将$C[i]$拆分，但我们采用更优秀的拆分方法，使得拆出来的物品尽量少，而且这些物品的组合可以表示$1\sim C[i]$中的任何一个数。我们考虑将其拆分成$C[i]=2^0+2^1+2^2+…+2^k+rest,rest&lt;2^{k+1}$，这样的话对于$x&lt;2^{k+1}$都可以很容易凑出，而对于$2^{k+1}\le x\le C[i]$，我们发现$x-rest&lt; 2^{k+1}$，也就是说$x-rest$是可以通过前面的部分组合出来的，因此我们可以组合出任意一个x。 123456//C进行拆分for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; (1 &lt;&lt; j) &lt;= C[i]; ++j) vt[++tot] = (1 &lt;&lt; j) * v[i], wt[tot] = (1 &lt;&lt; j) * w[i]; if (C[i])vt[++tot] = C[i] * v[i], wt[tot] = C[i] * w[i];&#125; 这样同样将问题转化成了0/1背包，但是时间复杂度更优秀，为$O(nm\log\max(C_i))$。 单调队列优化我们仔细观察转移的过程，寻找规律，来看看转移方程$dp[i][j]=\max\{dp[i-1][j],dp[i-1][j-k\cdot v[i]]+k\cdot w[i]|k\in [1,\min(\dfrac{m}{C[i]},C[i])]\}$我们发现，j mod v[i]相同时的j之间才会产生转移，于是我们可以按这个进行分组。而考虑到能转移到j的是区间$[j-C[i]*v[i],j]$的最大值，因此我们用复杂度优秀的单调队列来完成维护最大值的工作。那么总复杂度是多少呢？我们枚举了n类物品，对每类物品i分成C=v[i]类，枚举k的范围是$\dfrac{m}{v[i]}$，因此总复杂度为$O(nm)$ 1234567891011for (int i = 1; i &lt;= n; ++i) &#123; for (int ret = 0; ret &lt; v[i]; ++ret) &#123; head = 1, tail = 0; for (int k = 0; k * v[i] + ret &lt;= m; ++k) &#123; while (tail &gt;= head &amp;&amp; k - q[head] + 1 &gt; C[i])++head; dp[i][k * v[i] + ret] = dp[i - 1][q[tail] * v[i] + ret] + k * w[i]; while (tail &gt;= head &amp;&amp; dp[i - 1][q[tail] * v[i] + ret] &lt; dp[i][k * v[i] + ret])--tail; q[++tail] = k; &#125; &#125;&#125; 分组背包给定N组物品，规定每组物品中最多选一个，求大小为m的背包能装的最大价值。事实上我们只需要先枚举组，再枚举背包的容量，再枚举组内物品就行了。倒序枚举背包容量，空间复杂度降到一维。1234for (int i = 1; i &lt;= n; ++i) for (int j = m; j &gt;= 0; --j) for (int k = 1; k &lt;= C[i]; ++k) dp[j] = max(dp[j], dp[j - v[i][k]] + w[i][k]); 树上背包咕咕咕]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学（一）]]></title>
    <url>%2F2020%2F10%2F28%2F%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[裴蜀定理$a\cdot x +b\cdot y=c,x,y\in N_+$成立的充要条件是$\gcd(a,b)|c$该定理可推广至多个未知数方程。 GCDGCD就是最大公约数，最大公约数和最小公约数的求法都非常简单，这里直接给出求法。最大公约数：通常采用辗转相除法，也可以使用更相减损术。我们主要用辗转相除法（欧几里得算法）。gcd具有一些性质： $\gcd(a,b)=\gcd(-a,b)$ $\gcd(a,b)=\gcd(b,a\bmod b)$，这个性质应用于辗转相除法 $\gcd(a,b)=\gcd(b, a -b)$，这个性质应用于更相减损术 12345ll GCD(ll a, ll b) &#123; while (a %= b) swap(a, b); return a;&#125; exGCD扩展欧几里得定律，用于求解形如$a\cdot x+b\cdot y=\gcd(a, b)$的不定方程。下面我们来简单说明一下其原理：由性质2可知$\gcd(a,b)=\gcd(b,a\bmod b)$我们设$\gcd(b,a\bmod b)=b\cdot x’+(a\bmod b)\cdot y’$则有$a\cdot x+b\cdot y=b\cdot x’+(a\bmod b)\cdot y’$我们知道，$a\bmod b=a-b\cdot\lfloor \dfrac{a}{b}\rfloor$由此得$a\cdot x + b\cdot y=a\cdot y’+b\cdot(x’-\lfloor\dfrac{a}{b}\rfloor)$因此我们可以知道，$x,y$的一组可行解为$(x,y)=(y’,x’-\lfloor\dfrac{a}{b}\rfloor)$那么其边界条件是什么呢？我们知道，欧几里得算法执行到最后$a’\bmod b’=0$，即$a’$一定是$b’$的整数倍，所以在我们递归下一次时，$y’$的系数实际上变成了0，而$x’$的系数为$b’$，且$b’=\gcd(a,b)$，因此边界条件为$x=1,y=0$。 于是我们的解法就出来了，递归地实现欧几里得算法，当求到边界时设$x=1,y=0$，然后在回溯的过程中根据上述推导的公式一步步求解。 1234567891011//这里要采用递归写法，因为要回溯ll exGCD(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; ll gcd = exGCD(b, a % b, x, y), tmpx = x; x = y; y = tmpx - a / b * y; return gcd;&#125; 显然，这里我们求出了一组可行解，很容易得出该不定方程的通解为$x’=x_0+\dfrac{k\cdot b}{\gcd(a,b)},y’=y_0-\dfrac{k\cdot a}{\gcd(a,b)}$。得到这个结果后，我们可以推导出一般的二元一次不定方程解法。对于$a\cdot x+b\cdot y=c$，若$\gcd(a,b)\not|c$则无解，否则我们将$a\cdot x_0+b\cdot y_0=\gcd(a,b)$变形为 a\cdot\dfrac{x_0\cdot c}{\gcd(a,b)} + b\cdot \dfrac{y_0\cdot c}{\gcd(a,b)}=c由此可知$x_1=\dfrac{c\cdot x_0}{\gcd(a,b)},y_1=\dfrac{c\cdot y_0}{\gcd(a,b)}$我们设$d\in Q$，则$a\cdot(x_1+d\cdot b)+b\cdot(y_1-d\cdot a)=c$显然，$\min\{d\}=\dfrac{1}{\gcd(a,b)}$，设$d_x=d_{\min}\cdot b,d_y=d_{\min}\cdot a$，则通解形式为 x = x_1+k\cdot d_x\\ y = y_1+k\cdot d_y\\ k\in ZCRT中国剩余定理，用于求解一元模方程组，即模意义下的一元方程组（每个方程的模数不同）使用CRT的前提是所有模方程的模数互质即对于 \begin{cases} x\equiv a_1\pmod {m_1}\\ x\equiv a_2\pmod {m_2}\\ ...\\ x\equiv a_n\pmod {m_n}\\ \end{cases}其中$m_1,m_2,…,m_n$两两互质 我们定义$M=\prod m_i$考虑每一个方程，只要我们能求出$x_i$使得$x_i$是$M_i=\dfrac{M}{m_i}$的倍数且$x_i\equiv 1\pmod{m_i}$，那么最终结果就是$\sum a_i\cdot x_i\bmod M$然后我们考虑一下我们对$x_i$的定义，我们会惊奇地发现，实际上$x_i=M_i^{-1}\cdot M_i$，其中$M_i^{-1}$为$M_i$在模$m_i$意义下的逆元所以我们最终的解为$x=\sum a_i\cdot M_i^{-1}\cdot M_i\bmod M$，此处求的是x的最小正整数解，通解$x’=x + k\cdot M$。1234567891011121314151617181920212223242526272829303132ll m[N], a[N], M;ll mul(ll a, ll b) &#123; ll ans = 0; for (; b; a = (a &lt;&lt; 1) % M, b &gt;&gt;= 1) if (b &amp; 1) (ans += a) %= M; return ans;&#125;ll EXGCD(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; ll gcd = EXGCD(b, a % b, x, y), tmpx = x; x = y; y = ((tmpx - a / b * y) % M + M) % M; return gcd;&#125;ll CRT() &#123; ll ans = 0, x, y; M = 1; for (int i = 1; i &lt;= n; ++i) &#123; m[i] = fast_IO::read(), a[i] = fast_IO::read(); M *= m[i]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; ll Mi = M / m[i]; EXGCD(Mi, m[i], x, y);//m[i]互质，所以Mi与m[i]互质，满足exgcd的条件 (ans += mul(mul(a[i], x), Mi)) %= M; &#125; return ans;&#125; exCRTCRT的使用条件是m[i]互质，如果m[i]不互质，我们引入扩展中国剩余定理。注意，exCRT的解法是完全跳出CRT思想的，不要认为exCRT是CRT的升级版。首先我们来考虑只有两个模方程的模方程组 \begin{cases} x\equiv a_1\pmod{m_1}\\ x\equiv a_2\pmod{m_2} \end{cases}这两个方程显然可以写成 x=a_1+m_1\cdot y_1\\ x=a_2+m_2\cdot y_2所以有 a_1+m_1\cdot y_1=a_2+m_2\cdot y_2\\ a_1-a_2=m_2\cdot y_2-m_1\cdot y_1我们令$m_1\cdot a+m_2\cdot b=\gcd(m_1,m_2)$由裴蜀定理，当$\gcd(m_1,m_2)\not|(a_1-a_2)$无解，否则$y_1=-\dfrac{a_1-a_2}{\gcd(m_1,m_2)}\cdot a,y_2=\dfrac{a_1-a_2}{\gcd(m_1,m_2)}\cdot b$我们令$A=a_1+m_1\cdot y_1$，则该模方程组的解为$x\equiv A\pmod{ { \rm{lcm} } (m_1,m_2)}$这时候相当于我们将这两个模方程合并了，那么推广一下，对任意个数的模方程都可以这样合并。12345678910111213141516171819202122232425262728293031ll mul(ll a, ll b, ll p) &#123; ll ans = 0; for (; b; a = (a &lt;&lt; 1) % p, b &gt;&gt;= 1) if (b &amp; 1)(ans += a) %= p; return ans;&#125;ll exGCD(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; ll gcd = exGCD(b, a % b, x, y), tmpx = x; x = y; y = tmpx - a / b * y; return gcd;&#125;ll exCRT(int n) &#123; ll a1 = a[1], m1 = m[1]; for (int i = 2; i &lt;= n; ++i) &#123; ll a2 = (a[i] % m[i] + m[i]) % m[i], m2 = m[i]; ll del = ((a1 - a2) % m2 + m2) % m2 , x, y; ll gcd = exGCD(m1, m2, x, y); m2 /= gcd; if (del % gcd)return -1;//由裴蜀定理，无解 ll y1 = -mul(x, del / gcd, m2); a1 += m1 * y1; m1 = m1 * m2; a1 = (a1 % m1 + m1) % m1; &#125; return a1;&#125;]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串（一）]]></title>
    <url>%2F2020%2F10%2F28%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[哈希哈希的基本思想就是将信息量大的字符串压缩成信息量小的表达形式。我们将字符串转化成一个整数，便于进行存储和比较，而且我们要保证对于不同的字符串，转化成的整数也是不同的。那么具体如何转化呢？常用的方法是对每个字符换成一一对应的数字idx(s[i])，哈希模型为Hash(i)=Hash(i-1)p+idx(s[i])，其中p为素数，最终算出的Hash(n)即为字符串的哈希值，我们的任务就是构造哈希函数使得不同字符串的*哈希冲突率尽量小。 常见哈希方法自然溢出利用unsigned long long 自然溢出，直接用Hash[i]=Hash[i-1]*p+idx(s[i]) 单哈希自己规定模数，Hash[i]=(Hash[i-1]*p+idx(s[i]))%mod这里mod也为素数，且mod越大哈希冲突率越小 双哈希我们将同一个字符串用不同的模数哈希两次构成一个pair，这样的话就更加保险。 子串的哈希值求出一个字符串的哈希值后，其子串的哈希值是可以O(1)求出的。 KMPKMP主要用于字符串匹配，其复杂度为$O(N+M)$，其中N是主串的长度，M是模式串的长度。 基本思想我们求出当模式串中字符串匹配到i时，若匹配失败，应该从什么位置继续匹配（可能有点绕…）比如，模式串中间某一段正好与模式串的一个前缀相同，那么我们在中间这段匹配失败时，跳到这个前缀相应位置显然是更优的方法，这样也避免了我们对主串每一个位置都用整个模式串去匹配，总的来说，我们去掉了很多冗余重复的匹配，将复杂度从$O(nm)$降到了$O(n+m)$记这个数组为next，事实上，next数组也可以称为最长公共前后缀，即$next[i]$为子串$[1,i]$的最长公共前后缀。现在我们来看看next数组的求法。 next的构建考虑到上面我们对next的定义，next数组只与模式串有关，我们通过模式串匹配自身来求next数组。我们用一个指针i，i按顺序扫过整个模式串，再用一个指针j，用于标记next[i]的位置，从而达到求next的目的。在这里我们再次明确，next[i]表示当前最多匹配到i（也就是i+1匹配失败）时，应该从哪个位置继续进行匹配。1234567nt[0] = -1, i = 0, j = -1;//我的个人习惯，KMP的时候字符串从0开始，但nt是从1开始的，表示“第i个字符”while (i != lent) &#123; if (j == -1 || t[i] == t[j])nt[++i] = ++j;//这里其实++i表示的是串中i的位置，++j表示的是串中j+1的位置 //因为如果在i+1这里匹配失败，显然是将匹配失败的字符与j+1位置开始继续匹配 else j = nt[j];//这里前面的nt都已经算出来了，匹配失败直接跳&#125; 匹配匹配与求next就非常像了123456789101112i = j = 0;while (i &lt; lens) &#123; if (j == -1 || s[i] == t[j]) &#123; ++i; ++j;//匹配成功，继续匹配 if (j == lent) &#123; //这里成功匹配了一个完整的模式串 //进行相应操作 j = nt[j];//其实这里的nt[j]直接就是0了，从第一个开始配 &#125; &#125; else j = nt[j];&#125; 扩展KMP不会 Trie树Trie树即字典树，用树形结构存储多个字符串，构建方法其实很简单：从根节点开始往下找，如果有当前串的对应字符就走到下个点，否则开新节点，像这样录入所有的字符串即可。123456void insert(char *s) &#123; int now = root, len = strlen(s); for (int i = 0; i &lt; len; ++i) if (son[now][s[i]])now = son[now][s[i]]; else now = son[now][s[i]] = ++tot;&#125; 可持久化Trie树与主席树的思想类似，我们可以构造可持久化Trie树，也是考虑结构相同的Trie树可减，合并相同部分节省空间。12345678void insert(int pre. int &amp;now, char *s) &#123; now = ++tot; for (int i = 0; i &lt; 26; ++i) c[now][i] = c[pre][i]; sum[now] = sum[pre] + 1; if (!*s)return; insert(c[pre][*s], c[now][*s], s + 1);&#125; AC自动机KMP只支持单模式串的匹配，而AC自动机支持多模式串匹配。事实上，AC自动就相当于将KMP放到了树上，这棵树是一棵Trie树。 构建我们将所有的模式串建成一棵Trie树，然后类似于KMP，我们要求fail指针。这里我们fail指针的求法是利用BFS来求解的，显然对于每个模式串的第一个字母（也就是第一层的所有节点）的fail指针是指向根节点的，而对于下面的所有节点，其fail指针都指向其父节点fail指针指向的节点的对应相同字母子节点，即$fail[x]=son[fail[fa[x]]][s[x]]$，如此我们就构建出了基础的AC自动机。 匹配至于匹配，类比KMP的匹配，实际上就非常明显了，我们依然是用两个指针i j，i遍历主串，j在AC自动机上跳，匹配失败则j跳到fail[j]处。 AC自动机的总时间复杂度为$O(n+\sum m)$ 模板（暴力假模板）123456789101112131415161718192021222324252627282930313233343536struct AC &#123; int tot, son[N][26], fail[N], v[N]; void insert(char *s, int len) &#123; int now = 0; for (int i = 0; i &lt; len; ++i) &#123; if (!son[now][s[i] - 'a'])son[now][s[i] - 'a'] = ++tot; now = son[now][s[i] - 'a']; &#125; ++v[now]; &#125; void build() &#123; queue&lt;int&gt;q; for (int i = 0; i &lt; 26; ++i) if (son[0][i]) fail[son[0][i]] = 0, q.push(son[0][i]); while (!q.empty()) &#123; int k = q.front(); q.pop(); for (int i = 0; i &lt; 26; ++i) if (son[k][i]) &#123; fail[son[k][i]] = son[fail[k]][i]; q.push(son[k][i]); &#125; else son[k][i] = son[fail[k]][i];//这里相当于k跳到了fail[k]处，与KMP类似 //这里用son存储后，后面就不需要在匹配失败的时候再去跳fail，节省了时间 &#125; &#125; //统计有多少个模板串在主串中出现过 int query(char *s, int len) &#123; int now = 0, ans = 0; for (int i = 0; i &lt; len; ++i)//now一层一层跳 for (int j = now = son[now][s[i] - 'a']; j &amp;&amp; ~v[j]; j = fail[j]) ans += v[j], v[j] = -1;//这里不断跳fail可以统计与当前串[1,i]某个后缀相等的模板串 //实际上这种做法虽然简单，却使得复杂度并不正确，用aaaa....aaa这样的字符串可以轻松卡掉 return ans; &#125;&#125;A; 进一步理解AC自动机前面我们说过，AC自动机和KMP非常类似。fail[x]指向的位置所表示的字符串，实际上是x表示的字符串的一个后缀，也就是说，如果x能被匹配到，fail[x]必然能被匹配。我们再来观察AC自动机整棵Trie树的结构，每个节点的fail指针指向的位置表示的字符串长度都小于自身，而最终都连到根节点上，实际上这样的连接方式本身就是一棵树。于是我们可以建出AC自动机的fail树，建树方法是将i与fail[i]连起来，根据fail指针的定义，我们很容易发现若节点x能被匹配到，fail[x]也一定可以匹配到，于是我们就可以先进行一遍匹配，然后在fail树上进行树形DP统计答案。 复杂度正确的AC自动机12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct AC &#123; int tot, son[N][26], fail[N], ans[N], v[N], tag[N]; int p[N], b[N], num, nt[N]; void insert(char *s, int len) &#123; int now = 0; for (int i = 0; i &lt; len; ++i) &#123; if (!son[now][s[i] - 'a'])son[now][s[i] - 'a'] = ++tot; now = son[now][s[i] - 'a']; &#125; ++v[now]; &#125; void build() &#123; queue&lt;int&gt;q; for (int i = 0; i &lt; 26; ++i) if (son[0][i]) q.push(son[0][i]); while (!q.empty()) &#123; int k = q.front(); q.pop(); for (int i = 0; i &lt; 26; ++i) if (son[k][i]) &#123; fail[son[k][i]] = son[fail[k]][i]; q.push(son[k][i]); &#125; else son[k][i] = son[fail[k]][i]; &#125; &#125; void add(int x, int y) &#123; b[++num] = y, nt[num] = p[x], p[x] = num; &#125; void buildtree() &#123;//建树 for (int i = 1; i &lt;= tot; ++i) add(fail[i], i); &#125; void dfs(int x) &#123;//树形DP统计答案 for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; dfs(k); ans[x] += ans[k]; tag[x] |= tag[k]; //子节点能匹配到说明x也能够匹配到，因为x表示的字符串实际上是子节点表示的字符串的一个后缀 &#125; ans[x] += v[x] * tag[x];//当前的贡献 &#125; int query(char *s, int len) &#123; int now = 0; for (int i = 0; i &lt; len; ++i) //先进行一遍匹配 now = son[now][s[i] - 'a'], tag[now] = 1;//tag标记匹配到 dfs(0); return ans[0]; &#125;&#125;A;]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>KMP</tag>
        <tag>AC自动机</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不讲道理算法]]></title>
    <url>%2F2020%2F10%2F28%2F%E4%B8%8D%E8%AE%B2%E9%81%93%E7%90%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[个人觉得分块和莫队都是相当暴力不讲道理的算法 分块首先来说说分块。顾名思义，把一段区间分成一块一块的。分成一块块的有什么好处呢？如果我们要进行区间修改区间查询，当这个区间中包含了整个块时，如果我们知道了这个块的一些信息，就没必要对块内的元素一个个进行修改或查询，如此就达到了降低复杂度的目的。于是分块的策略就很清楚了，对于当前操作的区间[L,R]，对于其中的整块我们整体修改或查询，而两边可能有的非整块元素则暴力修改，再将两端所属的块更新，这些元素个数显然不会超过两个块的大小，所以时间复杂度就有了保证。那么块的大小应该怎么确定呢？理论上，如果区间长度为$n$，则当块大小为$\sqrt{n}$时时间复杂度是最优的，每次操作复杂度为$O(\sqrt{n})$。123456789101112131415161718192021222324252627282930313233//以区间加和区间求和为例void update(int l, int r, ll data) &#123; if (bel[l] == bel[r]) &#123; for (int i = l; i &lt;= r; ++i) a[i] += data; block[bel[l]].sum += (r - l + 1) * data; return; &#125;//同一块直接改 for (int i = l; i &lt;= bel[l] * nbl; ++i) a[i] += data;//左边角 block[bel[l]].sum += (bel[l] * nbl - l + 1) * data; for (int i = bel[l] + 1; i &lt; bel[r]; ++i) block[i].sum += nbl * data, block[i].del += data;//中间整块 for (int i = (bel[r] - 1) * nbl + 1; i &lt;= r; ++i) a[i] += data;//右边角 block[bel[r]].sum += (r - (bel[r] - 1) * nbl) * data;&#125;//查询也类同ll query(int l, int r) &#123; ll ans = 0; if (bel[l] == bel[r]) &#123; for (int i = l; i &lt;= r; ++i) ans += a[i] + block[bel[i]].del; return ans; &#125; for (int i = l; i &lt;= bel[l] * nbl; ++i) ans += a[i] + block[bel[i]].del; for (int i = bel[l] + 1; i &lt; bel[r]; ++i) ans += block[i].sum; for (int i = (bel[r] - 1) * nbl + 1; i &lt;= r; ++i) ans += a[i] + block[bel[i]].del; return ans;&#125; 莫队莫队是在分块的基础上，更暴力的一种算法。对于只有查询的题目，我们可以通过移动l r指针，计算相应的添加或者删除某个元素得到的贡献来得到所有查询的答案，但是这样的话复杂度可能达到$n^2$。由于只有查询，我们可以将这些要查询的区间改变顺序，使得两个指针移动的距离尽量减少，从而达到降低复杂度的目的。考虑将整个区间分块，然后将所有查询进行双关键字排序，第一关键字为左端点所在的块，第二关键字为右端点本身。这样的话，对于左端点，在同一块内的转移每次不会超过$\sqrt{n}$，不同块之间的转移不会超过$\sqrt{n}$；对于右端点，在左端点在同一块时，右端点是单调不降的，即最多$n$，而在左端点不同块之间的转移不会超过$\sqrt{n}$因此总时间复杂度为$O(n\sqrt{n})$。1234567891011121314151617181920212223242526272829303132struct Query &#123; int l, r, id; Query() &#123;&#125; Query(int r, int l, int id): l(l), r(r), id(id) &#123;&#125; bool operator &lt;(const Query s)const &#123; return bel[l] &lt; bel[s.l] || (bel[l] == bel[s.l] &amp;&amp; r &lt; s.r); &#125;&#125;q[N];//双关键字排序void ins(int x) &#123; ... //此处对新加进来的元素计算贡献&#125;void del(int x) &#123; ... //此处删去某个元素的贡献&#125;int main() &#123; ... for (int i = 1; i &lt;= n; ++i)bel[i] = (i - 1) / *bel + 1; ... sort(q + 1, q + m + 1); int l = 1, r = 0; for (int i = 1; i &lt;= m; ++i) &#123; while (r &lt; q[i].r)ins(++r); while (l &gt; q[i].l)ins(--l); while (r &gt; q[i].r)del(r--); while (l &lt; q[i].l)del(l++); //直接移动l r指针计算贡献 ANS[q[i].id] = ans;//记录答案 &#125; for (int i = 1; i &lt;= m; ++i) printf("%lld\n", ANS[i]); return 0;&#125; 带修莫队带修莫队实际上就是在普通莫队的基础上增加一个时间轴，来表示修改的时间点。分块策略与普通莫队类似，还是先l r分块，然后还要对同一块内的修改排序(假设为单点修改)在移动完l r指针后，再去移动时间轴指针t，类似地进行相应修改，基本思想其实是一致的。123456789101112131415161718192021222324struct Node &#123; int l, r, pre, bh; inline bool operator &lt;(register Node s)const &#123; if (blo[s.l] ^ blo[l])return s.l &lt; l; if (blo[s.r] ^ blo[r]) return s.r &lt; r; return s.pre &lt; pre; &#125; //此处pre记录时间戳，即当前查询在第几次修改后&#125;q[N];...int main() &#123; ... for (int i = 1; i &lt;= m; ++i) &#123; while (r &lt; q[i].r)ins(++r); while (l &gt; q[i].l)ins(--l); while (r &gt; q[i].r)del(r--); while (l &lt; q[i].l)del(l++); while (now &lt; q[i].pre)change(++now); while (now &gt; q[i].pre)change(now--); //除了l r指针外还有now指针 ans[q[i].bh] = sum; &#125; ...&#125; 树上莫队树上莫队用于解决树上问题，我们将树上问题转化为序列问题，从而使用莫队求解。如何将一个树上的问题转化成一个序列问题呢？我们借助dfs序（括号序列）达到这一点。首先指定根，对于每个点x，我们记录其在dfs过程中第一次遇到时dfs序为st[x]，第二次遇到时dfs序为ed[x]，并记录这两个dfs序对应的点euler[st[x]]=euler[ed[x]]=x。不难发现，在dfs序组成的长度为2n的序列中，如果在某一段区间[l,r]内st[x]和ed[x]同时存在，那么x必然不在原树上euler[l]和euler[r]的最短路径中，且为其中某个节点的后代。由此我们就能联想到，记录当前区间x是否出现过，进行相应的加或减操作，就可以统计出路径上的真实情况，形象地理解的话考虑从一个点到另一个点的过程中，先走到了中间某个点的其他分支，再走回来，走过去的过程中我们将中间的点都计入贡献，而回来时再将其删掉，这样就保证了正确性。当然，上面给出的是一个相当模糊的概述，如果我们模拟一下就会发现，要分两种情况(设查询的点对为(x, y)，其中st[x] &lt; st[y])： LCA(x, y)为x，这时候只需要从ed[x]走到st[y]就可以了，从st[x]开始没有意义 LCA(x, y)不为x，这时候要注意，我们的区间[st[x], st[y]]中显然是不包括LCA的(为什么)，所以对于这个查询，我们还要记录下其LCA，在计算答案时将LCA计入答案，但是要记住，计入答案后要立刻删掉，不能影响到后面的答案计算，因为区间内实际上是没有LCA这个点的dfs序的。 下面给出树上数颜色的模板洛谷SP10707 COT2 - Count on a tree II1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283struct Query &#123; int l, r, lca, id; Query() &#123;&#125; Query(int l, int r, int lca, int id): l(l), r(r), lca(lca), id(id) &#123;&#125; bool operator &lt;(const Query s)const &#123; return block[l] &lt; block[s.l] || (block[l] == block[s.l] &amp;&amp; r &lt; s.r); &#125;&#125;q[N];void add(int x, int y) &#123; b[++num] = y, nt[num] = p[x], p[x] = num; b[++num] = x, nt[num] = p[y], p[y] = num;&#125;void dfs1(int x) &#123; sz[x] = 1; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x])continue; fa[k] = x; dep[k] = dep[x] + 1; dfs1(k); if (sz[son[x]] &lt; sz[k])son[x] = k; sz[x] += sz[k]; &#125;&#125;void dfs2(int x, int chain_number) &#123; st[x] = ++tot; euler[tot] = x; bel[x] = chain_number; if (son[x])dfs2(son[x], chain_number); for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x] || k == son[x])continue; dfs2(k, k); &#125; ed[x] = ++tot; euler[tot] = x;&#125;int LCA(int x, int y) &#123; while (bel[x] != bel[y]) &#123; if (dep[bel[x]] &lt; dep[bel[y]])jh(x, y); x = fa[bel[x]]; &#125; if (dep[x] &lt; dep[y])return x; return y;&#125;void del(int x) &#123; if (!--cnt[c[x]])--ans; &#125;void opt(int x) &#123; if (use[x])del(x); else if (!(cnt[c[x]]++))++ans; use[x] ^= 1;&#125;int main(void) &#123; int n = fast_IO::read(), m = fast_IO::read(); *block = sqrt(n &lt;&lt; 1); for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i)block[i] = (i - 1) / *block + 1; for (int i = 1; i &lt;= n; ++i)c[i] = Hash[i] = fast_IO::read(); for (int i = 1; i &lt; n; ++i)add(fast_IO::read(), fast_IO::read()); sort(Hash + 1, Hash + n + 1); *Hash = unique(Hash + 1, Hash + n + 1) - Hash - 1; for (int i = 1; i &lt;= n; ++i) c[i] = lower_bound(Hash + 1, Hash + *Hash + 1, c[i]) - Hash; dfs1(1); dfs2(1, 1); for (int i = 1; i &lt;= m; ++i) &#123; int x = fast_IO::read(), y = fast_IO::read(), lca = LCA(x, y); if (st[x] &gt; st[y])jh(x, y); if (lca == x)q[i] = Query(st[x], st[y], 0, i); else q[i] = Query(ed[x], st[y], lca, i); &#125; sort(q + 1, q + m + 1); int l = 1, r = 0; for (int i = 1; i &lt;= m; ++i) &#123; while (r &lt; q[i].r)opt(euler[++r]); while (l &gt; q[i].l)opt(euler[--l]); while (r &gt; q[i].r)opt(euler[r--]); while (l &lt; q[i].l)opt(euler[l++]); if (q[i].lca)opt(q[i].lca); ANS[q[i].id] = ans; if (q[i].lca)opt(q[i].lca); &#125; for (int i = 1; i &lt;= m; ++i) printf("%d\n", ANS[i]); return 0;&#125; 回滚莫队咕咕咕]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治（二）]]></title>
    <url>%2F2020%2F10%2F28%2F%E5%88%86%E6%B2%BB%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CDQ分治和整体二分都属于离线算法 CDQ分治CDQ分治的流程与普通分治的流程区别在于，当我们递归解决[L,M]和[M+1,R]区间后，除了将两个子区间的答案合并还要再加上右区间对左区间的贡献。CDQ分治主要用于求解偏序问题。 下面用一个简单的示例说明CDQ的基本思想。 CDQ分治求逆序数求逆序数实质是一个二维偏序问题，相当于一个由有序点对$(x,y)$组成的集合，求对于每个$(x_i,y_i)$有多少对$(x_j,y_j)$使得$x_i&gt;x_j且y_i&lt;y_j$的和。首先一个区间其下标必然是有序的，于是我们只用考虑用$y$如何进行统计。那么参照上面所说的CDQ分治的思想，我们分别计算左右区间的逆序对个数并求和，然后算出右区间对左区间的贡献，总和即为整个当前区间的逆序对数。 1234567891011121314151617181920ll CDQ(int *p, int len) &#123; //p开始的len个元素为当前区间，区间长度为len if (len == 1)return 0;//只有一个数显然逆序数为0 int mid = len &gt;&gt; 1; ll ans = CDQ(p, mid) + CDQ (p + mid, len - mid);//分治，左右区间分别求解 //此处应该将整个区间排序用双指针算出右区间对左区间的贡献，考虑到我们分治的过程 //我们可以直接在分治过程中通过归并排序来减少复杂度 int i = 0, j = mid, k = 0; while (i &lt; mid &amp;&amp; j &lt; len) &#123; if (p[i] &lt;= p[j])tmp[k++] = p[i++];//不构成逆序对 else &#123; ans += mid - i;//p[i]后面的数都比p[i]大，因此也比p[j]大，将这部分计入右区间对左区间的贡献 tmp[k++] = p[j++]; &#125; &#125; while (i &lt; mid)tmp[k++] = p[i++]; while (j &lt; len)tmp[k++] = p[j++]; for (int i = 0; i &lt; k; ++i)p[i] = tmp[i];//tmp存储的是归并后有序的区间，用其更新p return ans;&#125; 其他问题值得一提的是，通常在进行CDQ分治之前我们会将数组排序，来确保可以通过计算右区间中每个点对左区间的贡献来得到正确答案。对于多维偏序问题，我们依然可以使用CDQ分治，例如三维偏序，我们可以对第一维排序、第二维CDQ、第三维用数据结构或CDQ统计答案。来看一个三维偏序的问题。洛谷P3810 【模板】三维偏序（陌上花开）我们很容易就想到，先以a为第一关键字、b为第二关键字、c为第三关键字排序，每次将区间分成两半，这样左区间的a都是小于等于右区间的a的，这样我们只需要计算对右边每对(b,c)左边有多少对满足条件的(b,c)即可显然，b如果在两个区间内分别有序，我们的计算将会非常方便，用双指针扫一遍，若右区间的b大于等于左区间的b，则此时左区间的c就有可能对右区间的c产生贡献，因此我们用一个c值域上的树状数组维护当前有多少产生贡献的c，在右区间的b小于左区间的b时查询此时的贡献。但是这里存在一个问题，此处我们用CDQ分治，要求只能是左区间对右区间产生贡献，但如果有a b c相同的元素分别属于左右区间，这时候右区间对左区间也能产生贡献。而我们的解决方法就是在开始的时候就对整个数组进行去重操作，记录下每个元素的个数有多少，然后对不同元素间进行上述分治+树状数组求解，每个元素的答案再加上相同元素个数-1（其他所有元素都对他产生贡献）就是该元素真正的答案。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;#define jh(x, y) x ^= y ^= x ^= y#define lowbit(x) (x &amp; -x)const double pi = 3.141593;typedef long long ll;const int N = 2e5 + 5, INF = 0x3f3f3f3f, mod = 1e9 + 7;using namespace std;namespace fast_IO &#123; ll read() &#123; char c; ll x = 0; bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r' &amp;&amp; ~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; void write(ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;struct Node &#123; int a, b, c, tot = 0, cnt; Node() &#123;&#125; Node(int c, int b, int a): a(a), b(b), c(c) &#123;&#125; bool operator &lt;(const Node s)const &#123; return a &lt; s.a || (a == s.a &amp;&amp; (b &lt; s.b || (b == s.b &amp;&amp; c &lt; s.c))); &#125; bool operator !=(const Node s)const &#123; return a != s.a || b != s.b || c != s.c; &#125;&#125;a[N], tmp[N], b[N];int ans[N], n, k, c[N];void update(int x, int data) &#123; while (x &lt;= k) &#123; c[x] += data; x += lowbit(x); &#125;&#125;int query(int x) &#123; int ans = 0; while (x) &#123; ans += c[x]; x -= lowbit(x); &#125; return ans;&#125;void CDQ(Node *p, int len) &#123; if (len == 1)return; int mid = len &gt;&gt; 1; CDQ(p, mid); CDQ(p + mid, len - mid); int i = 0, j = mid, k = 0; while (i &lt; mid &amp;&amp; j &lt; len) &#123; if (p[i].b &lt;= p[j].b) &#123; update(p[i].c, p[i].cnt); tmp[k++] = p[i++]; &#125; else &#123; p[j].tot += query(p[j].c); tmp[k++] = p[j++]; &#125; &#125; while (j &lt; len) &#123; p[j].tot += query(p[j].c); tmp[k++] = p[j++]; &#125; for (int t = i - 1; ~t; --t)update(p[t].c, -p[t].cnt); while (i &lt; mid)tmp[k++] = p[i++]; for (int i = 0; i &lt; len; ++i)p[i] = tmp[i];&#125;int main(void) &#123; //freopen("1.in", "r", stdin); int cnt = 0; n = fast_IO::read(), k = fast_IO::read(); for (int i = 1; i &lt;= n; ++i) a[i] = Node(fast_IO::read(), fast_IO::read(), fast_IO::read()); sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] != a[i - 1])b[++cnt] = a[i], b[cnt].cnt = 1; else ++b[cnt].cnt; &#125; CDQ(b + 1, cnt); for (int i = 1; i &lt;= n; ++i)ans[b[i].tot + b[i].cnt - 1] += b[i].cnt; for (int i = 0; i &lt; n; ++i) printf("%d\n", ans[i]); return 0;&#125; 事实上，CDQ是可以不断套娃的，三维偏序问题还可以通过CDQ套CDQ来解决。第一层CDQ与上面的过程类似，只不过我们不需要进行树状数组的操作，只是在原来的update和query处打上tag标记，表示这个位置是计入答案或者统计答案。在排序完成后我们在CDQ内对同一区间进行第二层CDQ，此时的区间是以b为第一关键字，c为第二关键字排序后的结果，因此跟一层CDQ就非常类似的，唯独是在第二层CDQ中计入和统计答案时要注意第一层CDQ中打的标记，比如如果当前左区间的c小于等于右区间的c，但是第一层中并没有给他打标记，就说明当前右区间的元素实际上在第一层时是在左区间，于是就不能进行贡献统计。 123456789101112131415161718192021222324252627282930313233343536void CDQ2(Node *p, int len) &#123; if (len == 1)return; int mid = len &gt;&gt; 1; CDQ2(p, mid); CDQ2(p + mid, len - mid); int i = 0, j = mid, k = 0, sum = 0; while (i &lt; mid &amp;&amp; j &lt; len) &#123; if (p[i].c &lt;= p[j].c) &#123; sum += p[i].tag; tmp[k++] = p[i++]; &#125; else &#123; if (!p[j].tag)tt[p[j].tot] += sum; tmp[k++] = p[j++]; &#125; &#125; while (j &lt; len) &#123; if (!p[j].tag)tt[p[j].tot] += sum; tmp[k++] = p[j++]; &#125; while (i &lt; mid)tmp[k++] = p[i++]; for (int i = 0; i &lt; len; ++i)p[i] = tmp[i];&#125;void CDQ(Node *p, int len) &#123; if (len == 1)return; int mid = len &gt;&gt; 1; CDQ(p, mid); CDQ(p + mid, len - mid); int i = 0, j = mid, k = 0; while (i &lt; mid &amp;&amp; j &lt; len) &#123; if (p[i].b &lt;= p[j].b)tmp[k] = p[i], tmp[k++].tag = p[i++].cnt; else tmp[k] = p[j++], tmp[k++].tag = 0; &#125; while (j &lt; len)tmp[k] = p[j++], tmp[k++].tag = 0; while (i &lt; mid)tmp[k] = p[i], tmp[k++].tag = p[i++].cnt; for (int i = 0; i &lt; len; ++i)a[i] = p[i] = tmp[i]; CDQ2(a, len);&#125; 以此类推，其实无论多少维的偏序问题我们都可以通过CDQ套娃来解决。 整体二分咕咕咕]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>CDQ分治</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治（一）]]></title>
    <url>%2F2020%2F10%2F28%2F%E5%88%86%E6%B2%BB%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基本分治分治的基本思想是：将一个问题分成若干个子问题，对每个子问题进行求解，再将所有子问题的解合并得到问题的解。我们通过一个简单实用的例子来说明该类算法的思想。 归并排序尽管我们几乎不会手写归并排序，但其思想对分治的理解是很有帮助的。考虑我们需要排序的序列[1,n]，如果其子序列[1,mid]和[mid+1,r]都是有序的，我们怎么做才能将其合并成一个有序序列呢？我们用两个指针分别遍历两个子序列，每次将两个指针指向的元素中较小的那个元素加入新的序列，最终得到的序列就是有序的。于是我们的分治策略就出来了，对于序列[l,r]，先将其分成两半分别进行排序，再进行合并。显然合并操作每一层总时间是O(n)的，而每次将序列分半，最多分$\log n$次，所以总复杂度为$O(n\log n)$。这里我们就将合并一个序列的问题变成合并两个子序列的子问题，再将两个排好序的子序列进行合并，就得到了最终的有序序列。123456789101112131415void merge(int l, int r) &#123; if (l == r)return;//只有一个元素当然是有序的 int mid = l + r &gt;&gt; 1; merge(l, mid); merge(mid + 1, r);//分成两个序列，进行排序 int i = l, r = mid + 1, tot = l - 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (a[i] &lt; a[j]) b&#123;++tot] = a[i++]; else b[++tot] = a[j++]; &#125; while (i &lt;= mid)b[++tot] = a[i++]; while (j &lt;= r)b[++tot] = a[j++];//将其余元素放入当前序列 for (int i = l; i &lt;= r; ++i)a[i] = b[i];&#125; 树分治点分治现在，我们要对一棵树进行基于点的分治，首先选择一点作为当前无根树的根，将无根树化为有根树，再去递归地处理每一个与根连接的子树。那么问题来了，如何选点呢？显然，我们希望递归的层数尽量少，自然不能胡乱选点。在点分治中我们选择一棵树的重心作为根。何为重心？即将某个点删去后，剩余节点数量最多的树点的数量最少，则该点称为重心。重心可以DP求解，复杂度$O(n)$：dfs求得每个子树大小，选取一个根x删掉后，剩余树中节点最大值为$\max\{sz[y_1],sz[y_2],…,sz[y_n],sum-sz[x]\}$，从所有x中选择该最大值最小的节点作为根。 123456789101112void getrt(int x, int fa) &#123; sz[x] = 1; maxn[x] = 0; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa || vis[k])continue; getrt(k, x); sz[x] += sz[k]; maxn[x] = max(maxn[x], sz[k]); &#125; maxn[x] = maxn(maxn[x], sum - sz[x]); if (maxn[rt] &gt; maxn[x])rt = x;&#125; 那么，知道了如何找根，分治的过程怎么写呢？参考下面的模板 1234567891011121314void solve(int x) &#123; vis[x] = true;//我们用vis来标记已经搜过的根，以此来确定子树的边界 ... calc(x);//处理x处，也就是当前子树的答案 for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (vis[k])continue; sum = sz[k]; maxn[0] = INF; rt = 0; getrt(k, 0);//找到k子树中合适的根 solve(rt);//分治 &#125;&#125; 至于其中的calc怎么写，根据题目会有变化。 边分治]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论（二）]]></title>
    <url>%2F2020%2F10%2F28%2F%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[网络流甚么是网络流？在有向图G=(V, E)中： 有唯一的一个源点S（入度为0，为出发点） 有唯一的一个汇点T（出毒为0，为结束点） 图中每条弧(u, v)都有一个非负容量c(u, v) 满足上述条件的图G称为网络流图，记为$G=(V,E,C)$ 可行流每条弧(u, v)上给定一个实数f(u, v)满足：有$0\le f(u,v)\le c(u,v)$，则f(u, v)称为弧(u, v)上的流量。如果有一组流量满足条件： 源点s：流出量=整个网络流的流量 汇点t：流入量=整个网络流的流量 中间点：总流入量=总流出量 那么整个网络中的流量称为一个可行流。 最大流在所有的可行流中，流量最大的一个流（满足流量最大的可行流可能不止一个）的流量称为最大流。 求法最大流的求法非常多，最常用的应该是Dinic。Dinic算法是在FF/EK算法的基础上优化的。 Ford-Fulkerson算法在这里我们引入残余容量和增广路的概念：残余容量是指当前的网络流图中边的容量-边的流量，增广路则是指从源点到汇点的一条所有边的残余容量都不为0的路径。显然，直接去找增广路然后尽可能地增大流量这种做法是有问题的，比如下面这张图 如果我们找到的增广路是1-&gt;2-&gt;3-&gt;4，最终得到的答案是1，而显然这里1-&gt;3-&gt;4和1-&gt;2-&gt;4得到的答案是2。如何解决呢？对于每一条边我们都添上一条反向边，每当将某条边的流量增加时，增加其反向边的容量，增加的容量与增加的流量相同。为何正确？考虑上面那张图，我们无法求出正确答案无非就是因为3-&gt;4这条边满流了，而满流的原因是1-&gt;2流过了2-&gt;3，因此如果能从1-&gt;3流到2-&gt;4，相当于中间的2-&gt;3这条边根本就没有选到，也就是说，我们撤销了2-&gt;3中的一部分流量。简要概括就是，对于一条流量本不该那么大的边，我们可以通过连到尾端的边对其进行撤销的操作。 FF算法的复杂度是$O(Mf)$，用bfs实现的FF算法即Edmond-Karp算法的复杂度是$O(nm^2)$ Dinic算法在前面算法的基础上，就有了Dinic算法。我们每次将网络流图进行分层，每个点只能走到比这个点高一层的点，进行dfs找增广路，重复操作直到没有增广路。如何分层？如果一条边(u, v)的容量不为0，且v还没有被分层，那么v就是u的下一层。 模板123456789101112131415161718192021222324252627282930313233343536373839bool bfs() &#123; memset(dist, -1, sizeof(dist)); memset(flag, 0, sizeof(flag)); q[++tail] = st; dist[st] = 0; while (head &lt;= tail) &#123; int k = q[head++]; for (int e = p[k]; e; e = nt[e]) &#123; int kk = b[e]; if (w[e] &gt; 0 &amp;&amp; dist[kk] == -1) &#123; dist[kk] = dist[k] + 1; if (!flag[kk]) &#123; flag[kk] = true; q[++tail] = kk; &#125; &#125; &#125; &#125; return dist[ed] &gt; 0;&#125;int dfs(int x, int minv) &#123; if (x == ed)return minv; int flow = 0; for (int e = p[x], tmp; e &amp;&amp; minv; e = nt[e]) &#123; int k = b[e]; if (dist[k] == dist[x] + 1 &amp;&amp; w[e] &gt; 0 &amp;&amp; (tmp = dfs(k, min(w[e], minv - flow)))) &#123; w[e] -= tmp; w[e ^ 1] += tmp; flow += tmp; &#125; &#125; if (flow &lt; minv)dist[x] = -1; return flow;&#125;int Dinic() &#123; int ans = 0; while (bfs()) ans += dfs(); return ans;&#125; 上面的代码中有几处优化： flow表示当前点x流出的流量，显然在x处尽量流完可以避免走重复路 若最终x点流出的流量比增广路（准确说应该是多路增广路）上的流量小，后面一定不可能再增广到x点了，于是将这个点的分层去掉，相当于跳过这个点 还有一种当前弧优化，即在dfs过程中记录每个点增广到哪一条边，去更新前向星建图中的$first[x]$，这样是避免重复访问不必要的边，但通常优化不是很大，也没必要用。 最小割什么是最小割？就是一张网络流图，割掉一些边使得源点与汇点不连通，割掉的这些边的容量和的最小值。一个著名的定理：最大流=最小割。所以求最小割我们只需要求最大流就行了。 最小割的割边求出了最小割，我们还想知道具体是割了哪些边。只需要从源点沿着残量网络标记下所有经过的点，标记过的点和未标记过的点之间的连边就是割掉的边。1234567891011121314void dfs(int x) &#123; vis[x] = true; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (vis[k])continue; if (w[e])dfs(k); &#125;&#125;void getans() &#123; dfs(st); for (int i = 1; i &lt;= m; ++i) if (vis[edge[i].x] ^ vis[edge[i].y]) ans[++tot] = edge[i].id;&#125; 最小费用最大流最小费用最大流问题建立在最大流问题的基础之上，对每条边赋予一个单位流量的费用，问达成最大流时的最小总费用是多少。根据我们求最大流的方法，每次我们找出一条增广路，保证这条增广路上单位流量费用的和最小，产生的贡献即为$flow\cdot fee$。至于反向边的费用，自然是边的费用的相反数。 1234567891011121314151617181920212223242526272829303132333435bool bfs() &#123; memset(dist, 0x3f, sizeof(dist)); memset(flag, 0, sizeof(flag)); q[1] = st, dist[st] = 0; int head = 1, tail = 1; while (head &lt;= tail) &#123; int k = q[head++]; flag[k] = false; for (int e = p[k]; e; e = nt[e]) &#123; int kk = b[e]; if (w[e] &gt; 0 &amp;&amp; dist[kk] - dist[k] &gt; w[e]) &#123; dist[kk] = dist[k] + w[e]; if (!flag[kk]) &#123; flag[kk] = true; q[++tail] = kk; &#125; &#125; &#125; &#125; return dist[ed] != 0x3f3f3f3f;&#125;int MCF() &#123; int maxflow = 0, mincost = 0; while (bfs()) &#123; int minn = INF; for (int i = ed; i != st; i = b[pre[i] ^ 1])minn = min(minn, w[pre[i]]); for (int i = ed; i != st; i = b[pre[i] ^ 1]) &#123; w[pre[i]] -= minn; w[pre[i] ^ 1] += minn; &#125; maxflow += minn; mincost += minn * dist[ed]; &#125; return mincost;&#125; 上下界网络流]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论（一）]]></title>
    <url>%2F2020%2F10%2F27%2F%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最短路最短路是非常常见的问题，求解方法和各种应用也很多，首先来看一些常用的、基本的最短路求法。 FloydFloyd是一种用DP求解最短路的方法，基本思想就是；对于每个起点和终点，枚举中间点，进行状态转移。转移方程为$d_{x,y}=\min\{d_{x,k}+d_{k,y}|1\le k\le n\}$其时间复杂度为$O(n^3)$，主要用来求任意两点间的最短路。除了Floyd算法，下面的其他最短路算法都是单源最短路的求解。12345for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (d[i][j] &gt; d[i][k] + d[k][j]) d[i][j] = d[i][k] = d[k][j]; Bellman-Ford（SPFA）Bellman-Ford算法最核心的操作称为松弛操作，其思想为：用当前节点的最短路更新其连接点的最短路。朴素的Bellman-Ford算法非常暴力，直接遍历所有点进行松弛操作，直到没有点可以被松弛，这样做复杂度显然是非常高的，于是我们考虑用队列来进行优化，将所有更新过的点加入队列，每次取出一个点进行松弛，直到队列为空，这便是SPFA。 但是即使用队列优化过，SPFA依然复杂度很高，为$O(|V|\cdot|E|)$，只是大多数情况下可以跑得很快，利用网格图之类的特殊结构可以卡掉这种算法，所以如果题目中明显是没有负边的，求最短路的时候我们采用别的方法。 1234567891011121314151617181920void spfa(int st) &#123; dist[st] = 0; queue&lt;int&gt;q; q.push(st); while (!q.empty()) &#123; int k = q.front(); q.pop(); flag[k] = false; for (int e = p[k]; e; e = nt[e]) &#123; int kk = b[e]; //下面是松弛操作，由于dist初始化值较大，我们将不等式变形 if (dist[kk] - dist[k] &gt; w[e]) &#123; dist[kk] = dist[k] + w[e]; if (!flag[kk]) &#123; q.push(kk);//kk不在队列中则入队 flag[kk] = true; &#125; &#125; &#125; &#125;&#125; 负环判定SPFA有一个好处（大概是唯一一个）就是不怕负边以及可以判定负环，判定方法也很简单，我们可以记录每个点入队的次数，如果这个次数达到了总节点数说明图中存在负环。 差分约束系统差分约束系统用于将不等式问题转换成最短路问题并求解，我们对于不等式$a-b\ge c$连边a to b，边权为-c，表示的是从a到b至少需要减少c，那么求完最短路后，a与b的差就是大于等于c的。以下不等式都可以变成上述形式建边：$a - b &gt; c即a-b\ge c+1$$a-b\le c即b-a\ge -c$$a-b &lt; c即b-a\ge -c+1$$a-b=c即a-b\ge c且b-a\ge -c$$a-b\not= c即b-a\ge-c + 1或a-b\ge c + 1$ 然后我们跑一遍SPFA，如果出现负环说明无解，否则我们可以跑出一组解。 上模板洛谷P5960 【模板】差分约束算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546int dist[N], num, p[N], b[N], nt[N], w[N], de[N], in[N], n, m;bool flag[N];void add(int x, int y, int z) &#123; b[++num] = y, w[num] = z; nt[num] = p[x], p[x] = num;&#125;void spfa(int st) &#123; dist[st] = 0; queue&lt;int&gt;q; q.push(st); while (!q.empty()) &#123; int k = q.front(); q.pop(); flag[k] = false; for (int e = p[k]; e; e = nt[e]) &#123; int kk = b[e]; if (dist[kk] - dist[k] &gt; w[e]) &#123; dist[kk] = dist[k] + w[e]; if (!flag[kk]) &#123; q.push(kk); flag[kk] = true; if (++in[kk] &gt; n) &#123; puts("NO");//出现负环 exit(0); &#125; &#125; &#125; &#125; &#125;&#125;int main() &#123; n = fast_IO::read(), m = fast_IO::read(); for (int i = 1; i &lt;= m; ++i) &#123; int a = fast_IO::read(), b = fast_IO::read(), c = fast_IO::read(); add(b, a, c); //a - b &lt;= c //化为b - a &gt;= -c //根据前面的结论，连边b-&gt;a，边权为c &#125; memset(dist, 63, sizeof(dist)); for (int i = 1; i &lt;= n; ++i)add(n + 1, i, 0);//超级源连上所有点 spfa(n + 1);//跑最短路 for (int i = 1; i &lt;= n; ++i) fast_IO::write(dist[i]), putchar(' '); return 0;&#125; DijkstraFloyd是如此之慢！SPFA也是如此之慢！那么我们怎么求点数和边数在1e5级别的单源最短路呢？我们使用Dijkstra算法来解决这样的问题，Dijkstra本质是贪心和BFS求最短路，其基本思想是保证每个点只能遍历一次，每次去找dist最小的点对其连接的点进行更新。更具体地，将Dijkstra算法过程描述为：从源点的dist=0开始，每次取出优先队列中最小的点并打上标记，对其连接的点进行更新，然后将其连接的没有打标记的节点加入优先队列，重复操作直到优先队列为空。如何说明其正确性呢？直观来看确实很难说明，但我们可以用反证法来简单证明。假设点x在出队后优先队列中还有点y可以使dist[x]减小，那么dist[y]必然小于dist[x]，而根据优先队列的性质，dist[x]大于等于x出队后优先队列内任何一点的dist值，即$dist[x]\ge dist[y]$，矛盾。因此可以保证x出队后其dist值是最小的。 12345678910111213141516171819202122232425struct Node &#123; int bh; ll dist; Node()&#123;&#125; Node(int bh, ll dist): bh(bh), dist(dist) &#123;&#125; bool operator &lt;(const Node s)const &#123; return dist &gt; s.dist; &#125;&#125;;priority_queue&lt;Node&gt;q;void dijkstra(int st) &#123; //dist初始化为较大值 dist[st] = 0; q.push(Node(st, 0)); while (!q.empty()) &#123; Node k = q.top(); q.pop(); if (flag[k.bh])continue; flag[k.bh] = true; for (int e = p[k.bh]; e; e = nt[e]) &#123; int kk = b[e]; if (dist[kk] - dist[k.bh] &gt; w[e]) &#123; dist[kk] = dist[k.bh] + w[e]; if (!flag[kk])q.push(Node(kk, dist[kk])); &#125; &#125; &#125;&#125; Tarjantarjan是非常实用的图论算法，使用tarjan可以解决很多图论问题。 强连通分量首先我们来看tarjan的一个经典应用：求有向图强连通分量（联通块）。强连通分量，即图的一个子集，其中每个点都可以到达其他任意一个点。要想搞清楚tarjan算法，主要是要弄明白这两个数组有何作用、如何实现：dfn和low其中dfn[x]较为简单，其含义为x的搜索序，你也可以理解为dfs过程中x的时间戳。重点需要理解的是low[x]的含义，一般来说我们描述为“他表示从x处开始搜索，能走到的最小的搜索序是多少。”但实际上这个说法是比较含糊的，与x连接的某个点为k，则从x处开始搜索时不能搜回fa处，且若k在此前其在x后已经搜索过，则不再继续搜索，并用dfn[k]更新low[x]的值， 而对于其他连接的节点，需要取其low最小值。对于k，我们用其dfn值更新x的low值的原因是，从x处能搜到曾经搜过的k，那么从k开始就有可能存在一个强联通块包含了x，因此我们将x的low值更新，再通过回溯时对low值的更新，一步步更新回k点，若low[k]与dfn[k]相等，就说明从k开始绕了一圈又找到了k，也就是说找到了强连通分量。那么如何对应地找到其中所有的节点呢？我们通过栈来实现，在dfs过程中，若遇到没搜过的点，则将其入栈，最后在low[x]=dfn[x]处，因为从x处最终能走回x，回溯到x时，途中的所有节点都在栈中，而中途可能遇到的分支都会在相同的过程中全部出栈（不在环中的自成一个强连通分量），因此从栈顶到栈中x的位置，中间的节点正好在一个强连通分量中，所以我们只需要不断弹栈，直到将x弹出栈，所有弹出的元素都归为一个强联通块中，可以证明，这样求得的强联通块是最大强联通块，将强联通块抽象成点，这便是缩点。 12345678910111213141516171819202122232425void tarjan(int x) &#123; dfn[x] = low[x] = ++tot; st[++top] = x; flag[x] = true;//在栈中 for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (!dfn[k]) &#123; tarjan(k); low[x] = min&#123;low[x], low[k]);&#125; &#125; else if (flag[k])low[x] = min(low[x], dfn[k]); //从某点出发的路径中有k（因为k还在栈中），则可能会成环。 &#125; if (dfn[x] == low[x]) &#123; //相等则成环 ++totltk;//联通块数量+1，也表示了当前联通块数量 while (st[top + 1] != x) &#123; ltk[st[top]] = totltk; f(totltk, x);//可能通过x对联通块内进行一些信息的统计 flag[st[top]] = false;//标记出栈 --top; &#125; //将栈中元素弹出至x也被弹出 &#125;&#125; 割点（割顶）理解了如何计算并使用dfn及low后，我们来看如何求无向图的割点。割点指的是若将联通无向图中的某点及其连接的边删去后，图中连通分量个数增加，则称这个点为割点。其中求dfn与low的过程与求强连通分量的过程基本相同，但我们不需要使用栈，对于任何一个走过的点我们都用其dfn值更新x的low值，至于具体原因，首先我们需要知道怎么求出割点。对于x，假设其从fa搜索过来，连接着某点k，则若low[k]==dfn[x]，说明x为割点。为什么呢？因为如果将x删掉，k与fa必然不属于同一个联通块，若删掉x后k与fa属于同一个联通块，那么low[k]必然会小于dfn[x]，这也就是为什么我们对每个走过的点都用其dfn值更新x的low值，就是为了保证求出的割点一定能保证k与fa不在任何同一个联通块中。然后我们就会考虑到一个特殊的点：第一个搜索的点，这个点是没有fa的。那么如何确定第一个点是不是割点呢？我们记录第一个点被包含在多少个最大的除去x后的联通块中，其实也就是在第一个点进行连接点的遍历时，若该点没有访问过则算入记录，这个应该比较显然，那么只要这个记录比1大，就说明将x删去后会产生多个联通块，即x为割点。于是我们的算法就出来了123456789101112131415void tarjan(int x, int fa) &#123; dfn[x] = low[x] = ++tot; int child = 0 ; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (!dfn[k]) &#123; tarjan(k, x); if (low[k] == dfn[x] &amp;&amp; x != fa)gd[x] = true;//是割点 low[x] = min(low[x], low[k]); if (x == fa)child++;//统计我们要的东西 &#125; else low[x] = min(low[x], dfn[k]);//全部更新 &#125; if (child &gt;= 2)flag[x] = true;//是割点&#125; 另外，根据上述求法，我们还可以统计出断开点x后联通块增加的个数：对于第一个搜索的点，显然联通块增加的个数就是child - 1；对于其他的点，联通块增加的个数应当是x被判为割点的次数。1234567if (low[k] == dfn[x] &amp;&amp; x != fa)gd[x] = true;改为if (low[k] == dfn[x] &amp;&amp; x != fa)++delta[x];if (child &gt;= 2)flag[x] = true;改为if (child &gt;= 2)delta[x] = child - 1; 桥在无向图中，若删去某边使得图的联通块数量增加，则该边称为桥。桥的求法非常简单，根据其定义，只要删去该边联通块数量增加的就是桥，因此在tarjan的过程中，若我们通过某条边找到的low值比dfn[x]大，说明该边就是桥。1234567891011121314151617181920212223void tarjan(int x) &#123; dfn[x] = low[x] = ++*dfn; st[++*st] = x; flag[x] = true; for (int e = p2[x]; e; e = nt2[e]) &#123; int k = b2[e]; if (vis[e])continue; if (!dfn[k]) &#123; vis[e] = vis[e ^ 1] = true;//考虑到可能有重边，这里我们标记边而不是点 tarjan(k); vis[e] = vis[e ^ 1] = false; low[x] = min(low[x], low[k]); if (low[k] &gt; dfn[x])can[id2[e]] = true; &#125; else if (flag[k])low[x] = min(low[x], dfn[k]); &#125; if (low[x] == dfn[x]) &#123; while (st[*st + 1] != x) &#123; flag[st[*st]] = false; --*st; &#125; &#125;&#125; （点/边）双连通分量强连通分量的概念是针对有向图的，对于无向图，我们称任意两点存在至少两条点不重复的路径的极大子图为点双连通分量，任意两点存在至少两条边不重复的路径的极大子图为边双连通分量。每一个点双连通分量中没有割点，每一个边双连通分量中没有桥。边双连通分量的求法比较简单，只需要去掉所有桥得到的就是边双连通分量。点双连通分量模板：12345678910111213141516171819void tarjan(int x, int fa) &#123; dfn[x] = low[x] = ++tot; st[++top] = x; flag[x] = true; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (!dfn[k]) &#123; tarjan(k, x); low[x] = min(low[x], low[k]); if (low[k] &gt;= dfn[x]) &#123; if (fa)++tot; while (st[top + 1] != k) ltk[st[top--]] = tot; ltk[x] = tot; &#125; &#125; else low[x] = min(low[x], dfn[k]); &#125;&#125;]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>tarjan</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构（三）]]></title>
    <url>%2F2020%2F10%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[平衡树Treap（单旋）咕咕咕 可持久化Treap咕咕咕 Splay（双旋）在理解splay的操作前，首先要搞清楚splay维护的是怎样的一棵树。这棵树是一棵二叉树，它最大的特点就是，对于每个节点k，k上的权值一定大于左子树的最大权值且小于右子树的最小权值。 首先来看splay的核心操作：旋转和双旋旋转操作，意在将节点x旋转到原本x父节点f所在的位置，那么会影响到的节点就有：x和f、x的孩子节点k1或k2、f的父亲节点gf。先看gf，gf原本的孩子节点f变成了x，只用将x放到原本f所在的位置就行；再看k1 k2，如果x是f的左孩子，那么f的权值就比x大，f应当到原本x的右孩子k2处，而k2的权值是小于f的，因此k2就到了f的左儿子处，也就是原本x所在的位置，如果x是f的右孩子则是同理；最后看x和f，颠倒父子关系即可。于是乎，我们的旋转操作就能总结出来了：1234567891011121314void _rotate(int x) &#123;//将x旋转到原本x父节点的位置 int f = fa[x], gf = fa[f]; c[gf][f == c[gf][1]]] = x;//将x放到原本f的位置 fa[x] = gf; int w = x == c[f][1];//w表示x是f的哪个孩子 c[f][w] = c[x][w ^ 1];//原本x所在的位置变成了x相反方向的孩子 fa[c[x][w ^ 1]] = f; c[x][w ^ 1] = f;//父子关系颠倒 fa[f] = x; pushup(f); pushup(x);//这里对f和x做一些更新，因为这两个节点表示的子树发生了变化 //当然，如果仔细想一下你会发现，在不断旋转的过程中，这个x会在下一次旋转中pushup //因此这里可以不写pushup(x)，而是写在splay操作完以后&#125; 在旋转的基础上，我们进行双旋操作。其实我们旋转的意义在于，将某个节点旋转到根节点来方便进行操作的同时，使树尽量平衡，从而降低复杂度。如果仅仅只是为了把节点放到根处操作，直接不停的旋转就行了，根本用不着splay。而我们的splay这里只有一处与直接旋转不同：如果gf、f和x成了一条直线，也就是说gf到f和f到x是同一个方向，那么我们可以先将f旋转，再将x旋转。因为这种情况下，f旋转上去时，x会被f带着向上走而不是成为gf的一个子树。通过这样的双旋操作，最终可以使得树的高度不至于太高，而是均摊$\Theta(\log n)$的水平。123456789101112void splay(int x) &#123; while (fa[x]) &#123;//fa[x]==0说明x已经到根节点了 int f = fa[x], gf = fa[f]; if (gf) if ((f == c[gf][0]) ^ (x == c[f][0]))//gf f x不在一条线上就为1 _rotate(x); else _rotate(f);//在一条线上就先转f _rotate(x);//再转x，一次循环的效果是将x转到了原本gf所在的位置 &#125; //pushup(x); rt = x;//根变成了x&#125; 有了这些以后，我们就可以去维护一个数集，最基本的操作就是添加、删除、查排名、查第k大数、找前驱后继等如果这个数集是区间的下标，通过给节点附上别的权值以及标记，可以实现对区间的各种操作，尤其包括区间翻转 LCT（动态森林）如果我们要维护一个森林，这个森林可以连边、删边，且操作后依然是森林，那么我们就可以使用LCT。而LCT实际上是基于实链剖分，与树链剖分类似的，我们将森林里的某些路径划分为实链，每个节点属于且仅属于一条实链。考虑到我们要动态维护森林，在这里我们使用平衡树（本人常用splay）来维护实链。那么LCT维护的这条链是怎样的？事实上，LCT维护的链是深度严格递增的，而splay的权值也就是深度，即每个节点x左儿子的深度比x小，右儿子的深度比x大。明白这些以后，我们再想，如何去动态维护这些链呢？ access操作这个操作是LCT的核心操作，其意义在于将某个点x与整棵树的根节点之间的路径划分成一条实链。为了达到这个目的，我们需要将路径上所有连的其他边都变为虚边，再将路径上的边划分为实边即可。下面的图片来自FlashHu的博客 这是原始的树的图像，但显然在我们的splay里面不会是这个样子比如说，这棵树可能实际上长这样 现在我们想把A与N划分成一条实链，首先当然是将N splay到当前实链的根，这样的话，断掉N-O就将深度大的节点（此处是O）全部断开，也就是变为了虚边。 再跳到此时N的父节点I，将I与N连起来（当然是连右儿子），自然就断开了原来的右儿子，也就是“其他的边（点）”。 是不是找到了什么规律呢？没错，只要不断往上跳，连上右儿子并断掉左儿子，最终就能构建A-N的splay出来。 那么代码其实就很简单了1234567void access(int x) &#123; for (int son = 0; x; x = fa[son = x]) &#123; splay(x); c[x][1] = son;//连在右儿子上 pushup(x);//对x做更新 &#125;&#125; 要特别注意的是，这里的fa维护的是原树的形状，而c维护的是splay的形状，要注意区分。 changert操作将根节点设为x仅仅只有access操作当然不够，如果我们想得到(x, y)的路径，我们还需要将x放到整棵树的根上，再在y处access。其实有了access，这个操作非常简单，只需要access(x),splay(x)就行了但这样会有一个问题，我们定义根为树中深度最小的节点，而此时的x显然是splay中深度最大的节点，所以我们需要进行区间翻转操作，这样就保证了x的深度为最小，也就是将x变为了根。 123456789void pushr(int x) &#123; swap(c[x][0], c[x][1]); r[x] ^= 1;&#125;//记得在splay前将所有标记下传！void changert(int x) &#123; access(x); splay(x); pushr(x);//将x所在splay翻转&#125; findrt操作查找x所在树的根节点access(x)，然后splay(x)，接着去找深度最小的点就行了。12345678int findrt(int x) &#123; access(x); splay(x); while (c[x][0]) x = c[x][0]; splay(x);//此处不影响正确性 return x;&#125; split操作将x与y之间的路径划分到同一个splay中前面提到过，只需要changert(x),access(y)即可12345void split(int x, int y) &#123; changert(x); access(y); splay(y);&#125; link操作将两个不在同一棵树的点连起来显然只需要将一个点变为根，连到另一个点上即可123456void link(int x, int y) &#123; changert(x); if (findrt(y) != x) fa[x] = y; //x和y不能在同一棵树中&#125; cut操作删除x到y的边先把x到y划到一个splay中，如果x与y相连直接删除即可123456789void cut(int x, int y) &#123; changert(x); access(y); if (findrt(y) == x &amp;&amp; fa[y] == x &amp;&amp; !c[y][0]) &#123; fa[y] = c[x][1] = 0; pushup(x); &#125; //findrt(y)==x说明x与y在同一棵树中，fa[y]==x&amp;&amp;!c[y][0]说明x与y相连&#125;]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构（二）]]></title>
    <url>%2F2020%2F10%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[树状数组树状数组用于维护前缀和，支持单点修改。树状数组的原理并不复杂：对于1 &lt;= i &lt; j &lt;= n，经过若干次i+=lowbit(i),j-=lowbit(j)，所得的i’和j’中必然会有唯一一对相等，所以我们只需要在修改时不断将a[i]加到c[i’]上，查询时将所有的c[i’]加起来就行了。下面简略地说明一下，为什么这样做是对的：首先，lowbit(x)指的是x在二进制下最低位的1，比如lowbit(3)=1,lowbit(4)=4,lowbit(6)=2。那么为什么一定会有i’和j’相等呢？当j的二进制位大于i时，设i二进制有k位，显然i’中会包含所有k’&gt;k,2^k’，也就是说，只要j将除最高位外所有的位都减成0，就会与某个i’相等。当j的二进制位等于i时，从高位往低位看，必然会有某一位k使得比k位以上i和j都是1，在第k位i是0而j是1，此时又要分两种情况： k位以下i全是0，那么只要j把k位一下全减掉，j’就与i相等 k位以下i有1，那么i’必然会有k位为1，k位以下全为0的情况，此时i’与j’相等 如此，就说明i’与j’必然会相等(注意:i’包含i,j’包含j)，且不难看出，按上述策略找出的i’和j’是唯一的一对。再来张树状数组的大致图像，帮助理解c[i]。 12345678910111213141516171819#define lowbit(x) (x &amp; -x)//为什么x &amp; -x就是x的最低位1呢？因为-x实际上是(~x) + 1，会使得x的最低位1为1，而比x高的位与x都相反void update(int x, int data) &#123; //将x位置加上data while (x &lt;= len) &#123; //len为区间长度 c[x] += data;//前面解释过c[x]的作用 x += lowbit(x); &#125;&#125;int query(int x) &#123; //查询x的前缀和 int ans = 0; while (x) &#123; ans += c[x]; x -= lowbit(x); &#125; return ans;&#125; 另外，对a的差分数组用树状数组可以实现a数组的区间修改和单点查询，只用update(l, delta),update(r+1, -delta)就行了。 线段树线段树是一种非常常用的数据结构，且变化极多，这里先说最基础的线段树。线段树，顾名思义，将区间分成一段一段，来达到区间操作的目的，那么如何分段呢？考虑将区间[l,r]分成两半[l,mid]、[mid+1,r]，这样相当于将区间对半分，那么很显然，对每个区间都这样分段，最终的段数为$O(n\log n)$。当我们进行区间操作时，从最大的区间开始，以此去找对应要操作的区间： [l,r]包含在当前区间的左区间内，就接着往左区间走 [l,r]包含在当前区间的右区间内，就接着往右区间走 [l,r]跨过中间的分界线，那么左边操作[l,mid]，右边操作[mid+1,r] 如此反复，直到找到的区间与当前操作的区间完全相同，就进行操作。大致图像如下 另外，如果我们的区间操作涉及对区间的修改，如加减、乘除、改值，我们可以在找到的区间上打上懒标记，这样我们不用每次往下遍历完整棵线段树，当然，在遍历过程中要注意标记的下传，如果有多个标记要注意多个标记之间的关系，如乘标记不仅改变区间上的值，还改变标记的值。 洛谷P3373 【模板】线段树 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct Node &#123; int l, r; ll sum, add, mul = 1;&#125;tree[N &lt;&lt; 2];void pushup(int x) &#123; tree[x].sum = (tree[x &lt;&lt; 1].sum + tree[x &lt;&lt; 1 | 1].sum) % p; &#125;void build(int x, int l, int r) &#123;//建树 tree[x].l = l, tree[x].r = r; if (l == r) &#123; tree[x].sum = fast_IO::read() % p; return; &#125; int mid = l + r &gt;&gt; 1; build(x &lt;&lt; 1, l, mid); build(x &lt;&lt; 1 | 1, mid + 1, r); pushup(x);&#125;void pushdown(int x) &#123;//标记下传 if (tree[x].mul != 1) &#123; (tree[x &lt;&lt; 1].mul *= tree[x].mul) %= p; (tree[x &lt;&lt; 1 | 1].mul *= tree[x].mul) %= p; (tree[x &lt;&lt; 1].add *= tree[x].mul) %= p; (tree[x &lt;&lt; 1 | 1].add *= tree[x].mul) %= p; (tree[x &lt;&lt; 1].sum *= tree[x].mul) %= p; (tree[x &lt;&lt; 1 | 1].sum *= tree[x].mul) %= p; tree[x].mul = 1; &#125; if (tree[x].add) &#123; (tree[x &lt;&lt; 1].add += tree[x].add) %= p; (tree[x &lt;&lt; 1 | 1].add += tree[x].add) %= p; (tree[x &lt;&lt; 1].sum += (tree[x &lt;&lt; 1].r - tree[x &lt;&lt; 1].l + 1) * tree[x].add % p) %= p; (tree[x &lt;&lt; 1 | 1].sum += (tree[x &lt;&lt; 1 | 1].r - tree[x &lt;&lt; 1 | 1].l + 1) * tree[x].add % p) %= p; tree[x].add = 0; &#125;&#125;void update(int x, int l, int r, ll data) &#123;//添加加标记 if(tree[x].l == l &amp;&amp; tree[x].r == r) &#123; (tree[x].sum += (r - l + 1) * data % p) %= p; (tree[x].add += data) %= p; return; &#125; pushdown(x); int mid = tree[x].l + tree[x].r &gt;&gt; 1; if (r &lt;= mid)update(x &lt;&lt; 1, l, r, data); else if (l &gt; mid)update(x &lt;&lt; 1 | 1, l, r, data); else update(x &lt;&lt; 1, l, mid, data), update(x &lt;&lt; 1 | 1, mid + 1, r, data); pushup(x);&#125;void update2(int x, int l, int r, ll data) &#123;//添加乘标记 if (tree[x].l == l &amp;&amp; tree[x].r == r) &#123; (tree[x].mul *= data) %= p; (tree[x].sum *= data) %= p; (tree[x].add *= data) %= p;//别忘了加标记也要更新 return; &#125; pushdown(x); int mid = tree[x].l + tree[x].r &gt;&gt; 1; if (r &lt;= mid)update2(x &lt;&lt; 1, l, r, data); else if (l &gt; mid)update2(x &lt;&lt; 1 | 1, l, r, data); else update2(x &lt;&lt; 1, l, mid, data), update2(x &lt;&lt; 1 | 1, mid + 1, r, data); pushup(x);&#125;ll query(int x, int l, int r) &#123; if (tree[x].l == l &amp;&amp; tree[x].r == r)return tree[x].sum; pushdown(x); int mid = tree[x].l + tree[x].r &gt;&gt; 1; if (r &lt;= mid)return query(x &lt;&lt; 1, l, r); if (l &gt; mid)return query(x &lt;&lt; 1 | 1, l, r); return (query(x &lt;&lt; 1, l, mid) + query(x &lt;&lt; 1 | 1, mid + 1, r)) % p;&#125; 主席树（可持久化线段树）典例：区间第K大给定一个长度为n的区间，给出m次查询，每次给出l,r,k,查询[l,r]中第k大的值发明者原话：“对于原序列的每一个前缀[1···i]建立出一棵线段树维护值域上每个数出现的次数，则其树是可减的”这话啥意思呢？就是对于序列中每一个位置i，都建立一棵线段树，这个线段树的范围是序列的值域范围，维护的是1~i中值域中的每个数出现的次数，这样的话两棵线段树的结构是完全相同的，因此对应的位置可以相减，所以用树r减去树l-1得到线段树就是区间[l,r]对应的线段树。但是对每个位置都建立一棵线段树，空间复杂度$O(n^2\log n)$，太高了，而我们又发现，其实相邻两颗线段树有大量相同的部分，如果我们将这些相同的部分合到一起，就可以大大降低空间的负担。 之后查询第k大就好说了，如果左区间的数字个数c&gt;=k就往左区间找，否则在右区间找第k-c大 12345678910111213141516171819202122232425//先建立空树void build(int &amp;x, int l, int r) &#123; x = ++tot; if (l == r)return; int mid = l + r &gt;&gt; 1; build(c[x][0], l, mid); build(c[x][1], mid + 1, r);&#125;//建新树，但新树与前一棵树部分重合int update(int pre, int l, int r, int x) &#123; int now = ++tot;//只在需要的地方开节点，节省空间 c[now][0] = c[pre][0], c[now][1] = c[pre][1];//有一部分重合 sum[now] = sum[pre] + 1;//类似于前缀和 if (l == r)return now; int mid = l + r &gt;&gt; 1; if (x &lt;= mid)c[now][0] = update(c[now][0], l, mid, x);//左区间开新节点 else c[now][1] = update(c[now][1], mid + 1, r, x);//右区间开新节点 return now;&#125;int query(int pre, int now, int l, int r, int k) &#123; int mid = l + r &gt;&gt; 1, tmp = sum[c[now][0]] - sum[c[pre][0]];//tmp表示的是查询的[L,R]区间在值域[l,r]真正的数字个数 if (l == r)return l; if (tmp &gt;= k)return query(c[pre][0], c[now][0], l, mid, k); return query(c[pre][1], c[now][1], mid + 1, r, k - tmp);&#125; 李超线段树咕咕咕 扫描线咕咕咕 树链剖分树链剖分主要用于解决树上路径、子树相关问题。树链剖分的思想很简单：在树上划出一些链，使得每个节点都属于且仅属于一条链，记录链的顶部，那么只需要O(1)的时间就能处理整条链的信息，从而达到缩短时间的目的。如何划分这些链？我们采用轻重链剖分，也就是说，找到以节点x的子节点中子树大小最大的节点y（称为重儿子），将x和y划分到同一条链中。 这样的话，基本就可以保证我们划分出的链尽量长，从而减少的时间更多。树链剖分的代码实现比较麻烦，我们分步看。首先，来看看我们需要用到什么变量和数组。12345int sz[N],//子树的大小，用于求重儿子dep[N],//节点的深度bel[N],//节点所在链的顶部son[N],//节点的重儿子fa[N];//节点的父节点 我们需要求出每个点的重儿子以及深度，使用dfs。1234567891011121314//dfs1从根节点开始void dfs1(int x) &#123; sz[x] = 1;//本身大小是1 for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x])continue; fa[k] = x;//k父节点是x dep[k] = dep[x] + 1;//记录深度 dfs1(k); if (sz[k] &gt; sz[son[x]])son[x] = k; //找到sz最大的子树，令其为重儿子 sz[x] += sz[k];//所有子树的大小加本身就是x子树的大小 &#125;&#125; 到目前为止做的都是准备工作，接下来才是链的划分。123456789101112void dfs2(int x, int chain_number) &#123; bel[x] = chain_number;//chain_number存的就是当前链的顶部，也代表着这条链 if (son[x])//如果有子节点，将重儿子划分到同一条链中 dfs2(son[x], chain_number); for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x] || k == son[x])continue; //son[x]已经划分了，要跳过 dfs2(k, k); //由于我们是自顶向下dfs的，k与x又不属于同一条链，k所在的链顶部就是k本身 &#125;&#125; 至此，我们就完成了树链剖分，那么如何使用呢？比如，求LCA：123456789101112int LCA(int x, int y) &#123; //求x和y的LCA //x和y反复往上跳，直到跳到同一条链 while (bel[x] != bel[y]) &#123; if (dep[bel[x]] &gt; dep[bel[y]])swap(x, y); //我们希望x和y都尽量往上跳，这样最节省时间，于是我们就跳链顶部的dep较小的那个 x = fa[bel[x]];//从bel[x]链跳到另一条链 &#125; //最终x和y在同一条链上，dep小的那一个显然就是LCA if (dep[x] &lt; dep[y])return x; else return y;&#125; 那如果，要引入路径及子树内的修改、查询怎么办？我们当然希望同一条链上的东西可以一起操作，这样与x和y向上跳的步骤就是一致的，那么具体怎么办呢？考虑引入dfs序，在dfs2中，因为我们优先dfs了重儿子的分支，因此同一条链上的dfs序是连续的，同时，一棵子树内的dfs序显然也是连续的，因此我们可以在dfs序上建立线段树。12345678910111213141516171819void dfs2(int x, int chain_number) &#123; bel[x] = chain_number;//chain_number存的就是当前链的顶部，也代表着这条链 dfn[x] = ++tot;//x的dfs序 ct[x] = dfn[x];//x子树内最大的dfs序 if (son[x]) &#123;//如果有子节点，将重儿子划分到同一条链中 dfs2(son[x], chain_number); ct[x] = max(ct[x], ct[son[x]]); &#125; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x] || k == son[x])continue; //son[x]已经划分了，要跳过 dfs2(k, k); //由于我们是自顶向下dfs的，k与x又不属于同一条链，k所在的链顶部就是k本身 ct[x] = max(ct[x], ct[k]); &#125; //显然，从dfn[x]到ct[x]的dfs序对应的节点与x子树内的节点一一对应&#125;//其他操作都是与LCA类似的过程，对dfn[bel[x]]到dfn[x]进行操作，最后对dfn[x]到dfn[y] (dfn[x]&lt;=dfn[y])操作]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>可持久化</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构（一）]]></title>
    <url>%2F2020%2F10%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基本数据结构栈栈是一种遵循先进后出原则的数据结构，数据在同一端入栈和出栈。 手动实现如下：123456789int stk[100005], top;//stk用于存放栈内的数据，top为栈顶，入栈和出栈都是在栈顶进行操作void ins(int x) &#123; stk[++top] = x; //新加入一个元素x&#125;int del() &#123; return stk[top--]; //返回并删除一个元素， 出栈&#125; 是不是很简单呢？ C++的STL提供了stack给我们直接使用，它支持如下基本操作：123456stack&lt;dataType&gt;name;//创建一个元素类型为dataType的栈namename.top();//返回顶部元素的引用name.push(x);//将x压入栈中name.pop();//弹出栈顶元素name.size();//返回栈中的元素个数name.empty();//栈为空时返回true 单调栈在栈的基础上，我们规定元素出栈的顺序必须是单调不降或单调不增的，对栈内元素的顺序没有要求。对于单调不降的单调栈，入栈前把比要入栈的元素小的元素全部出栈。对于单调不增的单调栈，入栈前把比要入栈的元素大的元素全部出栈。12345678void ins(int x) &#123; //此处以单调不降的单调栈为例 while (top &amp;&amp; stk[top] &lt; x) &#123; fun(stk[top--]);//出栈的元素可能要进行一些操作 //top--出栈 &#125; stk[++top] = x;&#125; 队列队列是一种遵循先进先出原则的数据结构，数据在一端入队，在另一端出队。 手动实现如下123456789int q[100005], head = 1, tail;void ins(int x) &#123; q[++tail] = x; //从尾部入队&#125;int del() &#123; return q[head++]; //从头部出队&#125; C++的STL中同样提供了queue供我们使用，它支持如下基本操作：1234567queue&lt;dataType&gt;name;//创建一个元素类型为dataType的队列namename.front();//返回队列中第一个元素的引用name.back();//返回队列中最后一个元素的引用name.push(x);//x从队列尾部入队name.pop();//删除队列的尾部name.size();//返回队列中元素的个数name.empty();//队列为空时返回true 单调队列与单调栈不同，单调队列要求队内的元素要是单调不降或单调不增的，且队首队尾都可以进行出队操作，只有队尾可以进行入队操作。一般来说，单调队列会有一个限制的大小m，即最多只能有m个元素。单调队列主要用于维护不同段区间内的最值，每次元素要入队时，与单调栈类似地，要让一些元素出队。123456void ins(int x) &#123; //以单调不降的单调队列为例 while (head &lt;= tail &amp;&amp; q[tail] &lt;= x)--tail;//删除比x小的元素 q[++tail] = x;//x入队 while (tail - head &gt;= m)++head;&#125; 链表先鸽着 简单数据结构ST表ST表用于求静态区间最值，构建复杂度$O(n\log n)$，查询复杂度只有$O(1)$!那么ST表是怎么实现的呢？显然区间[L,R]的最值可以拆成[L,L+x]与[R-x+1,R]的最值取最值，只要L+x&gt;=R-x+1即可。那么我们考虑求对于区间内每个位置i，从i开始往后$2^k$个元素中的最值ST[i][k]，于是构建ST表的算法就出来了。123456//以求最大值为例//注意，这里ST[i][0]为位置i上本来的这个数for (int j = 1; j &lt;= log2(n) + 1; ++j) for (int i = 1; i + (1 &lt;&lt; j - 1) &lt;= n; ++i) ST[i][j] = max(ST[i][j - 1], ST[i + (1 &lt;&lt; j - 1)][j - 1]);//显然是两段的最值中取最值 查询也好说：1234int query(int l, int r) &#123; int k = log2(r - l + 1); return max(ST[l][k], ST[r - (1 &lt;&lt; k) + 1][k]);&#125; 并查集并查集用于维护集合的关系。普通的并查集操作非常简单，直接上代码。123456789//用fa[x]表示x所在的集合//fa[x]初始化为x本身int findf(int x) &#123; if (x == fa[x])return x;//fa[x] == x说明当前的x已经表示了一个最大的集合 return fa[x] = findf(fa[x]);//如果fa[x] != x说明当前的集合被包含在另一个集合里&#125;//如此就能找到x所在的集合fa[findf(x)] = findf(y);//将x所在的集合合并到y所在的集合 不难看出，findf最多递归小常数次，因此并查集的复杂度是非常小的。 带权并查集（扩展并查集）带权并查集即结点有权值的并查集，如果我们要维护元素之间可量化的属性，而且这种属性关系可以合并时，可以采用带权并查集。带权并查集中每个元素的权值通常描述其与祖先的关系。 探究结点与祖先的关系我们可以利用向量偏移。 例题题面 首先我们确定属性，设sum[x]为从x到x的祖先的区间和祭出好图 显然当roota!=rootb时，我们想要将roota和rootb合并，那么roota-&gt;rootb即sum[roota]是要更新的，可如何更新呢？根据向量运算我们知道，(roota,rootb)=(b,rootb)-(b,roota)=(b,rootb)-(a,roota)+(a,b)由此可得sum[roota]=sum[b]-sum[a]+w(a,b) 而当roota=rootb时，说明此时的区间通过前面的答案已经可以推出，只需要验证是否为真即可。显然此时(a,b)=(a,root)-(b,root)即s(a,b)=sum[a]-sum[b] 在找祖先的过程中，我们也需要对sum进行更新。另外，我们推出的表达式是sum[r]-sum[l]的形式，因此左端点还要-1。 123456789101112131415161718192021222324252627282930int fa[N], sum[N];int findf(int x) &#123; if (x == fa[x])return x; int y = fa[x]; fa[x] = findf(fa[x]); sum[x] += sum[y]; return fa[x];&#125;int main() &#123; int n, m; while (~scanf("%d%d", &amp;n, &amp;m)) &#123; for (int i = 0; i &lt;= n; ++i)fa[i] = i, sum[i] = 0; int ans = 0; while (m--) &#123; int l = fast_IO::read() - 1, r = fast_IO::read(), s = fast_IO::read(); int rtl = findf(l), rtr = findf(r); if (rtl == rtr) &#123; if (sum[l] - sum[r] != s) ++ans; &#125; else &#123; fa[rtl] = rtr; sum[rtl] = -sum[l] + sum[r] + s; &#125; &#125; fast_IO::write(ans); putchar('\n'); &#125; return 0;&#125; 可持久化并查集咕咕咕 优先队列（二叉堆）首先，优先队列并不是用队列实现的，一般我们用二叉堆来实现优先队列。那么什么是优先队列？就是队列中的元素被赋予的优先级，当我们访问优先队列时优先访问优先级高的元素。二叉堆，其实就是一棵二叉树，它满足父节点的优先级一定大于子节点的性质，换句话说，在二叉堆中，以任意节点x为根的子树中，x的优先级是最高的，这样的话，只要构建一个二叉堆，它的根节点就是优先级最高的点。12345678910111213141516171819202122232425262728293031323334//这里我们用一种比较方便的方法表示节点的左右孩子//x * 2表示x的左孩子，x * 2 + 1表示x的右孩子，可以证明这种表示方法是不会重复的//这样的话x / 2就可以表示x的父节点//f[x]表示x的优先级void shift1(int now, int len) &#123; //删除了堆顶，将一个优先级小的元素放到堆顶后，通过该操作维护堆的结构 //从顶向下去更新 int father = now , child = father &lt;&lt; 1; while (child &lt;= len) &#123; if (child &lt; len &amp;&amp; f[pq[child]] &lt; f[pq[child + 1]])++child; if (f[pq[child]] &gt; f[pq[father]])swap(pq[child], pq[father]); father = child, child &lt;&lt;= 1; &#125;&#125;void shift2(int now) &#123; //加入一个元素后，从加入的元素起向上更新，维护堆的结构 int child = now, father = child &gt;&gt; 1; while (father) &#123; if (f[pq[farther]] &gt;= f[pq[child]])break;//此时说明已经满足了堆的性质 //因为加入元素前堆是成立的，只有加入的元素破坏了堆的结构 swap(pq[father], pq[child]); child = father, father &gt;&gt;= 1; &#125;&#125;void add(int x) &#123; pq[++tot] = x; shift2(tot);&#125;dataType del() &#123; dataType x = pq[1]; pq[1] = pq[tot--];//将优先级小的放到堆顶 shift1(1, tot); return x;&#125; 手动实现起来相当麻烦，当然，C++的STL提供了priority_queue供我们直接使用，它支持以下基本操作：123456priority&lt;dataType&gt;pq;pq.top();//访问堆顶元素pq.push(x);//将x入队pq.pop();//将堆顶出队pq.size();//返回优先队列的元素个数pq.empty();//优先队列为空返回true 左偏树（可并堆）有些时候，我们需要将堆进行合并，这时候就用到左偏树。左偏树，左偏是啥意思？意思就是对于堆内任意一棵子树，其左子树中深度最小的叶子节点的深度要大于右子树中深度最小的叶子节点的深度，这样的话从整体上看，整棵树明显左边比较重。 具体实现：我们用并查集来维护不同的节点是否在同一个堆中，下面给出合并操作123456789101112int merge(int x, int y) &#123;//将y堆合并到x堆上，返回合并后的根节点 if (!x || !y)return x | y;//0当然是没有这棵树啦 if (f(x) &lt; f(y))swap(x, y);//f(x)表示x的优先级 //这时候就保证了x节点的优先级比y大，即y只能往x的子树合并，合并后x为根节点 rson[x] = merge(rson[x], y);//左偏树嘛，右子树比较轻，把y往右子树合并 if (dep[lson[x]] &gt; dep[rson[x]]) swap(lson[x], rson[x]); //永远保证rson[x]的最小深度比lson[x]的最小深度小，保证“左偏” dep[x] = dep[rson[x]] + 1;//x的最小深度 fa[lson[x]] = fa[rson[x]] = x;//x为根节点 return x;&#125; 合并自然不用说，如果要删除根节点，只需要合并左右子树就行了。]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>单调栈</tag>
        <tag>单调队列</tag>
        <tag>优先队列</tag>
        <tag>链表</tag>
        <tag>ST表</tag>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 1166D Cute Sequences]]></title>
    <url>%2F2019%2F05%2F18%2FCodeForces-1166D-Cute-Sequences%2F</url>
    <content type="text"><![CDATA[写篇题解祭一下因为脑子短路而逝去的几个小时 Description给定一个正整数$m$，定义一个正整数序列$x_1,x_2,x_3,…,x_n$，满足对于$2\le i\le n$有$x_i=x_{i-1}+x_{i-2}+…+x_1+r_i$，其中$1\le r_i\le m$现在给出$q$个询问，每个询问给出$a,b,m$，强制要求$x_1=a$，$x_n=b$，要求构造出一个长度不超过$50$的$x$序列 Input第一行一个正整数$q(1\le q\le 10^3)$表示询问数接下来$q$行，每行三个正整数$a,b,m(1\le a,b,m\le 10^{14},a\le b)$，意义见题面 Output没有合法序列输出$-1$有合法序列则先输出序列长度$k(k\le 50)$，然后$k$个数$x_1,x_2,…,x_k(1\le x_i\le 10^{14})$，其中$x_1=a,x_k=b$ Sample Input12325 26 23 9 1 Sample Output124 5 6 13 26-1 Solution又被sb题整弱智了.jpg很容易推出$b=2^{k-2}\cdot a+2^{k-3}\cdot r_2+…+2^{k-i-1}\cdot r_i+…+r_{k-1}+r_k$首先特殊情况是$a=b$，这时候直接输出$1\;a$考虑到$k$很小，先枚举长度$k$这时候$a$是确定的，因此可以先把$a$的部分减掉，同时把每个$r_i$都减$1$，这样来保证求出的$r_i$都是$\ge0$的，那么此时$0\le r_i\le m-1$定义$cha=n-2^{k-2}\cdot a-2^{k-2}$从$r_2$到$r_{k-1}$贪心考虑，系数大的尽量大，同时要注意不能超过$m-1$这样构造出来，最后剩余的$r_k=cha$如果在$m$以内，就是合法的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x &amp; -x)#define jh(x, y) x ^= y ^= x ^= y#define loc(x, y) (x - 1) * m + y#define rg register#define inl inline#define PI 3.141592654typedef long long ll;const int N = 6e2 + 5, INF = 0x3f3f3f3f, mod = 998244353;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r' &amp;&amp; ~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;ll r[N];int main(void) &#123; rg int q = fast_IO::read(); while (q--) &#123; rg ll a = fast_IO::read(), b = fast_IO::read(), m = fast_IO::read(); if (a == b) &#123; printf("1 %I64d\n", a); continue; &#125; rg bool can = false; r[1] = a; rg int len; for (rg int k = 2; k &lt;= 50 &amp;&amp; !can; ++k) &#123; rg ll cha = b - a * (1ll &lt;&lt; k - 2) - (1ll &lt;&lt; k - 2); if (cha &lt; 0)break; for (rg int i = 2; i &lt; k; ++i) r[i] = fast_IO::min(m - 1, cha / (1ll &lt;&lt; k - i - 1)), cha -= r[i] * (1ll &lt;&lt; k - i - 1); if (cha &lt; m) &#123; can = true, len = k, r[len] = cha; break; &#125; &#125; if (!can)puts("-1"); else &#123; rg ll sum = a; for (rg int i = 2; i &lt;= len; ++i)++r[i], r[i] += sum, sum += r[i]; fast_IO::write(len); for (rg int i = 1; i &lt;= len; ++i)putchar(' '), fast_IO::write(r[i]); putchar('\n'); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>思路</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ5480:路径的条数]]></title>
    <url>%2F2019%2F04%2F13%2FBZOJ5480-%E8%B7%AF%E5%BE%84%E7%9A%84%E6%9D%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Description给一棵$n$个点的有标号无根树，你需要找到满足条件的路径$u−v$的条数。我们称路径$u-v$满足条件当且仅当$u\not=v$且路径$u-v$上不存在点对$(a,b)$,$a,b$满足$gcd(a,b)=a$。注意：路径$u−v$和$v−u$是同一条路径。 Input第一行一个整数$n\le10^5$接下来$n−1$行，每行两个用空格隔开的整数$a,b$，表示边$(a,b)$ Output一行一个整数，代表要求的答案。 Sample Input43 13 23 4 Sample Output2//只有路径$2 − 3$和$3 − 4$满足条件 Solution这个题的转换很有意思我们考虑用总路径数-不合法的路径数来得到合法的路径数那么现在问题就在于，如何求不合法的路径数首先根据题意，枚举起点$u$，可以通过枚举$u$的倍数来得到一些不合法的路径，我们可以称之为“限制”，很容易得出：每一个不合法的路径必定至少包含一个“限制”知道这个有什么用呢？重头戏来了：设$dfn[x]$为$x$点的dfs序，$cover[x]$为$x$子树中最大的dfs序考虑不合法路径$a-b$，假设$a-b$包含路径$u-v$且$dfn[u]&lt;dfn[v]$，$dfn[a]&lt;dfn[b]$分两种情况讨论： $u$是$v$的一个祖先 $u$不是$v$的祖先 对于第一种情况这时候$a,b$和$u,v$有怎样的关系呢？我们来看下面这张图 这时我们发现，$a$可以是$g$子树外的任意一点，$b$可以是$v$子树内的任意一点，他们对应的dfs序关系为$dfn[a]$ $&lt;$ $dfn[g]\;\;and\;\;dfn[v]\le dfn[b] \le cover[v]$当然你可能会问：那如果我们先遍历图中$g$的那棵子树，上面这个关系就不成立了！（注意我们的前提条件，$a$的dfs序小于$b$）没错，所以我们还要讨论把上图中把$a,b$交换的情况，此时关系为$dfn[v]\le dfn[a] \le cover[v]\;\;and\;\;dfn[b] &gt; cover[g]$ 对于第二种情况这种情况相对较简单，还是先上图此时$a$是$u$子树中的任意一点，$b$是$v$子树中的任意一点所以对应的关系就是$dfn[u]\le dfn[a] \le cover[u]\;\;and\;\;dfn[v]\le dfn[b]\le cover[v]$ 说了这么多，这有什么用啊？ 考虑这样一个坐标系这个坐标系的横轴是$dfn[a]$，纵轴是$dfn[b]$再看看上面我们列出的条件，$dfn[a]$对应一个横轴上的区间，$dfn[b]$对应一个纵轴上的区间这不是矩形嘛！大致乱画一下，其实一堆条件（关系）就成了下面这个东西这些矩形内的每一个整点$(dfn[a],dfn[b])$，都是满足我们要求的东西，也就是不合法而每一个dfs序对应唯一节点，这样我们计算这些矩形内的整点个数就能得到不合法的路径数如何计算？线段树维护扫描线即可，只不过把求面积改成求矩形内点的个数，如果具体不清楚可以直接看代码，代码还算是比较简明的最终统计答案，由于我们这样求出的路径是无向的，设求出的路径数为$ans$答案就是$\dfrac{n*(n-1)}{2}-ans$ 复杂度：枚举$u,v$是$O(n\ln n)$的，线段树还要再乘个$\log n$，所以总复杂度应该是$O(n\ln n\log n)$ 最后献上本人丑陋的代码，现在是2019年3月28日22:06:10，目前在BZOJ是最快的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/************************************************************** Problem: 5480 User: Zechariah Language: C++ Result: Accepted Time:13152 ms Memory:193400 kb****************************************************************/ #include &lt;bits/stdc++.h&gt;#define lowbit(x) (x &amp; -x)#define jh(x, y) x ^= y ^=x ^= y#define loc(x, y) (x - 1) * m + y#define rg register#define inl inline#define PI 3.141592654typedef long long ll;const int N = 8e5 + 5, mod = 998244353, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;int cover[N], dfn[N], nt[N], b[N], p[N], num, id, fa[N][18], deep[N], tot, n;struct Node &#123; int left, right, min; ll sum;&#125;tree[N &lt;&lt; 2];struct Line &#123; int l, r, v, y; Line(rg int l = 0, rg int r = 0, rg int y = 0, rg int v = 0) :l(l), r(r), y(y), v(v) &#123;&#125; bool operator &lt;(const rg Line &amp;s)const &#123; return y &lt; s.y; &#125;&#125;e[N &lt;&lt; 2];inl void add(rg int x, rg int y) &#123; b[++num] = y, nt[num] = p[x], p[x] = num; b[++num] = x, nt[num] = p[y], p[y] = num;&#125;inl bool is(rg int x, rg int y) &#123; return dfn[x] &lt;= dfn[y] &amp;&amp; cover[x] &gt;= cover[y]; &#125;void dfs(rg int x) &#123; dfn[x] = ++id; for (rg int e= p[x]; e; e = nt[e]) &#123; if (b[e] == fa[x][0])continue; fa[b[e]][0] = x; deep[b[e]] = deep[x] + 1; dfs(b[e]); &#125; cover[x] = id;&#125;void build(rg int x, rg int l, rg int r) &#123; tree[x].left = l, tree[x].right = r; if (l == r)return; rg int mid = l + r &gt;&gt; 1; build(x &lt;&lt; 1, l, mid); build(x &lt;&lt; 1 | 1, mid + 1, r);&#125;inl void pushup(rg int x) &#123; if (tree[x].min)tree[x].sum = tree[x].right - tree[x].left + 1; else tree[x].sum = tree[x &lt;&lt; 1].sum + tree[x &lt;&lt; 1 | 1].sum;&#125;void update(rg int x, rg int l, rg int r, rg ll data) &#123; if (tree[x].left == l &amp;&amp; tree[x].right == r) &#123; tree[x].min += data; pushup(x); return; &#125; rg int mid = tree[x].left + tree[x].right &gt;&gt; 1; if (r &lt;= mid)update(x &lt;&lt; 1, l, r, data); else if (l &gt; mid)update(x &lt;&lt; 1 | 1, l, r, data); else &#123; update(x &lt;&lt; 1, l, mid, data); update(x &lt;&lt; 1 | 1, mid + 1, r, data); &#125; pushup(x);&#125;inl ll query() &#123; sort(e + 1, e + tot + 1); rg ll ans = 0; for (rg int i = 1; i &lt; tot; ++i) &#123; update(1, e[i].l, e[i].r, e[i].v); ans += tree[1].sum * (e[i + 1].y - e[i].y); &#125; return ans;&#125;inl int getfa(rg int x, rg int d) &#123; for (rg int j = 17; ~j; --j) if (d &amp; (1 &lt;&lt; j)) x = fa[x][j]; return x;&#125;inl void addedge(rg int x1, rg int x2, rg int y1, rg int y2) &#123; if (1 &lt;= x1 &amp;&amp; x1 &lt;= x2 &amp;&amp; x2 &lt;= n &amp;&amp; 1 &lt;= y1 &amp;&amp; y1 &lt;= y2 &amp;&amp; y2 &lt;= n) e[++tot] = Line(x1, x2, y1, 1), e[++tot] = Line(x1, x2, y2 + 1, -1);&#125; int main(void) &#123; n = fast_IO::read(); for (rg int i = 1; i != n; ++i)add(fast_IO::read(), fast_IO::read()); dfs(1); build(1, 1, n); for (rg int j = 1; j != 18; ++j) for (rg int i = 1; i &lt;= n; ++i) fa[i][j] = fa[fa[i][j - 1]][j - 1]; for (rg int i = 1; i &lt;= n; ++i) &#123; for (rg int j = i &lt;&lt; 1; j &lt;= n; j += i) &#123; rg int x = i, y = j; if (dfn[x] &gt; dfn[y])jh(x, y); if (is(x, y)) &#123; rg int node = getfa(y, deep[y] - deep[x] - 1); addedge(1, dfn[node] - 1, dfn[y], cover[y]); addedge(dfn[y], cover[y], cover[node] + 1, n); &#125; else addedge(dfn[x], cover[x], dfn[y], cover[y]); &#125; &#125; fast_IO::write((ll)n * (n - 1) / 2 - query()); return 0;&#125;]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>思路</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day6]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day6%2F</url>
    <content type="text"><![CDATA[Day 6——字符串一、哈希（哈希）把信息量大的东西压缩成信息量小的表达。 例题一、给出两个排列$a,b$，长度分别为$n,m$，你需要计算有多少个$x$，使得$a_1+x,a_2+x,a_3+x,…,a_n+x$是$b$的子序列。$n\le m\le2\times 10^5$ 思路枚举$b$中与$a$匹配的最大值$x$，把$x-n+1$ 例题二、你可以通过交换字母来修改字符串。如果两个字符串经过这样的变换之后可以相等，则称它们相似。给出一个文本串$T$与一个模式串$P$，询问$T$中有哪些子串与$P$一模一样或相似。$|T|,|P|\le10^6$ 思路考虑如何判断两个字符串相似。记录$last_i$表示上一次出现$p_i$的位置，我们发现两个字符串的$last$数组相同，他们就是相似的。然后直接KMP比较（或者哈希）。 二、KMP求出$next$数组，$next_i$表示当第$i$个位置失配的时候，应该从后面的什么位置开始匹配。求最长公共前后缀，这样就可以求出$next$数组。 模板1234567891011121314151617181920212223242526272829char s[N], t[N];int nt[N];inl void getnext()&#123;//模式串与自己匹配求出next数组 rg int len = strlen(t), i = 0, j = -1; while (i &lt; len) &#123; if (j == -1 || t[i] == t[j])nt[++i] = ++j; else j = nt[j]; &#125;&#125;inl void kmp()&#123; getnext(); rg int lens = strlen(s),lent=strlen(t), i = 0, j = 0; while (i &lt; lens) &#123; if (j == -1 || s[i] == t[j]) &#123; ++i, ++j; if (j == lent) &#123; j = nt[j]; //此时[i-lent+1,i-1]的子串是与t串匹配的 &#125; &#125; else j = nt[j]; &#125;&#125; 例题一、给出一个长度为$n$的串$S$，判断$S$的每个前缀是不是循环串，如果是输出最大循环次数。循环串的定义：由一个相同的串重复至少两次拼成。$n\le10^6$ 思路如果一个串是循环串，那么这个串就是$m$个小串的拼接，他的$next$就是$m-1$个小串。由于$s_{1…next}$与$S_{n-next…next}$是相同的两串，那么只要$i\mod(i-next)=0$，那么该串是一个以$i-next$为最小循环节的串。 例题二、给出一个长度为$n$的串$S$，你需要选取$S$的一个前缀$T$，使得$T$重复若干次可以拼出$S$（拼合可以有部分重复，但是重复部分必须相同）。最小化$T$的长度$n\le10^6$ 思路根据$next$建出$fail$树，贪心即可。 三、AC自动机（Aho-Corasick automation）例题一、给出含有$n$个单词的词典，你需要计算对于所有长度为$m$的字符串，有多少个至少包含一个单词。字符集为大写字母。$n\le60,m\le100,$每个单词长度$\le100$ 思路建出AC自动机，将每个单词结尾设为不可通行，计算从根节点开始走$m$步的总方案数，用总字符串数$-$总方案数即可。 例题二、给出$n$个字符串和$m$个询问，每次询问$i,j,k,l$，求第$i$个串的$j$长前缀和第$k$个串的$l$长前缀的最长公共后缀。$\sum S_i\le10^6$ 思路建出AC自动机，求所求两个前缀在$fail$树上的LCA即可。 例题、三给定$n$个字符串$s_i$，问最多能从中选择多少个串，使得其中不存在一个串是另一个串的子串。$n\le750,\sum|s_i|\le10^7,s_i\in\left\{a,b\right\}$ 思路四、后缀数组（SA）模板1234567891011121314151617181920212223242526272829303132333435363738int rk[N], sa[N], b[N], m, n, tong[N], height[N];char s[N];inl void radix_sort()&#123; memset(tong, 0, sizeof(tong)); for (rg int i = 1; i &lt;= n; ++i)++tong[rk[b[i]]]; for (rg int i = 1; i &lt;= m; +i)tong[i] += tong[i - 1]; for (rg int i = n; i &gt;= 1; --i)sa[tong[rk[b[i]]]--] = b[i];&#125;inl void getsa()&#123; for (rg int i = 1; i &lt;= n; ++i)rk[i] = s[i] - 'a' + 1, b[i] = i; radix_sort(); for (rg int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; rg int tot = 0; for (rg int i = n - k + 1; i &lt;= n; ++i)b[+tot] = i; for (rg int i = 1; i &lt;= n; ++i)if (sa[i] &gt; k)b[++tot] = sa[i] - k; radix_sort(); memcpy(b, rk, sizeof(b)); rk[sa[tot = 1]] = 1; for (rg int i = 2; i &lt;= n; ++i) if (b[sa[i]] == b[sa[i - 1]] &amp;&amp; b[sa[i] + k] == b[sa[i - 1] + k])rk[sa[i]] = tot; else rk[sa[i]] = ++tot; if (tot == n)break; m = tot; &#125;&#125;inl void getheight()&#123; rg int k = 0; for (rg int i = 1; i &lt;= n; ++i)rk[sa[i]] = i; for (rg int i = 1; i &lt;= n; ++i) &#123; if (rk[i] == 1)continue; rg int j = sa[rk[i] - 1]; while (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; s[j + k] == s[i + k])++k; height[rk[i]] = k; &#125;&#125; 例题一、给出$n$个串，找出一个最长的子串，至少在$\dfrac{n}{2}$个串中出现过。$\sum S_i\le10^5$ 思路将所有字符串拼起来，求$SA$和$Height$，做滑动窗口，求RMQ。 结论一个字符串的不同子串个数为$\dfrac{n(n-1)}{2}\sum\limits_{i=1}^{n}Height_i$ 例题二、给出一个小写字符串$S$以及$m$个询问，每个询问给出两个正整数$x,y$（$x\le y\le$字符串$S$本质不同的子串个数），表示询问$s$的所有本质不同的子串中，字典序排名为$x$到$y$之间的所有字符串的哈希值总和（包括$x$和$y$）。$|S|,m\le10^5$ 思路考虑转化为对前缀的查询，避免对两个子串的相同前缀重复计算，我们只用对不相同的部分二分求 例题三、给出一个字符串，将其划分为不超过$k$个连续子串。设第$i$个子串为$s_i$，对于每个$s_i$，找到其中字典序最大的连续子串$c_i$。你需要找到一种划分，使得字典序最大的$c_i$字典序最小。$|S|\le10^6$ 思路二分字典序，每次从后往前考虑，使得每个子串字典序不超过二分的答案，统计字典序的方法：二分一个后缀，再在后缀上二分。 例题四、给定一个字符串$S$，有$m$个询问，每组询问形如$(a,b,c,d)$，询问$S_{a…b}$的所有子串中与$S_{c…d}$的最长公共前缀的最大值是多少。$|S|\le10^5m\le10^5$ 思路二分答案$x$，找到$SA$中与后缀$c$LCP大于$x$的部分，查询是否含有$[a,b]$中的元素，二维数点问题，主席树求解。 例题五、给出一个长度为$n$的数组$a_i=i$，把它进行$m$次操作，每次操作可以是以下两种： 把某一段提到开头 区间翻转 现在问后缀数组为$a$的字符串$S$有多少种可能。限制$S$为字符串中出现的都是正整数，且最大元素等于不同元素的个数。$n\le10^9,m\le10^5$ 思路考虑后缀数组的定义$suf_{a_i}&lt;suf_{a_{i+1}}$于是推出$S_{a_i}\le S_{a_{i+1}}$可以发现确定每一个$\le$为$&lt;$或$=$，就能唯一确定整个数组。取$&lt;$一定合法，取$=$要求$suf_{a_{i+1}}&lt;suf_{a_{i+1}+1}$ 五、后缀自动机（SAM）字符串$S$的后缀自动机是一个能接受$S$的所有子串的有限状态自动机。 Right集所有该字符串的右端点组成的集合称为该串的$Right$集，$Right$集不同的串即为本质不同的串子串的$Right$集只有包含与并列关系由于这样的性质，我们可以建出一棵树，这棵树称为$fail$树。 建立SAM$last$:已经建立好的$SAM$因为新后缀而创建的最后一个节点。]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day5]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day5%2F</url>
    <content type="text"><![CDATA[Day5 上午——动态规划大纲DP的类型序列DP数位DP概率DP树形DP状态压缩DPDP套DP DP的优化形式优化决策单调性优化斜率优化凸单调性DP优化 例题、[HAOI2011]problem a题面见P2519 思路将问题转化一下，一个人说的话如果为真说明从第$a_i+1$到第$n-b_i$个人的分数是一样的.如果我们把这样一个模型看成一条线段，那么在这$n$条线段中，相交且互不重合的线段一定不能同时为真话，所以问题就转化为选出尽可能多的不相交或完全重合的线段，且对于某条线段完全重合的个数要小于等于线段长。所以做法就很明显了，先求出说最多的说真话的人数，用总人数去剪。具体做法为：将每个人对应的线段放在一起进行双关键字排序，合并完全包含的线段，每一个线段上存一个权值$V_i$，现在就是要从$m$个线段中取出不相交的线段使得权值和最大，这就可以DP了。将所有线段按右端点排序，设$f_i$为到第$i$个线段的最优解。转移的时候先二分$[1,i)$之间满足$R_k&lt;L_i$的$f_k$最大的$k$，转移方程为$f_i=\max(f_{i-1},f_k+V_i)$最终答案为$n-f_m$ 一、数位DP数位DP常用来统计或查找一个区间满足条件的数，然后按数位顺序DP，一般需要仔细分情况讨论，常见处理如将区间拆为$[1, R], [1, L)$，记忆化，预处理等。 例题一、[SDOI2013]淘金题面见P3303 思路考虑对于一个$i$，有多少$j$满足$f_j=i$，记为$v_i$不难发现，$[1,n]$内的任何数各位相乘的结果最多只有4个质因子$2 ,3 ,5 ,7$，也就是说$i$可以被分解为$2^a\times 3^b\times5^c\times7^d$，这样的$i$在$n\le10^{12}$范围内其实是很少的这个个数设为$m$。所以我们可以设计状态$f_{i,j,0/1}$表示从低位到高位的第$i$位，各位的乘积为$j$（离散化后），最后一维表示是否小于等于$N$转移的时候枚举第$k$位，如果$k|j$那么$dp_{i,j,0/1}$可以从$dp_{i-1,\dfrac{j}{k},0/1}$转移过来最终我们是要求位置$(x,y)$的价值$v_x\times v_y$的前$K$大之和。考虑将$v$从小到大排序，用大根堆维护$m$个指针$p_i$，分别表示的是$v_1$到$v_m$，维护堆的关键字为$v_{p_i}\times v_i$，贪心选择$K$个求和得到答案。 二、概率和期望DP概率DP是一类求事件概率或期望的DP的总称。对于求概率问题，有时利用补集转化，或者将其转化为计数问题；而对于求期望则大多利用期望的线性性来解决问题。 贝叶斯公式条件概率$P(y|x)$联合概率$P(y,x)$$P(x,y)=P(x,y)=P(y|x)P(x)=P(x)P(y)$$P(x,y)=P(x|y)P(y)$贝叶斯公式：$P(y|x)=\dfrac{P(x|y)P(y)}{P(x)}$ 例题一、亚瑟王给你$N$张牌，每张牌有一个发动概率 $P_i$ 以及伤害 $D_i$，共有$R$回合，每回合会按编号从小到大依次考虑本次游戏中还未发动的卡牌，依次尝试发动，如果发动成功，进入下一回合，求期望伤害之和，共 $T$组数据。$T\le444,N\le220,R\le132$ 思路$dp_{i,j}$表示前$i$张牌发动了$j$张的概率求出每张牌发动的概率$sump_i=\sum\limits_{j=0}^rdp_{i-1,j}(1-(1-p_i)^{r-j})$$dp$可以DP求得$dp_{i,j}=\sum\limits_{j=0}^r(dp_{i-1,j}(1-p_i)^{r-j}+dp_{i-1,j-1}(1-(1-p_i)^{r-j+1}))$ 例题二、Museum题面见CF113D 思路解法一、设$ f_{i, j} $为第一个人在$ i$, 第二个人在$ j$,此时开始,之后在$ t $点相遇的概率.枚举终点, 做$ n $次高斯消元即可,不过直接这样做是$ O(n^7)$的.注意到每次高斯消元时,$ Ax = B $只有$ B $发生了变化.于是把$ B $改成一个矩阵就可以$ O(n^6)$了.最后通过$f_{i,j}=\sum\limits_{1\le i\le n}A_if_{i,i}$,令$f_{i,i}=1$就可以求出所有解 解法二、设$f(i,j)$为第一个人在$i$，第二个人在$j$这种情况的期望出现次数，因为终止状态只会出现0/1，于是期望就是概率了。 三、树形DP树形DP是指基于树的结构的动态规划，基础的有： 树的直径：DP记录子树内最长路 树的重心：DP记录子树大小 树上最大权独立集：DP记录子树的根是否选择 树形依赖背包：在dfs序上DP(即每次选择是否跳过子树)，或通过父节点的DP值传入孩子DP 虚树：在原树上只保留需要的点与他们的LCA的树称为虚树，建树方法为：将点按dfs序排序，一次将点加入，用一个栈维护树上的已加入的点和他们LCA的右链，每次加入一个点，与栈顶比较，便可以建出虚树 … 例题一、大工程题面见P4103 解答有着询问的和小于的限制的题是虚树的一个显著的特征。建出虚树, 然后直接在上面树形DP。设$ f_i $为以$ i $为根的子树内路径的代价和,$ size_i $为$ i $的子树中询问点的个数,$ max_i $为$i$子树内的到$ i $的最长路,$ min_i $为最短路，则：$f_i=f_{son_i}+size_i\times k-size_{son_i}$$max_i = \max\left\{max_{son_i} + 1\right\}$路径和答案是$ f_{root}$, 对于每个点,用它的最大与次大的儿子更新答案.如果他是被询问的点,则还可以用它每个儿子更新答案. 四、状态压缩DP基于状态压缩的DP是由于状态用单个简单的变量直接存储存在空间的浪费，而采用压缩的状态的动态规划，例如： 插头DP：维护当前已决策和未决策的一条$Z$字形的轮廓线的插头状态，用括号序列配对插头，每次只需分情况讨论即可，但是这类DP的显著特点就是情况繁多，使用时须细心 例题、给一个$N$个点$M$条边的无向图，每个点有点权$A_i$，保证任意两点之间距离不超过$10$。现在要你选取一些点，使得每个点要么自己被选，要么相邻的点被选。一个方案的代价定义为选取的点的点权和，求最小代价。$N\le20000,M\le25000,0\le A_i\le10000$ 解法考虑如何利用 “距离不超过10” 这个限制.不妨把生成树搞出来,那么这个树的深度$ \le 10$. 一个很显然的想法是DP时,对每个点设状态$ dp_{u, S}$, 表示以$ u $为根的子树,当$ u $到根这条路径上的点的选取情况是$S $时的最小代价.由于,一个点可能会对通过非树边覆盖祖先,对于$S$中每个未选取的点,我们可以再记录一下它是否已经被覆盖.对于一个点状态数是$3^{10}$的.用$3$进制来表示$S$. 规定一下$S$中某一位的值的意义: 0: 这个点被选取了 1: 这个点未被选取, 但已经被覆盖 2: 这个点未被选取, 且仍未被覆盖 在DFS序上做即可.转移并不困难,注意的是当DFS序中前一个点不是当前点的父亲时,要把$dp$值维护一下.使用滚动数组,空间复杂度$ O(N + M + 3^{10})$,时间复杂度$O(M + 3^{10}N)$.对每个连通块都要做一遍. 例题一、对于任意一个正整数$N\le10^5$，求出${1,2,…,N}$的满足”若$x$在该子集中，则$2x,3x$不能在该子集”的子集个数。答案对$10^9+1$取模。$N\le10^5$ 思路将题目转化为“一个网格图，相邻点不能选”的计数问题，枚举左上角就行了。 五、DP套DP某些DP问题的子判定问题不能简单的解决,而必须用另一个DP解决,此时就只能使用DP套DP的方法,即：外面的DP的状态是存的里层DP各个状态的值,利用里层的状态来判断外层的DP是否合法,类似的问题有LCS为定值的序列的方案数等等。 例题一、给你一个只由$ACGT$组成的字符串$S$，对于每个$0\le k\le |S|$，问有多少个只由$ACGT$组成的长度为$M$字符串$T$，使得$LCS(S,T)=k$.$|S|\le15,M\le10^3$ 思路DP套DP，算LCS的DP为$dp_{i,j}=max(dp_{i-1,j-1}+[T_i=S_i],dp_{i-1,j},dp_{i,j-1})$这题的$ |S| $很小,不妨对于每个$ i$, 将$ j $不同时的DP值都记录下来,计个数即可.但是直接记DP值状态数会爆内存,但是注意到相邻的DP值只会差$1$,所以我们可以用$ 2^{|S|} $的状态数将这些值记录下来. 六、DP的形式优化有时在做一个DP问题时将会遇到时间或者空间复杂度过高的问题,而在DP的形式上优化便是有效的优化技巧, 典型的有预处理, 分阶段DP等: 预处理: 我们可能发现, 在DP的过程中, 出现了重复的运算, 浪费了时间, 所以我们可以通过DP前预处理, 或者DP过程总处理出最值, 而达到为后面的DP提供便捷的功能与作用, 达到优化的目的 分阶段DP: 在某些DP中将DP拆为一个个有特点阶段也许比将整个DP放在一起更加节省时间与空间, 所以对于彼此相对无关的转移, 可以分开考虑 例题一、给定长度为$N,M$的数组$A,B$，求最长公共上升子序列。$N,M\le5000$ 思路状态设计：$dp_{i,j}$表示$A$考虑到$i$，$B$考虑到$j$且必须选$j$的长度当$A_i=B_j$时，有转移$dp_{i,j}=\max\left\{dp_{i-1,k}|k&lt;j,B_k&lt;B_j\right\}+1$由于$A_i=B_j$，这个限制事实上就是$B_k&lt;A_i$，对于同一个$i$限制是相同的。我们可以从小到大枚举$j$，维护$\max\left\{dp_{i-1,k}|k&lt;j,B_k&lt;A_i\right\}$，直接转移即可。 例题二、现在有$n$个活动，每个活动需要占用$[l_i,r_i)$的时间，现在有两个会场，两个会场不能同时有活动，但是一个会场可以同时举办多个活动。要求安排每个活动在哪个会场举行，或者不举行，使得举行活动较少的会场举行活动最多。同时，对$i\in[1,n] $求出如果强制活动$i$必须举行，那么所求答案是多少。$n\le200$ 思路第一问，预处理出$[l,r)$表示$[l,r)$包含多少段区间，设$f_{i,j}$表示考虑了$[0,i)$区间，第一个会场举办$j$个活动的前提下，第二个会场最多举办多少活动。第二问，处理出DP数组的前后缀，对于每个询问合并答案令$g_{i,j}$表示考虑了$[i,size)$这个区间时的DP数组，不难想到：处理出$max_{l,r}$表示$[l,r)$区间一定选时的答案，然后合并前后缀。考虑优化合并过程，我们发现前缀和后缀都具有单调性，双指针即可。最终复杂度$O(n^3)$ 七、决策单调性优化DP问题的转移往往需要大量的时间, 如果我们能发现一些性质, 找到一些规律来优化 DP 决策转移的过程, 那么在时间上我们便能得到很大的优化, 常见的有四边形不等式优化, 以及一些1D/1D动态规划的优化。 四边形不等式优化对于形如以下DP:$f_{i,j}=f_{i,k-1}+f_{k,j}+w_{i,j}$如果$w$满足四边形不等式： 任意$i\le i’\le j\le j’$，有$w_{i,j}+w_{i’,j’}\le w_{i’,j}+w_{i,j’}$ 任意$i’\le i\le j\le j’$，有$w_{i,j}\le w_{i’,j’}$ 那么也可证明：$f_{i,j}+f_{i’,j’}\le f_{i’,j}+f_{i,j’}$而如果得到了这样的式子, 则就可以证明$ f_{i, j} $的决策一定在$f_{i, j − 1} $与$ f_{i − 1, j} $的决策之间:$s_{i,j-1}\le s_{i,j}\le s_{i-1,j}$四边形不等式的证明：http://wenku.baidu.com/link?url=344UHCQdTP9z2dFTCCGB3eBYHnlBeF0IAYdFeLmA_p0QU9nGv3L-6AyISk4zUKcTMBDrokvx_i-5BHh7H5ZFfjS3hf2j9jHdPCgUXwQjqS 1D/1D动态规划方程的优化$f_i=\min\left\{f_j+w_{j,i}|j\le i\right\}$若$w$满足四边形不等式，则可证明$f_i$的决策也一定单调。 例题一、NOI2009 诗人小G题面见P1912 思路首先推出DP方程:$f_i=\min\left\{f_j+|sum_i-sum_j-l|^p\right\}$令$w_{i,j}=|sum_i-sum_j-l|^p$，可以证明（不会证）$w$满足四边形不等式。由上述结论，对于任意的$i\le j$，$f_i$的决策一定$\le f_j$的决策，于是我们用一个栈来维护DP的决策。 八、斜率优化斜率优化DP是当DP转移式形如$f_i = \min\left\{f_j + k_ix_j + c_i + b_j\right\}$将与$ j $无关的常数提出$ \min$，我们就是要求$\min\left\{k_ix_j + f_j + b_j\right\}$令$ y_j = f_j + b_j$，每次我们实际上是在所有过 $(x_j , y_j )$ 且斜率为$-k_i $的直线$y_j =-k_ix_j+B$中找到一个直线具有最小的$ B$，即纵截距最小。显然最优的$(x_j , y_j ) $一定在凸壳上。于是我们便可以使用维护凸壳来将时间复杂度变得更优。根据$ x_j $和$ k_i $的单调性，我们可以： $x_j $与$ k_i $同时单调: 单调队列/单调栈 (hdu 3507) $x_j $单调,$ k_i $不单调: 单调队列/单调栈+二分斜率 (bzoj 2726) $x_j $不单调: Splay维护凸壳 (bzoj 1492) 九、凸单调性DP优化例题一、IOI2016 aliens题面见uoj240 思路将主对角线一边的点翻到另一边，去除一些无用点，首先可以推出一个显然的DP方程 $dp_{i,j}=\max\limits_{k&lt;j}\left\{dp_{i-1,k}+(x_j-y_{k+1}+1)^2-\max(0,x_k-y_{k+1}+1)^2\right\} $其中$dp_{i,j}$表示用$i$个正方形覆盖$j$个点所需要的最小并面积。这个转移方程可以很容易斜率优化，时间复杂度就变成$O(nk)$当然这并不能满足题目要求。如果$dp_{k,n}$是一个关于$k$的凸函数，那么不妨二分$dp_{k-1,n}$和$dp_{k,n}$这两个状态之间的差值（用一个一次函数取切，得一个切点）。将DP方程改为$dp_i=\max\limits_j&lt;i\left\{dp_j+(x_i-y_{j+1}+1)^2-\max(0,x_j-y_{j+1}+1)^2\right\}+x$转移一次有$x$的代价，记录一下$dp_n$转移达到最优值所需要的最少转移次数，就可以二分了。 十、容斥DP例题一、给定$n$个数$a_1,a_2,…,a_n$，将这些数分成两组，使得两组中的元素$or$和相同，求方案数，答案对1e9+7取模。$n\le50,0\le a_i\le2^{20}$ 解法按位考虑, 如果所有的数在某一位上都为$ 0$, 显然可以不用考虑.对于其它的位, 如果要满足题目的要求, 则必须满足所有这一位为$ 1$的数不能全部在同一组里. 虽然这个条件不好计数, 但是它的反面是很好计数的!所以, 枚举至少有哪些二进制位不满足条件, 然后用并查集维护一下就行了. 例题二、给定一个$N$维超立方体，第$i$个维度的长度为$r_i$，同时给你一个$N$维超平面$x_1+x_2+…+x_n=S$。这个超平面把超立方体切成至多两部分，求圆点所在那一部分的面积。$N\le500,A_i\le500,S\le10^9$ 思路有点超纲。。。学了微积分再补 例题三、[ZJOI2016]小星星题面见P3349 思路首先考虑一个错误的树形DP. 设$ dp_{u, p} $表示考虑了以$ u $为根的这个子树, 并且根映射到原图的$ p $点. 这个显然可以$ O(n^3) $转移, 但是有什么问题呢?不同的点可能映射到同一个点. 于是考虑容斥.求出$ dp_S $表示映射的点集至多为$ S $时的答案, 然后就可以$O(2^nn^3) $做了. 容斥何时起作用 $=$和$\not=$ $\min$和$\max$ gcd和lcm “恰好”和”至少” … 容斥的理解给定一些条件，问全部满足的对象的个数答案$=$所有对象$-$至少不满足其中一个的$+$至少不满足其中两个的$-$至少不满足其中三个的…另一种理解：在所有物品中, 问在某个条件$C_0$下所有物品的贡献之和.构造一些相对容易计算贡献的条件$C_1,…,C_n$再对于每个条件构造容斥系数 $f_1,…,f_n$ 满足对于每个物品$\sum\limits_{i=1}^{n}s_{C_i}f_i=s_{C_0}$其中$s_{C_i}$表示这个物品在条件$C_i$下所产生的贡献.对于常见的计数问题, 物品的贡献只会是$0/1$, 表示这个物品是否满足此条件. 凑系数一个经典的错排问题求长度为$n$的排列$a_1,…,a_n$的个数，满足$a_i\not=i$错排数：排列的不动点，即$a_i=i$的位置. 例题四、小学奥数（雾）给定$m$个数$a_1,a_2,…,a_n$，统计$[1,n]$的整数中，满足$a_1,a_2,…,a_n$中有奇数个数整除它的个数。$n\le10^9,m\le15$ 思路枚举$m$个数的一个子集，算出$lcm$，容斥一下。对于每个数，如果它被$k$个数整除，则有$\sum\limits_{i=0}^{k}C^i_kf_i=k\mod 2$可以求出所有的$f_i$ 例题五、异或图题面见bzoj4671 思路容斥。首先枚举子集划分，强制连通性“至少”是这个划分，也就是说，不同子集的两个点之间一定没有边，相同子集的两个点则任意.对于一个有$m$个联通块的图，容斥系数需要满足$\sum\limits_{i=1}^{m}$ 例题六、[NOI2009]管道取珠题面见P1758 技巧：平方处理思路统计平方的和, 转化成统计有序对.即统计有多少对$(wayA, wayB)$使得$wayA, wayB$均能得到相同的结果. 例题七、给定$S, T, K,$求每次$+1, −1,$用不超过$K$次操作从$S$变成$T$的方案数.每一时刻都不能为负$S,T,K\le10^5$ 技巧：反射法在平面直角坐标系中画出图像($x $轴代表时间,$ y $轴代表当前的数值), 发现所有不合法的路径都可以沿$ y = −1 $反射到一条从$(-(S + 2), 0) $到$ (T, 0) $的路径.直接组合数计算即可. 当然直接减一下转化为不能穿过对角线也是一样的.]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day4]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day4%2F</url>
    <content type="text"><![CDATA[Day4 上午——数学一、BSGS给定质数$p$，给定$a$和$b$，$(a,p)=1$。求最小的非负整数$x$，使得$a^x\equiv b(mod\;p)$。 解法首先根据欧拉定理$a^{\phi(p)}\equiv1(mod\;p)$，当$a^x\equiv b(mod\;p)$有解，最小非负整数解一定在$[0,\phi(p))$中。令$m=\sqrt{\phi(p)}$，任意$x\in [0,\phi(p))$都可以分解成$im+j$的形式，其中$0\le i \le m,0 \le j &lt;m$。枚举$i$的值，$a^x\equiv b(mod\;p)\Leftrightarrow a^j\equiv a^{-im}b(mod\;p)$。将$a^0,a^1,a^2…$放到$hash$表中查询就可以了。复杂度：$O(\sqrt{\phi(p)})$另外，如果要解决$p$不为素数的情况，需要用到$exBSGS$ 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x)#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e2 + 5, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;ll mod;inl ll ksm(rg ll a, rg ll b)&#123; rg ll ans = 1; for (; b; b &gt;&gt;= 1, (a *= a) %= mod) if (b &amp; 1)(ans *= a) %= mod; return ans;&#125;inl ll BSGS(rg ll a, rg ll b)&#123; rg ll p = mod; a %= p, b %= p; map&lt;ll, ll&gt;mp; rg ll m = ceil(sqrt(p)), t = 1; for (rg int i = 0; i &lt; m; ++i) &#123; if (!mp.count(t)) mp[t] = i; (t *= a) %= p; &#125; rg ll k = ksm(t, p - 2), w = b; for (rg int i = 0; i &lt; m; ++i) &#123; if (mp.count(w))return i * m + mp[w]; (w *= k) %= p; &#125; return -1;&#125;int main(void)&#123; rg ll a, b; while (~scanf("%lld%lld%lld",&amp;mod, &amp;a, &amp;b)) &#123; rg ll ans = BSGS(a, b); if (~ans)fast_IO::write(ans), putchar('\n'); else puts("no solution"); &#125; return 0;&#125; exBSGS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#pragma GCC optimize("fast-math,unroll-loops")#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")#include &lt;bits/stdc++.h&gt;#include &lt;unordered_map&gt;#define lowbit(x) (x&amp;-x)#define jh(x, y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e2 + 5, mod = 998244353, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;unordered_map&lt;ll, ll&gt;mp;ll a, b, p;inl ll GCD(rg ll a, rg ll b) &#123; while (b ^= a ^= b ^= a %= b); return a; &#125;inl ll exBSGS(rg ll a, rg ll b, rg ll p)&#123; if (b == 1)return 0; rg ll gcd, add = 0, mul = 1; while ((gcd = GCD(a, p)) ^ 1) &#123; if (b%gcd)return -1; b /= gcd, p /= gcd, ++add; (mul *= a / gcd) %= p; if (mul == b)return add; &#125; rg ll m = sqrt(p) + 1, kt = 1; mp.clear(); for (rg int i = 0; i != m; ++i) &#123; mp[kt*b%p] = i; (kt *= a) %= p; &#125; (mul *= kt) %= p; for (rg int i = 1; i &lt;= m; ++i) &#123; if (mp.find(mul) != mp.end())return i * m - mp[mul] + add; (mul *= kt) %= p; &#125; return -1;&#125;int main(void)&#123; while (a = fast_IO::read(), p = fast_IO::read(), b = fast_IO::read()) &#123; rg ll ans = exBSGS(a, b, p); if (~ans)fast_IO::write(ans), putchar('\n'); else puts("No Solution"); &#125; return 0;&#125; 二、Miller-Rabin给定$n$，判定$n$是否为素数。 解法首先筛去偶数，我们只考虑奇数的情况。显然$\forall x\in[1,p-1],x^p\equiv x(mod\;p)$，但是有些合数也满足这个性质，所以不能直接用这个性质来判断一个数是不是素数。考虑$x^2\equiv 1(mod\;n)$的根，若$n$是奇素数，则只有$1$和$n-1$(即$-1$两根)，因为原式可以改写成$(x+1)(x-1)\equiv 0(mod\;n)$。设$n-1\equiv 2^r\times d$，其中$d$是奇数。$n$是合数当且仅当存在$0\le k&lt; r,a^{2^k\times d}\not\equiv1,-1(mod\;n)$，且$a^{2^{k+1}\times d}\equiv1(mod\;n)$。选取多个$a$进行二次探查，减小错误率。 模板（int64）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x)#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e2 + 5, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;ll num[11] = &#123; 0,2,3,5,7,11,13,17,19,23,29 &#125;;inl ll ksm(rg ll a, rg ll b, rg ll mod)&#123; rg ll ans = 1; for (; b; b &gt;&gt;= 1, (a *= a) %= mod)if (b &amp; 1)(ans *= a) %= mod; return ans;&#125;inl bool detective(rg ll x, rg ll n)&#123; rg int r = 0; rg ll d = n - 1; while (!(d &amp; 1))d &gt;&gt;= 1, ++r; for (rg ll a = ksm(x, d, n), b; r; --r) &#123; b = a * a%n; if (b == 1)return a == 1 || a == n - 1; a = b; &#125; return false;&#125;inl int Miller_Rabin(rg ll x)&#123; for (rg int i = 1; i &lt;= 10; ++i) &#123; if (x == num[i])return 1; if (x%num[i] == 0)return 0; if (!detective(num[i], x))return 0; &#125; return 1;&#125;int main(void)&#123; rg int m = fast_IO::read(); while (m--)puts(Miller_Rabin(fast_IO::read()) ? "Yes" : "No"); return 0;&#125; 实践结论对于$int32$范围内的数，我们选取$2,7,61$探测即可。对于$int64$范围内的数，我们选取前十个素数探测即可。 三、Pollard-rho给定$n$，将$n$质因数分解。 解法如果用Miller-Rabin测试出来$n$是素数，直接停止算法。随机基底$a$和$c$，，生成序列$x_0=a,x^2_{i-1}+c(mod\;n)$，可以说序列${x_i}$是一个随机序列。如果出现$(x_i-x_{2i+1},n)\not=1$，停止算法。令$d=(x_i-x_{2i+1},n)$，若$d\not=n$，那么$d$就是$n$的一个非平凡因子，$n$可以被分为$\dfrac{n}{d}$和$d$相乘的结果，递归下去对$\dfrac{n}{d}$和$d$分别求解。复杂度$O(N^{\dfrac{1}{4}})$ 四、Linear-Shaker给定$n$，筛出$n$以内的所有素数。 解法见线性筛模板P3383。 五、Chinese Reminder Thereom$x\;mod\;n_1=x_1$$x\;mod\;n_2=x_2$$x\;mod\;n_3=x_3$…其中$n_1,n_2,…,n_k$两两互质，求$x$的一个合法解。 解法令$N=\prod\limits_{i=1}^{k}n_i$，$m_i=\dfrac{N}{n_i}$，$t_i=m_i^{-1}(mod\;n)$。$x=\sum\limits_i x_im_it_i(mod\;n)$我们容易发现，当$j=i$时，$m_it_i\equiv1(mod\;n_j)$，当$j\not=i$时，$m_it_i\equiv0(mod\;n_j)$，因此$x$一定是方程组的一组解。 模板（UVA756）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x)#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e2 + 5, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;ll mod[3]&#123; 23,28,33 &#125;, x[3];ll exgcd(rg ll a, rg ll b, rg ll &amp;x, rg ll &amp;y)&#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; rg ll yu = exgcd(b, a%b, x, y); rg ll tmp = x; x = y; y = tmp - a / b * y; return yu;&#125;inl ll CRT(rg int n)&#123; rg ll sum = 1, ans = 0, m; for (rg int i = 0; i != n; ++i)sum *= mod[i]; for (rg int i = 0; i != n; ++i) &#123; rg ll xx, y; m = sum / mod[i]; exgcd(m, mod[i], xx, y); ans += m * xx *x[i]; &#125; return ans % sum;&#125;int main(void)&#123; rg int d, step = 0; while (~(x[0] = fast_IO::read())) &#123; x[1] = fast_IO::read(), x[2] = fast_IO::read(); rg ll ans = CRT(3) - fast_IO::read(); ((ans %= 21252) += 21252) %= 21252; ans = (ans - 1 + 21252) % 21252 + 1; printf("Case %d: the next triple peak occurs in %d days.\n", ++step, ans); &#125; return 0;&#125; exCRT模板（POJ2891）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//#pragma GCC optimize("fast-math,unroll-loops")//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x)#define jh(x, y) x^=y^=x^=y#define rg register#define inl inlinetypedef __int128 ll;const int N = 1e5 + 5, mod = 1e9 + 7, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;ll mo[N], yu[N];ll exGCD(rg ll a, rg ll b, rg ll &amp;x, rg ll &amp;y)&#123; if (!b)return x = 1, y = 0, a; rg ll gcd = exGCD(b, a%b, x, y); rg ll tmpx = x; x = y; y = tmpx - a / b * y; return gcd;&#125;inl ll exCRT()&#123; rg int n = fast_IO::read(); for (rg int i = 1; i &lt;= n; ++i)mo[i] = fast_IO::read(), yu[i] = fast_IO::read(); rg ll ans = yu[1], lcm = mo[1]; for (rg int i = 2; i &lt;= n; ++i) &#123; rg ll x, y, c = (yu[i] - ans % mo[i] + mo[i]) % mo[i]; rg ll gcd = exGCD(lcm, mo[i], x, y), b = mo[i] / gcd; if (c%gcd)return -1; (x *= c / gcd) %= b; ans += lcm * x; lcm *= b; ans = (ans%lcm + lcm) % lcm; &#125; return (ans%lcm + lcm) % lcm;;&#125;int main(void)&#123; fast_IO::write(exCRT()); return 0;&#125; 六、Quadratic residue给定$y$和奇素数$p$，求$x$，使得$x^2\equiv y(mod\;p)$。 欧拉判别法若$y^{\dfrac{p-1}{2}}\equiv1(mod\;p)$，则$y$在模奇素数$p$下有二次剩余若$y^{\dfrac{p-1}{2}}\equiv-1(mod\;p)$，则$y$在模奇素数$p$下没有二次剩余勒让德符号$(\dfrac{a}{p})\equiv a^{\dfrac{p-1}{2}}$$1,…,p-1$中有$\dfrac{p-1}{2}$个数的勒让德符号为$1$，另外$\dfrac{p-1}{2}$个数的勒让德符号为$-1$。 解法不断随机$a$，使得$(\dfrac{a^2-y}{p})=-1$令$\omega=\sqrt{a^2-y},x=(a+\omega)^{\dfrac{(p+1)}{2}}$由于$x^2\equiv(a+\omega)^p\times(a+\omega)\equiv(a+\omega)\sum\limits_{j}C^j_p\omega^{p-j}$$\equiv(a^p+\omega^p)(a+\omega)\equiv(a-\omega)(a+\omega)\equiv a^2-\omega^2\equiv y(mod\;p)$所以最终答案就是$(a+\sqrt{a^2-y})^{\dfrac{p+1}{2}}$ 例题给定长度为$n$的整数$a$，判断$a$是否是完全平方数。$n\le1000$ 思路选多组素数进行判别，考虑$x^2\equiv a(mod\;p)$成立，随机一些素数$p$判别就行了。 七、Multiplicative function狄利克雷卷积$(fg)(n)=\sum_{d|n}f(d)g(n/d)$ 积性函数积性函数的性质： $\forall (a,b)=1,f(ab)=f(a)f(b)$ 积性函数的卷积仍然是积性函数 所以其实我们可以把$n$看成$n=p_1^{k_1}p_2^{k_2}…p_m^{k_m}$常见的积性函数： 普通函数:$I(n)=1,id(n)=n,e(n)=[n=1]$ 除数函数:$\sigma_k(n)=\sum\limits_{d|n}d^k$ 欧拉函数:$\phi(n)=n\times\dfrac{p_1-1}{p_1}\times…\times\dfrac{p_m-1}{p_m}$ 莫比乌斯函数:$\mu(n)=[k_1\le1][k_2\le1]…k_m\le1^m$ $\sum\limits_{d|n}\mu(d)=[n=1]\Rightarrow\mu\times1=e$$\sum\limits_{d|n}\phi(d)=n\Rightarrow\phi\times1=id$ $\phi$和$\mu$的前$n$项与前缀和前$n$项可以在做线性筛的过程中求出，前缀和用杜教筛或者min25等算法解决 Day4 下午八、Primitive root（原根）给定$n$，若$a$满足$(a,n)=1$且$1,a,a^2,a^3,…,a^{\phi(n)-1}$在$mod\;n$下都互不相同，则称$a$是$n$的一个原根。 原根的性质 $2,4,p^n,2p^n$有原根，$p$是奇素数。 若$n$有原根，则原根数量为$\phi(\phi(n))$个。 阶最小的非零$x$使得$a^x\equiv 1(mod\;p)$，记为$$ 有关阶的定理①若$p&gt;1$且$(a,p)=1$，又满足$a^n\equiv1(mod\;p)$，则$|n$②$|\phi(p)$ 求法将$\phi(p)$质因数分解，$\phi(p)=p_1^{w_1}p_2^{w_2}…p_k^{w_k}$枚举$g$，如果恒满足$g^{\dfrac{\phi(m)}{p_i}} \not =1$，其中$i=1,2,…,k$则$g$是$m$的一个原根 九、Combination（组合数）求法：杨辉三角预处理阶乘及逆元 十、Recurrence relation（递推关系）矩阵乘法：$C_{i,j}=\sum A_{i,k}\times B_{k,j}$。 例题给定一张$N$个点$M$条边的有向图，$Q$次询问图中从每个点出发的长度为$K$的路径各有多少条。$N\le100,Q\le10,K\le100$ 思路分块矩乘。 十一、Principle of inclusion-exclusion（容斥原理）容斥原理$F(A\bigcup B\bigcup C)=F(A)+F(B)+F(C)-F(A\bigcap B)-F(B\bigcap C)-F(A\bigcap C)+F(A\bigcap B\bigcap C)$ 十二、Binomial inversion(二项式反演)$f_n=\sum\limits_{i=0}^{n}(-1)^iC^i_ng_i\Leftrightarrow g_n=\sum\limits_{i=0}^{n}(-1)^iC^i_nf_i$$f_n=\sum\limits_{i=0}^{n}C^i_ng_i\Leftrightarrow g_n=\sum\limits_{i=0}^{n}(-1)^{n-i}C^i_nf_i$ 例题、集合计数$n$个元素有$2^n$种不同的子集，现从$2^n$个子集中选取若干子集，求有多少种方案，使得选出集合的交元素个数为$K$。$n,k\le 10^6$，对$10^9+7$取模 思路令$g_k$表示选出集合的集合交为$k$时的方案数，$f_k$表示选出集合的集合交至少为$k$时的方案数。$f_i=C^i_n(2^{2^{n-i}}-1)$$f_i=\sum\limits_{j=i}^{n}g_jC^i_j$ 推出$g_i=\sum\limits_{j=i}^{n}C^j_n(2^{2^{n-j}}-1)(-1)^{j-k}C^k_j$ 十三、Probability Thereom（概率论）期望：$E(x)=\sum\limits_{i=1}^{n}a_iP(x=a_i)$期望具有线性性 例题、求逆序对长度为$n$的序列，求逆序对的期望个数。令$a_{i,j}$表示$i,j$是否逆序，逆序则为1，否则为0。 例题、Clear the room给定一个$n\times m$的网格，$(i,j)$中有物品价值$w_{i,j}$。现取$K$次，每次取走一个矩形内所有物品，问$K$次操作后拿走物品价值和期望。$n,m\le500,K\le10^9$ 思路求出每一个点被选中的概率$p$，不难想到我们要想选中一个点$(x,y)$，必须要使得选中的矩形包含$(x,y)$，也就是$x_1\le x\le x_2,y_1\le y \le y_2$，那么推出结论：选中一点$(x,y)$的概率$p=\dfrac{x\times(n-x+1)\times y\times(m-y+1)}{n^2\times m^2}$，答案就等于$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}w_{i,j}p_{i,j}^k$ 十四、Gaussian（高斯消元）模板。]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day3]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day3%2F</url>
    <content type="text"><![CDATA[Day3上午——图论一、强联通分量强联通分量即是环极大强联通子图：将原图中任何点加入这个子图都不能构成强联通分量的强联通分量。极大不一定最大。强联通分量针对有向图。途中每个点都属于且仅属于一个极大强联通分量。强联通分量与点的关系具有传递性。求强联通分量可以使用Tarjan算法或者Kosaraju算法，我们主要使用Tarjan算法。 二、Tarjan算法考虑当前dfs到某个点now,其余点只有三种：①可以访问到的点②不能访问到的点③未访问的点dfs的过程中，如果从某一点出发可以回到这个点，那么一定会存在一个强联通分量，而这个强联通分量就在dfs的栈里，所以我们可以用一个栈记录一下经过的点，去找强联通分量。定义dfn[x]为搜索到x的时间，即编号，low[x]为从x出发可以走到的最小点。我们发现如果从某点出发搜完之后low[x]==dfn[x]，说明此时从x出发有一个强联通分量，此时我们把记录的栈弹出至遇到x就是一个强联通分量。 缩点缩点后，新图为一个DAG。 例题一、The Cow Prom题面见P2863。tarjan裸题。 例题二、受欢迎的牛题面见P2341。 思路首先缩点，发现如果某个点只有入度且只有这个点是只有入度的，那么这个点就是要求的点，否则不存在。 例题三、稳定婚姻题面见P1407。 思路夫妻男连女，情人女连男，跑一边tarjan，如果一对夫妻在同一个强联通分量中，这段婚姻就是不稳定的。 三、双联通分量割点和桥将点$x$删掉后，图中联通分量个数增加，称$x$为割点。将边$e$删掉后，图中联通分量个数增加，称$e$为桥。点双联通分量：两点间的所有路径不经过同一点的联通分量。边双联通分量：两点间的所有路径不经过同一边的联通分量。 割点求法类似于tarjan，如果x有一个出点low值$\ge dfn[x]$说明x是割点，注意要特殊处理第一个搜索的点。 边双联通分量求法和求强联通分量几乎一样，判断一下不走回头路就行了，不能走走过的边。扔个模板1234567891011121314151617181920212223242526272829303132333435363738394041424344...int nt[N], b[N], p[N], num = 1, st[N], dfn[N], low[N], ltk[N], id;bool flag[N];inl void add(rg int x, rg int y)&#123; b[++num] = y, nt[num] = p[x], p[x] = num; b[++num] = x, nt[num] = p[y], p[y] = num;&#125;void tarjan(rg int x)&#123; dfn[x] = low[x] = ++id; st[++*st] = x; for (rg int e = p[x]; e; e = nt[e]) if (!flag[e]) &#123; rg int k = b[e]; if (!dfn[k]) &#123; flag[e] = flag[e ^ 1] = true; tarjan(k); flag[e] = flag[e ^ 1] = false; low[x] = fast_IO::min(low[x], low[k]); &#125; else low[x] = fast_IO::min(low[x], dfn[k]); &#125; if (dfn[x] == low[x]) &#123; ++*ltk; while (st[*st + 1] != x) &#123; ltk[st[*st]] = *ltk; --*st; &#125; &#125;&#125;int main(void)&#123; ... for (rg int i = 1; i &lt;= m; ++i)add(fast_IO::read(), fast_IO::read()); for (rg int i = 1; i &lt;= n; ++i)if (!dfn[i])*ltk = 0, tarjan(i); ... return 0;&#125; 例题一、冗余路径Redundant Paths题面见P2860。 思路先求边双联通分量，缩点后成了一颗树，这棵树的度数为1的点的数量sum，答案就是⌈$sum/2$⌉，答案的正确性显然，因为每个度数为1的节点肯定需要连边出去，贪心的想就很容易证明了。 点双联通分量求法在求割点的过程中就能求出，稍微改动一下就行，我们考虑将经过的边入栈而不是经过的点，在找到割点的时候，把边一个个从栈中取出直到遇到边$(u,v)$，取出的边与其关联的点构成一个点双联通分量。由于点双联通分量求法不太一样，扔个模板吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct Node &#123; int u, v;&#125;e[N], st[N], tp;int nt[N], p[N], top, dfn[N], low[N], id, gedian[N], bcc_cnt, belong[N];vector&lt;int&gt;bcc[N];void tarjan(rg int x, rg int fa)&#123; rg int child = 0; dfn[x] = low[x] = ++id; for (rg int k = p[x]; k; k = nt[k]) &#123; rg int to = e[k].v; st[++top] = e[k]; if (!dfn[to]) &#123; ++child; tarjan(to, x); low[x] = fast_IO::min(low[x], low[to]); if (low[to] &gt;= dfn[x]) &#123; gedian[x] = true; bcc[++bcc_cnt].clear(); do &#123; tp = st[top--]; if (belong[tp.u] != bcc_cnt) &#123; bcc[bcc_cnt].push_back(tp.u); belong[tp.u] = bcc_cnt; &#125; if (belong[tp.v] != bcc_cnt) &#123; bcc[bcc_cnt].push_back(tp.v); belong[tp.v] = bcc_cnt; &#125; &#125; while (tp.u != e[k].u || tp.v != e[k].v); &#125; else if (e[k].v != fa)low[x] = fast_IO::min(low[x], dfn[to]); &#125; &#125; if (!fa) &#123; if (child &gt; 1)gedian[x] = true; else gedian[x] = false; &#125;&#125;...int main()&#123; ... for (rg int i = 1; i &lt;= n; ++i) if (!dfn[i])tarjan(i, 0); ... return 0;&#125; 四、二分图二分图的判定对二分图黑白染色，如果产生矛盾说明不是二分图。（二分图中无奇环）。 Hall定理设二分图中$G=$中$\left| V1 \right|=m\le\left| V2 \right|=n$,$G$中存在从$V1$到$V2$的完全匹配当且仅当$V1$中任意$k(k=1,2,…,m)$个顶点至少与$V2$中$k$个顶点是相邻的。 匈牙利算法贪心，过程比较简单，扔个模板12345678910111213141516171819202122232425262728vector&lt;int&gt;e[N];int mat[N];bool flag[N];bool dfs(rg int x)&#123; for (rg int i = 0; i != e[x].size(); ++i) &#123; rg int j = e[x][i]; if (flag[j])continue; flag[j] = false; if (!mat[j] || dfs(mat[j]))return mat[j] = x; &#125; return false;&#125;...int main()&#123; ... for (rg int i = 1; i &lt;= n; ++i) &#123; if (dfs(i))++ans; memset(flag, 0, sizeof(flag)); &#125; ... return 0;&#125; 几个定理二分图最小点覆盖==二分图最大匹配点覆盖：在图中选取一些点，保证每条边至少有一个点在选取点中，称这些点是一个点覆盖。二分图最大点独立集==总点数-二分图最大匹配独立集：在图中选取一些点，保证每个点不相邻，则称这些点是一个独立集。 例题一、Asteroids 小行星题面见POJ3041。 思路行列分开，对于小行星的坐标$(x,y)$，连边$(x,y)$，跑二分图匹配求最小点覆盖即是答案。 例题二、Muddy Fields 泥泞的牧场题面见POJ2226 思路和前面那道例题类似，贪心的考虑，每块板子肯定是延伸到最长最好，所以我们把一些板子分成两部分：$A$部分是所有横着的木板，$B$为所有竖着的木板，将横竖交叉的木板连边，构成一个二分图，这样选择一个点就代表选择一个板子，求最小点覆盖就是我们要求的答案。 五、2-SATSAT问题是给出一些条件（元素经过逻辑运算的结果，如and or xor），SAT问题已经被证明是一个NP完全问题。2-SAT问题中最多有两个条件。 求法对于每个变量$x$，建立两个点$x_t$和$x_f$，分别表示$x$取TRUE和$x$取FALSE。对于所有的“A取x则B取y”，连边$(A_x,B_y)$，该图中如果P能到达Q，表示“若P成立，则Q一定成立”所以如果从$a_f$出发能到达$a_t$或者$a_t$出发能到达$a_f$，则矛盾。这一步的检验我们考虑用tarjan求联通分量，$O(N)$解决。如果没有这种情况出现，则一定存在合法方案。现在我们考虑如何构造一组可行解我们构造这样一种方案：缩点之后按照“逆拓扑序”挑选一个未被染色的强联通分量将其染成黑色，然后把所有与这个强联通分量里的点矛盾的点所在的联通分量染成白色。最后所有染成黑色的强联通分量里的点就是选择的方案。 例题一、NOI2017 游戏题面见P3825 思路对于$a,b,c$，就直接裸的2-SAT。对于$x$，如果直接枚举选$A,B,C$中的哪个，复杂度要乘上$3^d$，但是如果我们考虑枚举x不适合哪辆车，复杂度就乘上$2^d$。 Day3下午一、网络流除了源点和汇点，所有点的输入与输出平衡。 求法Ford-Fulkerson算法DinicSAP等等。。。个人觉得用dinic就够了…… 二、Dinic反向边：用于反悔，保证所有操作可撤销。 优化当前弧优化 三、最小割最小割定理最小割==最大流 例题一、吃饭Dining题面见P2891。 思路把牛拆成两个点，这两个点之间连容量为1的边，原点连食物，食物连牛，牛连饮料，饮料连汇点，跑最大流。 经典最小割模型——最大闭合子图图中的点有点权，点权可正可负，在图中选一些点，如果有边$(u,v)$则选u必选v。 解法建图：对于权值为正$x$的点，从源点连一条容量为$x$的边，权值为负$y$的点，向汇点连一条容量为$y$的边，原图边容量为正无穷（较大值）。 例题二、NOI2006 最大获利题面见P4174。 思路将题目中的边都看成点边对应的点依赖于原图中的点将边转化为点，则该图转化为一个二分图求这个二分图的最大闭合子图就行了。 经典最小割模型——二分图最小点权覆盖给出一个二分图，每个点有非负点权选出一些点构成一个覆盖，求最小点权和 解法源点向左边的点连容量为点权的边，右边的点向汇点连容量为点权的边，求最小割即可。 例题三、游戏一张图，删除每个点的入边有费用$w_i+$，删除每个点的出边有费用$w_i-$，求删除所有边需要的最小费用。 思路将所有入边和出边看成点，同一条边之间连容量无穷大的边，构成一个二分图，求这个二分图的最小点权覆盖就行了。 经典最小割模型——二分图最大点权覆盖给出一个二分图，每个点有非负点权选出一些点构成一个覆盖，求最大点权和 解法点权和减去最大流。 例题四、方格取数问题题面见P2774 思路黑白染色成一个二分图，跑最小割，用全局和-最小割即可。 四、费用流图中的边不仅有容量，还有费用。最小费用最大流：流量最大的情况下费用最小最小费用流：跑最短路，如果途中发现跑某条路径会使费用变大，就停止，最大费用流同理。 例题一、晨跑题面见P2153 思路拆点限流，连边直接跑费用流出解。 经典费用流模型——连续$M$个元素最多选$K$个给定$n$个元素，每个元素有权值$a_i$（可正可负），要求从中选出一些，满足其中任意相邻$M$个元素中只有最多$K$个元素被选出。 解法把题目转换为选$K$次，每次要求选出的点距离大于$M$，建图的时候从每个点$i$向$i+M$连边，容量为1，费用为$a_i$，相邻点之间连边，费用为0容量为$INF$，源点向第一个点连边，容量为$K$费用为0，最后一个点向汇点连边，容量为$INF$费用为0，跑费用流即可。 例题二、数字配对题面见P4068。 思路设$cnt_i$表示第i个数字质因数分解后各质因数的指数和。按照cnt的奇偶性，将这些数字分为两个集合。从源点向所有$cnt_i$为奇数的点连容量为$b_i$，费用为0的边。从所有$cnt_i$为偶数的点向汇点连容量为$b_i$，费用为0的边。对于一对$a_i$和$a_j$，如果$a_i$和$a_j$能匹配且$cnt_i$为奇数，连边，容量为$INF$，费用为$c_i\times c_j$。考虑贪心，跑最大费用最大流，每次跑最长路，在价值总和不小于0的情况下尽量增加流量，如果找不到增广路或者增广下去会使费用小于0则说明找到了答案。 例题三、方格取数问题题面见P2045。 思路拆点，两点之间连两条边，第一条边费用是该点权值，流量是1，另一条边费用是0，流量是$INF$。从源点向左上角连费用为0，流量为$K$的边，右下角向汇点连边，费用为0，流量为$INF$，跑最大费用最大流。 例题四、修车题面见P2053。 思路一个工人拆成$n$个点，表示n个时间段的工人，将$n$辆车与这$m \times n$个点都连起来，容量为1，费用为工人的时间段$\times$输入的时间，源点到车费用为0，流量为1，工人到汇点费用为0，流量为1，跑最小费用最大流即可，最后答案用总时间除以车数。 例题五、费用流题面见P3305。 思路二分最大的容量，跑dinic。 例题六、小M的作物题面见P1361。 思路按题目建图，一个点拆成两个点 五、上下界网络流每条边除了流量上界，还有流量下界。 解法这里借用了这篇博客 感觉总结的非常好①无源汇有上下界可行流（循环流）模型:一个网络,求出一个流,使得每条边的流量必须$\ge L_i$且$\le H_i$,每个点必须满足总流入量$=$总流出量(流量守恒)(这个流的特点是循环往复,无始无终)。可行流算法的核心是将一个不满足流量守恒的初始流调整成满足流量守恒（所有点的流入量$=$流出量）的流。我们可以令每条边的流量为该边的下界得到一个初始流，然后建出这个流的残量网络（每条边的上界与下界之差）。考虑在残量网络上求出一个附加流，使得附加流与可行流合并之后达到流量守恒，即：1)如果某个点在所有边流量等于下界的初始流中满足流量守恒,那么这个点在附加流中也满足流量守恒,2)如果某个点在初始流中的流入量比流出量多$x$,那么这个点在附加流中的流出量比流入量多$x$.3)如果某个点在初始流中的流入量比流出量少$x$,那么这个点在附加流中的流出量比流入量少$x$.$x$可以通过枚举点$i$的所有连边求出，开一个数组$A[]$，统计$i$点的流入量-流出量大小，根据$A_i$的正负表示流入量与流出量的大小关系。我们在残量网络中加入一些点和边，首先是虚拟超级源$ss$和虚拟超级汇$tt$。如果$A_i&lt;0$，从$i$向$tt$连一条容量为$-A_i$的边，反之从$ss$向$i$连一条容量为$A_i$的边。最后在建出的图上跑最大流，如果$ss$和$tt$连接的边都是满流的说明存在可行流，每条边在可行流中的流量$=$容量下界$+$附加流中它的流量（即反向边的权值）。 ②有源汇有上下界可行流模型:现在的网络有一个源点$s$和汇点$t$,求出一个流使得源点的总流出量等于汇点的总流入量,其他的点满足流量守恒,而且每条边的流量满足上界和下界限制。从$t$向$s$连一条下界为0，上界为$INF$的边，改成无源汇上下界可行流，跑完之后拆掉这条边就得到有源汇上下界可行流。最终的流量为这条边的反向边流量。 ③有源汇有上下界最大流模型:现在的网络有一个源点$s$和汇点$t$,求出一个流使得源点的总流出量等于汇点的总流入量,其他的点满足流量守恒,而且每条边的流量满足上界和下界限制。在这些前提下要求总流量最大。先跑出可行流，再在残量网络上跑出$s-t$最大流，最终的最大流$=$可行流流量$+$新增广出的$s-t$流量。 ④有源汇有上下界最小流模型:现在的网络有一个源点$s$和汇点$t$,求出一个流使得源点的总流出量等于汇点的总流入量,其他的点满足流量守恒,而且每条边的流量满足上界和下界限制。在这些前提下要求总流量最小。还是先跑出可行流，然后再残量网络上跑出$t-s$最大流，最终的最小流$=$可行流-$t-s$的最大流。]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day2]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day2%2F</url>
    <content type="text"><![CDATA[Day2上午一、基本分治例题一、归并排序如题…基础排序之一。 二、树分治①点分治原则上要尽量减小递归层，而考虑删去当前某节点之后，剩余节点数量最多的联通块尽量少，此时递归层数一定是最小的。这个节点就是“重心”。重心可以$O(n)$DP求得 例题一、IOI2011 Race给定一颗$n$个点的带边权的树，求一条路径使得权值和为$K$且边数量最少。$1\le n \le10^5,K\le10^6$ 思路点分治，记录到根路径长为dist[i]的最小边数即可 ②边分治选择一条边删去，得到两颗不相交的子树，统计这条边的信息。选边方法与点分治的选点几乎一致。 一个优化我们发现菊花图可以轻松卡掉边分，于是我们考虑重构这颗树，使得度数最大的点度数最小，采用的策略是加虚点（个人喜欢左孩子右兄弟）关键是两点间路径经过的实边不能变。 例题二、bzoj2870题面见bzoj2870 思路采用边分治。考虑删去一条边以后这条边的两端$a,b$，考虑将a端子树和b端子树中的链按点权最小值排序，对a端来说，每条链选b端中点权最小值不小于这条链且最长的链，b端同理，如此就可以做出这道题。 ③链分治（树链剖分）略（太过于模板） 三、CDQ分治普通分治：将区间分成两部分递归求解后合并。CDQ分治：在普通分治基础上需要加上左半区间对右半区间对贡献得到答案 例题一、二维偏序（上一篇好像有一样的题） 思路首先进行双关键字排序根据CDQ分治，不断递归至区间长度为1关键在于计算贡献考虑到子区间贡已经求出，我们将两个区间按第二维进行排序，如果左区间的一个有序对$(u,v)$对右区间的一个有序对$(a,b)$产生贡献，那么就等价于$v&lt;b$，双指针扫一遍即可。又考虑到我们按b排序，显然用归并复杂度比较优秀。 四、整体二分整体二分需要满足五个性质：①询问的答案具有可二分性（单调性）②修改对询问是独立互不影响的。③不同的修改贡献可叠加，不用重复计算④贡献满足交换律、结合律，有可加性⑤题目允许离线实现起来就是将所有询问一起二分 例题一、Meteors题面见SP10264 二分答案，线段树模拟当前区间的修改 五、三分用于求解凸函数（单峰函数） 六、分块整块整体做，边角暴力做 七、莫队将询问离线排序，优化暴力过程。 八、树上莫队借助欧拉序（括号序）将树上问题转换成区间问题，其余与莫队大致相同。 九、块状链表略 Day2下午今天下午是考试，结果…T1文件名写错，T2感觉没问题莫名wa掉，T3空间开小——完美爆0（解决上述问题后拿到60分暴力分）然后发现T2逆序对求错。。。总之以后细心更重要。题目暂时就不贴了。。。打完再来发]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day1]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day1%2F</url>
    <content type="text"><![CDATA[Day1 上午——高级数据结构一、树状数组基本功能1.单点修改，前缀信息查询2.区间修改可减信息，单点查询 对lowbit的理解保留x中最后一位1（由位运算实现）1#define lowbit(x) (x&amp;-x) 例题一:矩形数点给定$n$个点坐标($x_i$,$y_i$)，q次询问，每次询问给出一个矩形的右上角坐标和左下角坐标，求矩形内包含给定点的个数n, q $\leq$ $10^5$，0 $\leq$ $x_i$, $y_i$ $\leq$ $10^9$ 思路首先用容斥原理把矩形拆型四个二维偏序区域（形如$\sum$[$x_i$ $\leq$ $x$, $y_i$ $\leq$ $y$]）将数据离散化，排序，此时$x$自然满足偏序结构，用树状数组根据$y$值维护前缀和即可 复杂度O((n+q)logn) 例题二:逆序对给定一个长度为$n$的序列，可以将其中任意个数字取相反数，求可以得到的最少逆序对数$n$ $\le$ $10^5$，$\left|A_i \right|$ $\le$ $10^9$ 思路对于每个数字，我们发现$A_i$的正负只影响绝对值比$A_i$小的数，所以求出每个数$A_i$前后分别有多少数绝对值大于$A_i$，取较少的那一个就行了 二、线段树例题一、序列操作给定长度为$n$的序列$A$，执行$q$次操作，支持区间加、区间赋值、查询区间和、查询区间最大值 思路线段树模板 例题二、环上连续最大和给定一个长度为$n$的环形序列$A$，其中$A_1$与$A_n$是相邻的。$q$次操作，每次操作更改$A_x=v$。对于每次修改输出最大连续和$n,q\le10^5,1\le x\le n,\left|A_i\right|,\left|v\right|\le10^9$ 思路线段树维护一下最小前缀和，最小后缀和与最小连续和，考虑到题目中的序列为环形，最大环形序列可能是两段互不相交的前缀与后缀，用总和减去最小子序列就行了。 例题三、SDOI2016 游戏题面见P4069 思路树链剖分+李超线段树 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;bits/stdc++.h&gt;#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 2e5 + 5;const ll INF = 123456789123456789;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg ll num = 0; rg char ch; rg bool flag = false; while ((ch = getchar()) == ' ' || ch == '\n' || ch == '\r'); if (ch == EOF)return ch; if (ch == '-')flag = true; else num = ch ^ 48; while ((ch = getchar()) != ' '&amp;&amp;ch != '\n'&amp;&amp;ch != '\r'&amp;&amp;~ch) num = (num &lt;&lt; 1) + (num &lt;&lt; 3) + (ch ^ 48); if (flag)return -num; return num; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;ll pos[N], id, ssize[N], fa[N], p[N], w[N], b[N], h[N], nt[N], num, son[N], deep[N], belong[N], dist[N];inl void add(rg ll z, rg int y, rg int x)&#123; b[++num] = y, w[num] = z; nt[num] = p[x], p[x] = num; b[++num] = x, w[num] = z; nt[num] = p[y], p[y] = num;&#125;void dfs1(rg int x)&#123; ssize[x] = 1; for (rg int e = p[x]; e; e = nt[e]) &#123; rg int k = b[e]; if (k == fa[x])continue; fa[k] = x, deep[k] = deep[x] + 1; dist[k] = dist[x] + w[e]; dfs1(k); if (ssize[son[x]] &lt; ssize[k])son[x] = k; ssize[x] += ssize[k]; &#125;&#125;void dfs2(rg int x, rg int chain_number)&#123; belong[x] = chain_number; pos[x] = ++id; h[id] = x; if (son[x])dfs2(son[x], chain_number); for (rg int e = p[x]; e; e = nt[e]) &#123; rg int k = b[e]; if (k == fa[x] || k == son[x])continue; dfs2(k, k); &#125;&#125;struct Line &#123; ll k, b; Line() &#123; k = 0, b = INF; &#125; Line(rg ll k, rg ll b) :k(k), b(b) &#123;&#125;&#125;;struct Node &#123; int left, right; ll min, l, r; Line delta; Node() &#123; min = INF; delta.b = INF; &#125;&#125;tree[N &lt;&lt; 2];void build(rg int x, rg int l, rg int r)&#123; tree[x].left = l, tree[x].right = r; if (l == r) &#123; tree[x].l = tree[x].r = dist[h[l]]; return; &#125; rg int mid = l + r &gt;&gt; 1; build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r); tree[x].l = tree[x &lt;&lt; 1].l; tree[x].r = tree[x &lt;&lt; 1 | 1].r;&#125;inl ll f(rg ll x, rg ll k, rg ll b) &#123; return k * x + b; &#125;inl void apply(rg int x, rg ll k, rg ll b)&#123; rg ll nl = f(tree[x].l, k, b), nr = f(tree[x].r, k, b), l = f(tree[x].l, tree[x].delta.k, tree[x].delta.b), r = f(tree[x].r, tree[x].delta.k, tree[x].delta.b); if (nl &lt;= l &amp;&amp; nr &lt;= r) &#123; tree[x].delta = Line(k, b); tree[x].min = fast_IO::min(tree[x].min, fast_IO::min(nl, nr)); return; &#125; if (nl &gt; l&amp;&amp;nr &gt; r)return; rg ll tmp = (b - tree[x].delta.b) / (tree[x].delta.k - k); rg ll mid = tree[x &lt;&lt; 1].r; if (nl &lt;= l || tmp &lt;= mid)apply(x &lt;&lt; 1, k, b); if (nr &lt;= r || tmp &gt; mid)apply(x &lt;&lt; 1 | 1, k, b); tree[x].min = fast_IO::min(tree[x].min, fast_IO::min(tree[x &lt;&lt; 1].min, tree[x &lt;&lt; 1 | 1].min));&#125;void addline(rg int x, rg int l, rg int r, rg ll k, rg ll b)&#123; if (tree[x].left &gt;= l &amp;&amp; tree[x].right &lt;= r) &#123; apply(x, k, b); return; &#125; rg int mid = tree[x].left + tree[x].right &gt;&gt; 1; if (l &lt;= mid)addline(x &lt;&lt; 1, l, r, k, b); if (r &gt; mid)addline(x &lt;&lt; 1 | 1, l, r, k, b); tree[x].min = fast_IO::min(tree[x].min, fast_IO::min(tree[x &lt;&lt; 1].min, tree[x &lt;&lt; 1 | 1].min));&#125;inl void addLine(rg int x, rg int y, rg ll k, rg ll b)&#123; while (belong[x] != belong[y]) &#123; if (deep[belong[x]] &lt; deep[belong[y]])jh(x, y); addline(1, pos[belong[x]], pos[x], k, b); x = fa[belong[x]]; &#125; if (pos[x] &gt; pos[y])jh(x, y); addline(1, pos[x], pos[y], k, b);&#125;inl int LCA(rg int x, rg int y)&#123; while (belong[x] != belong[y]) &#123; if (deep[belong[x]] &lt; deep[belong[y]])jh(x, y); x = fa[belong[x]]; &#125; if (deep[x] &lt; deep[y])return x; return y;&#125;inl void tian()&#123; rg int s = fast_IO::read(), t = fast_IO::read(); rg ll k = fast_IO::read(), b = fast_IO::read(); rg int lca = LCA(s, t); addLine(s, lca, -k, k*dist[s] + b); addLine(lca, t, k, k*dist[s] - 2 * k*dist[lca] + b);&#125;ll querymin(rg int x, rg int l, rg int r)&#123; rg ll ans = INF, mid = tree[x].left + tree[x].right &gt;&gt; 1; if (l &lt;= tree[x].left&amp;&amp;r &gt;= tree[x].right)return tree[x].min; if (l &lt;= mid)ans = fast_IO::min(ans, querymin(x &lt;&lt; 1, l, r)); if (r &gt; mid)ans = fast_IO::min(ans, querymin(x &lt;&lt; 1 | 1, l, r)); l = fast_IO::max(l, tree[x].left), r = fast_IO::min(r, tree[x].right); ans = fast_IO::min(ans, f(dist[h[l]], tree[x].delta.k, tree[x].delta.b)); ans = fast_IO::min(ans, f(dist[h[r]], tree[x].delta.k, tree[x].delta.b)); return ans;&#125;inl ll queryMin(rg int x, rg int y)&#123; rg ll ans = INF; while (belong[x] != belong[y]) &#123; if (deep[belong[x]] &lt; deep[belong[y]])jh(x, y); ans = fast_IO::min(ans, querymin(1, pos[belong[x]], pos[x])); x = fa[belong[x]]; &#125; if (pos[x] &gt; pos[y])jh(x, y); return fast_IO::min(ans, querymin(1, pos[x], pos[y]));&#125;inl ll query()&#123; rg int s = fast_IO::read(), t = fast_IO::read(); return queryMin(s, t);&#125;int main(void)&#123; rg int n = fast_IO::read(), m = fast_IO::read(); for (rg int i = 1; i != n; ++i)add(fast_IO::read(), fast_IO::read(), fast_IO::read()); dfs1(1), dfs2(1, 1), build(1, 1, n); while (m--) switch (fast_IO::read()) &#123; case 1:tian(); break; case 2:printf("%lld\n", query()); break; &#125; return 0;&#125; 三、可并堆（左偏树）左偏树呈二叉树结构，除维护权值信息外，还需要维护子树内最近叶结点的距离$d_x$。 例题一、Dispatching题面见P1552。 思路考虑到如果某个忍者当管理员时不选$x$忍者，那么这个忍者的直接上级一定不会选$x$。使用左偏树维护以$x$为根子树内派遣忍者名单，它需要满足大根堆的性质，不断删除堆顶直到总和$\le m$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e5 + 5;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg ll num = 0; rg char ch; rg bool flag = false; while ((ch = getchar()) == ' ' || ch == '\n' || ch == '\r'); if (ch == EOF)return ch; if (ch == '-')flag = true; else num = ch ^ 48; while ((ch = getchar()) != ' '&amp;&amp;ch != '\n'&amp;&amp;ch != '\r'&amp;&amp;~ch) num = (num &lt;&lt; 1) + (num &lt;&lt; 3) + (ch ^ 48); if (flag)return -num; return num; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;int fa[N], n, lson[N], rson[N], d[N], root[N], ssize[N];ll c[N], m, l[N], sum[N], ans;int merge(rg int x, rg int y)&#123; if (!x || !y)return x | y; if (c[x] &lt; c[y])jh(x, y); rson[x] = merge(rson[x], y); if (d[lson[x]] &lt; d[rson[x]])jh(lson[x], rson[x]); d[x] = d[rson[x]] + 1; return x;&#125;int main(void)&#123; n = fast_IO::read(), m = fast_IO::read(); for (rg int i = 1; i &lt;= n; ++i) fa[i] = fast_IO::read(), sum[i] = c[i] = fast_IO::read(), l[i] = fast_IO::read(), root[i] = i, ssize[i] = 1, ans = fast_IO::max(ans, l[i]); for (rg int i = n; i != 1; --i) &#123; root[fa[i]] = merge(root[i], root[fa[i]]); sum[fa[i]] += sum[i]; ssize[fa[i]] += ssize[i]; while (sum[fa[i]] &gt; m) &#123; sum[fa[i]] -= c[root[fa[i]]]; root[fa[i]] = merge(lson[root[fa[i]]], rson[root[fa[i]]]); --ssize[fa[i]]; &#125; ans = fast_IO::max(ans, l[fa[i]] * ssize[fa[i]]); &#125; fast_IO::write(ans); return 0;&#125; 线段树的合并线段树要合并，必须要有相同的结构，均摊复杂度$O(log n)$。 四、平衡树Treap——Treep=Tree+HeapTreap通过单旋保持堆性质。树高期望$O(logn)$ 启发式合并合并两棵$Treap$的时候，只需要暴力遍历较小的 Treap 提取所有结点，然后依次插入到较大的$Treap$之中就好了。很多数据结构都可以用启发式合并 例题一、Peaks题面见P4197 思路将道路和询问混在一起排序，进行$Kruskal$算法的同时用$Treap $维护连通分量内所有山峰的高度。 SplaySplay借助双旋操作（zig_zag）。 例题二、序列终结者题面见P4146。 思路Splay维护翻转、子树最值、addv标记。 例题三、三维偏序思路线段树套平衡树 Day1 下午五、嵌套数据结构嵌套数据结构的思想是将普通的数据结构维护的信息拓展成另一种数据结构（可能与第一维数据结构相同） 树套树常见的有树状数组套平衡树，线段树套权值线段树等。注意，第一维的数据结构应该尽量简单，可以节约空间减小时间复杂度。 例题一、Mokia题面见P4390。 思路树状数组套Splay 六、可持久化线段树（主席树）可持久化数据结构可持久化数据结构就是利用函数式编程的思想使其支持询问历史版本，同时充分利用它们之间的共同数据来减少时间和空间消耗 大致的思想就是只新建不修改，保存历史版本 例题一、静态区间第k小题面见P3834。 思路主席树模板题 七、动态树（Link-Cut-Tree）不是很懂。。。弄明白以后再补 总结数据结构是很重要的基础。讲课好快…今天的例题只敲出来两个，其他的还得以后慢慢做]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2019%2F04%2F11%2Fhello%2F</url>
    <content type="text"><![CDATA[我的第一篇blogLaTeX测试$\sum\limits_{i=1}^{n}a_b^c$ 理综答题卡模板 答题卡物理选择题 题号 14 15 16 17 18 19 20 21 答案 非选择题22.23.24.25.33.化学选择题 题号 7 8 9 10 11 12 13 答案 非选择题26.27.28.36.生物选择题 题号 1 2 3 4 5 6 答案 非选择题29.30.31.32.37.数学答题卡模板选择题 题号 1 2 3 4 5 6 7 8 9 10 11 12 答案 填空题13.14.15.16. 解答题17.18.19.20.21.22.]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
