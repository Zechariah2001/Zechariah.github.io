<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[后缀自动机]]></title>
    <url>%2F2022%2F07%2F14%2F%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%E2%80%9C%2F</url>
    <content type="text"><![CDATA[定义$S$的后缀自动机是一种能识别所有$S$的子串的自动机类型的数据结构。$s(w)$表示字串$w$对应的后缀自动机上的状态。$tran(s,ch)$表示当前状态是$s$，接收新字符$ch$之后到达的状态。$Trans(s,str)$表示当前状态是$s$，接收新字符串$str$之后到达的状态。$Suf[i]$表示从$i$位置开始的后缀，即$S[i,\left|S\right|]$。$Right(s)=\{r_1,r_2,…,r_m\}$表示$s$状态代表子串出现位置右端点集合。$SC$树（也称后缀链接树、Parent树、link树等）即为$Right$集合包含关系形成的树。$f(s)$表示状态$s$对应的$Right(s)$在$SC$树上的父节点。 最简状态后缀自动机最优后缀自动机的状态数为$O(2n)$，转移数为$O(3n)$。后缀自动机中，一个状态表示的是出现位置相同（右端点相同），但长度不同的一系列串。不同的$Right$集合之间只有相离和真包含关系，形成一个树形结构，叶子节点是只有一个位置的集合，因此总共有$n$个节点，整棵树的节点数（状态数）就是$O(2n)$。显然对于任意状态$s$，$MaxL[f(s)]=MinL[s]-1$，因此每个节点只需要记录$MaxL[s]$和$f(s)$，状态$s$能表示的串长度范围是$(MaxL[f(s)],MaxL[s]]$。将每条非树边（转移）映射到后缀上，每个后缀最多只会被一条非树边映射到，因此转移的数量是$O(3n)$。 构造考虑在线增量构造，首先创建一个根节点$root$，标号为$1$，$MaxL[1]=0$，$f(1)=0$。然后在已经建出$S[1,i-1]$的后缀自动机的基础上加上$S[i]$建出$S[1,i]$的后缀自动机。显然新增的$i$个子串是$S[1,i]$的所有后缀，首先$S[1,i]$肯定不在SAM里，需要新建一个状态$np$。新状态有$trans$为空，$MaxL[np]=i$。要找到$f(np)$，就要找到最长的$S[i-x+1,i]$，要求在$S[1,i-1]$中出现过。由于$S[i-x+1,i]=S[i-x+1,i-1]+S[i]$，因此要找到$S[1,i-1]$的最长后缀，使得其所在的状态存在$S[i]$的转移。这一过程需要枚举$S[1,i-1]$的所有后缀，即从$S[1,i-1]$所在的状态$p$开始向上遍历到$root$来实现。如果没有任何状态有$S[i]$转移，则$f(np)=root$。]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树与图计数]]></title>
    <url>%2F2022%2F04%2F28%2F%E6%A0%91%E4%B8%8E%E5%9B%BE%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Prufer序列Prufer序列是有标号无根树的一种映射。$n$个节点的有标号无根树可以与一个长度为$n-2$的Prufer序列唯一对应。 从树到Prufer序列的转换： 设$f$为空序列 如果当前树上多于两个节点，假设当前标号最小的叶子节点为$x$，与$x$相连的节点标号为$y$，将$x$从树上删掉，将$y$加入$f$末端 重复2.直到树上只有两个节点 从Prufer序列到树的转换： 找到当前不在$f$中且还没使用过的最小的元素$x$ $x$与当前$f$的第一个元素连边，把$x$标记为已使用过 删除$f$的第一个元素，如果$f$非空，重复1. 最终有两个元素没有使用过，将他们连边 Prufer序列长度为$n-2$，每个元素的取值范围是$[1,n]$。这种唯一对应的关系说明$n$个点的有标号无根树一共有$n^{n-2}$种。]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速沃尔什变换]]></title>
    <url>%2F2022%2F02%2F17%2F%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[集合幂级数给每个$S\in 2^A$赋予一个权值$w(S)$，则定义它关联的集合幂级数为 f(x)=\sum_{S\in 2^A}w(S)x^{id(S)}与、或、异或卷积定义两个形式幂级数$f(x)=\sum\limits_{i=0}^{2^n-1}a_ix^i,g(x)=\sum\limits_{i=0}^{2^n-1}b_ix^i$的积为$h(x)=\sum\limits_{i=0}^{2^n-1}c_ix^i$，其中$c_k=\sum_{i\otimes j=k}a_ib_j$，$\otimes$可以为$\&amp;,|,\oplus$中的一种，分别称为对应的积为与、或、异或卷积。 快速沃尔什变换（FMT/FWT）与卷积求解$C_k=\sum\limits_{i\&amp;j=k}A_iB_j$考虑找到一种操作$\mathcal{F}(A)$，使得其满足如下条件： $\mathcal{F}(A)$存在逆变换$\mathcal{F}^{-1}(\mathcal{F}(A))=A$ $\mathcal{F}(A)_i\times \mathcal{F}(B)_i=\mathcal{F}(C)_i$ $\mathcal{F}(A+B)=\mathcal{F}(A)+\mathcal{F}(B)$ 将$A,B,C$分成$[0,2^{n-1}-1],[2^{n-1},2^n-1]$两部分，分别记作$A_0,A_1,B_0,B_1,C_0,C_1$。很明显有 \mathcal{F}(C_0)=\mathcal{F}(A_0)\times \mathcal{F}(B_0)+\mathcal{F}(A_0)\times \mathcal{F}(B_1)+\mathcal{F}(A_1)\times \mathcal{F}(B_0)\\ \mathcal{F}(C_1)=\mathcal{F}(A_1)\times \mathcal{F}(B_1)这里$\times$表示每一位相乘，进一步化简得 (\mathcal{F}(C_0)+\mathcal{F}(C_1))=(\mathcal{F}(A_0)+\mathcal{F}(A_1))\times(\mathcal{F}(B_0)+\mathcal{F}(B_1))\\ \mathcal{F}(C_1)=\mathcal{F}(A_1)\times \mathcal{F}(B_1)所以$\mathcal{F}$操作可以为 \mathcal{F}(C)=(\mathcal{F}(C_0)+\mathcal{F}(C_1),\mathcal{F}(C_1))\\ \mathcal{F}^{-1}(C)=(\mathcal{F}^{-1}(C_0)-\mathcal{F}^{-1}(C_1),\mathcal{F}^{-1}(C_1))正逆变换复杂度都是$O(n2^n)$。 或卷积求解$C_k=\sum\limits_{i|j-k}A_iB_j$和$\&amp;$卷积相同的思路，需要满足 \mathcal{F}(C_0)=\mathcal{F}(A_0)\times \mathcal{F}(B_0)\\ (\mathcal{F}(C_0)+\mathcal{F}(C_1))=(\mathcal{F}(A_0)+\mathcal{F}(A_1))\times(\mathcal{F}(B_0)+\mathcal{F}(B_1))得到的$\mathcal{F}$操作为 \mathcal{F}(C)=(\mathcal{F}(C_0), \mathcal{F}(C_1)+\mathcal{F}(C_0))\\ \mathcal{F}^{-1}(C)=(\mathcal{F}^{-1}(C_0),\mathcal{F}^{-1}(C_1)-\mathcal{F}^{-1}(C_0))异或卷积求解$C_k=\sum\limits_{i\oplus j=k}A_iB_j$和$\&amp;$卷积相同的思路，需要满足 \mathcal{F}(C_0)=\mathcal{F}(A_0)\times \mathcal{F}(B_0)+\mathcal{F}(A_1)\times \mathcal{F}(B_1)\\ \mathcal{F}(C_1)=\mathcal{F}(A_0)\times \mathcal{F}(B_1)+\mathcal{F}(A_1)\times \mathcal{F}(B_0)即 (\mathcal{F}(C_0)+\mathcal{F}(C_1))=(\mathcal{F}(A_0)+\mathcal{F}(A_1))\times(\mathcal{F}(B_0)+\mathcal{F}(B_1))\\ (\mathcal{F}(C_0)-\mathcal{F}(C_1))=(\mathcal{F}(A_0)-\mathcal{F}(A_1))\times(\mathcal{F}(B_0)-\mathcal{F}(B_1))得到的$\mathcal{F}$操作为 \mathcal{F}(C)=(\mathcal{F}(C_0)+\mathcal{F}(C_1),\mathcal{F}(C_0)-\mathcal{F}(C_1))\\ \mathcal{F}^{-1}(C)=\dfrac{1}{2}(\mathcal{F}^{-1}(C_0)+\mathcal{F}^{-1}(C_1),\mathcal{F}^{-1}(C_0)-\mathcal{F}^{-1}(C_1))总结找到一种关于集合幂级数的可逆变换$\mathcal{F}$，使得$h(x)=f(x)g(x)$满足$[x^i]\mathcal{F}(h(x))=[x^i]\mathcal{F}(f(x))\cdot[x^i]\mathcal{F}(g(x))\;(0\le i&lt;2^n)$ 假设$f(x)=f_0(x)+x^{2^{n-1}}f_1(x)$，则$\mathcal{F}$为： 与卷积：$\mathcal{F}(f)=(\mathcal{F}(f_0)+\mathcal{F}(f_1))+x^{2^{n-1}}\mathcal{F}(f_1)$ 或卷积：$\mathcal{F}(f)=\mathcal{F}(f_0)+x^{2^{n-1}}(\mathcal{F}(f_0)+\mathcal{F}(f_1))$ 异或卷积：$\mathcal{F}(f)=(\mathcal{F}(f_0)+\mathcal{F}(f_1))+x^{2^{n-1]}}(\mathcal{F}(f_0)-\mathcal{F}(f_1))$ 它们的逆运算： 与卷积：$\mathcal{F}^{-1}(f)=(\mathcal{F}^{-1}(f_0)-\mathcal{F}^{-1}(f_1))+x^{2^{n-1}}\mathcal{F}(f_1)$ 或卷积：$\mathcal{F}^{-1}(f)=\mathcal{F}^{-1}(f_0)+x^{2^{n-1}}(\mathcal{F}^{-1}(f_1)-\mathcal{F}^{-1}(f_0))$ 异或卷积：$\mathcal{F}^{-1}(f)=\dfrac{1}{2}((\mathcal{F}^{-1}(f_0)+\mathcal{F}^{-1}(f_1))+x^{2^{n-1}}(\mathcal{F}^{-1}(f_0)-\mathcal{F}^{-1}(f_1)))$ 12345678910111213141516171819202122232425262728293031323334353637template &lt;class T&gt;void Or_FWT(T f[], int n, int opt) &#123;//opt=1为正变换 for (int len = 2, mid = 1; len &lt;= n; len &lt;&lt;= 1, mid &lt;&lt;= 1) &#123; for (int i = 0; i &lt; n; i += len) &#123; for (int j = 0; j &lt; mid; ++j) &#123; if (opt == 1)f[i + j + mid] = ADD(f[i + j + mid], f[i + j]); else f[i + j + mid] = DEL(f[i + j + mid], f[i + j]); &#125; &#125; &#125;&#125;template &lt;class T&gt;void And_FWT(T f[], int n, int opt) &#123; for (int len = 2, mid = 1; len &lt;= n; len &lt;&lt;= 1, mid &lt;&lt;= 1) &#123; for (int i = 0; i &lt; n; i += len) &#123; for (int j = 0; j &lt; mid; ++j) &#123; if (opt == 1)f[i + j] = ADD(f[i + j], f[i + j + mid]); else f[i + j] = DEL(f[i + j], f[i + j + mid]); &#125; &#125; &#125;&#125;template &lt;class T&gt;void Xor_FWT(T f[], int n, int opt) &#123; for (int len = 2, mid = 1; len &lt;= n; len &lt;&lt;= 1, mid &lt;&lt;= 1) &#123; for (int i = 0; i &lt; n; i += len) &#123; for (int j = 0; j &lt; mid; ++j) &#123; f[i + j] = ADD(f[i + j], f[i + j + mid]); f[i + j + mid] = DEL(f[i + j], ADD(f[i + j + mid], f[i + j + mid])); if (opt != 1) &#123; (f[i + j] *= mod + 1 &gt;&gt; 1) %= mod; (f[i + j + mid] *= mod + 1 &gt;&gt; 1) %= mod; &#125; &#125; &#125; &#125;&#125; 分治FWT分治FWT可以每次直接算两个子区间的异或卷积然后再直接卷起来，$O(n\log^2 n)$进行，但实际上可以做到$O(n\log n)$。实际上，可以通过$2^{L-1}$长度的FWT计算$2^{L}$长度的FWT，且复杂度为$O(2^L)$。以异或卷积为例，$n$个集合幂级数的异或卷积需要考虑取的数的个数是奇数还是偶数，同时也需要考虑高位和低位，记为$p_{0/1},q_{0/1}$，$p,q$表示低、高位，$0/1$表示取的数个数的奇偶。 C=(p_0*q_0+p_1*q_0)+x^{2^{L-1}}(p_0*q_1+p_1*q_1)考虑将异或卷积的FWT计算过程看成矩阵变换，设变换矩阵 M_0= \begin{pmatrix} 1 \end{pmatrix}\\ M_i= \begin{pmatrix} M_{i-1}&M_{i-1}\\ M_{i-1}&-M_{i-1} \end{pmatrix}现在已知$\mathcal{F}(p_0),\mathcal{F}(p_1),\mathcal{F}(q_0),\mathcal{F}(q_1)$，要求$\mathcal{F}(C)$。根据$\mathcal{F}$的线性性，可以将每一项卷积的FWT分开计算再合并。考虑式子中每一项卷积构成的列向量分别为 \begin{pmatrix} p_0*q_0\\ 0 \end{pmatrix} 与 \begin{pmatrix} p_1*q_0\\ 0 \end{pmatrix} 与 \begin{pmatrix} 0\\ p_0*q_1 \end{pmatrix} 与 \begin{pmatrix} 0\\ p_1*q_1 \end{pmatrix}将其分别与变换矩阵相乘，就得到 \begin{pmatrix} \mathcal{F}(p_0)\times\mathcal{F}(q_0)\\ \mathcal{F}(p_0)\times\mathcal{F}(q_0) \end{pmatrix} 与 \begin{pmatrix} \mathcal{F}(p_1)\times\mathcal{F}(q_0)\\ \mathcal{F}(p_1)\times\mathcal{F}(q_0) \end{pmatrix} 与 \begin{pmatrix} \mathcal{F}(p_0)\times\mathcal{F}(q_1)\\ -\mathcal{F}(p_0)\times\mathcal{F}(q_1) \end{pmatrix} 与 \begin{pmatrix} \mathcal{F}(p_1)\times\mathcal{F}(q_1)\\ -\mathcal{F}(p_1)\times\mathcal{F}(q_1) \end{pmatrix}因此就有 \mathcal{F}(C_0)=(\mathcal{F}(p_0)\times\mathcal{F}(q_0)+\mathcal{F}(p_1)\times\mathcal{F}(q_1))+x^{2^{L-1}}(\mathcal{F}(p_0)\times\mathcal{F}(q_0)-\mathcal{F}(p_1)\times\mathcal{F}(q_1))\\ \mathcal{F}(C_1)=(\mathcal{F}(p_1)\times\mathcal{F}(q_0)+\mathcal{F}(p_0)\times\mathcal{F}(q_1))+x^{2^{L-1}}(\mathcal{F}(p_1)\times\mathcal{F}(q_0)-\mathcal{F}(p_0)\times\mathcal{F}(q_1))最后将$\mathcal{F}(C_0)$和$\mathcal{F}(C_1)$用IFWT还原即可。 子集卷积（FST）设集合幂级数$f(x)=\sum\limits_{i=0}^{2^{n-1}}a_ix^i,g(x)=\sum\limits_{i=0}^{2^{n-1}}b_ix^i$，定义卷积$h(x)=f(x)g(x)$，其中$h(x)=\sum\limits_{i=0}^{2^n}c_ix^i$满足 c_k=\sum\limits_{i|j=k,i\&j=0}a_ib_j将$f(x)$扩展为二元多项式$f(x,y)=\sum\limits_{i=0}^{2^n-1}a_ix^iy^{\text{cnt}(i)}=\sum\limits_{i=0}^{2^n-1}\sum\limits_{j=0}^{n}a_{i,j}x^iy^j$，则以上表达式改写为$h(x)=\sum\limits_{i=0}^{2^n-1}\sum\limits_{j=0}^nc_{i,j}x^iy^j$，其中 c_{i,j}=\sum\limits_{u|v=i,p+q=j}a_{u,p}b_{v,q}=\sum\limits_{p+q=j}\sum\limits_{u|v=i}a_{u,p}b_{v,q}123456789101112131415161718192021template &lt;class T&gt;void FST(T ans[], T a[], T b[], int m, int n) &#123; //结果的幂次在2^m内 for (int i = 0; i &lt; n; ++i)f[cnt[i]][i] = a[i]; for (int i = 0; i &lt; n; ++i)g[cnt[i]][i] = b[i]; for (int i = 0; i &lt; m; ++i) &#123; Or_FWT(f[i], n, 1); Or_FWT(g[i], n, 1); &#125; for (int i = 0; i &lt;= m; ++i) &#123; for (int j = 0; i + j &lt;= m; ++j) &#123; for (int k = 0; k &lt; n; ++k) &#123; h[i + j][k] = ADD(h[i + j][k], f[i][k] * g[j][k] % mod); &#125; &#125; &#125; for (int i = 0; i &lt; m; ++i) Or_FWT(h[i], n, -1); for (int i = 0; i &lt; n; ++i) ans[i] = h[cnt[i]][i];&#125;]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>幂级数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斯特林数]]></title>
    <url>%2F2022%2F02%2F07%2F%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%2F</url>
    <content type="text"><![CDATA[第一类斯特林数第一类斯特林数为有$k$个轮换的$n$元置换的方案数，表示为$\begin{bmatrix}n\\m\end{bmatrix}$或$c(n,m)$。递推公式 \begin{bmatrix}n\\k\end{bmatrix}=(n-1)\times\begin{bmatrix}n-1\\k\end{bmatrix}+\begin{bmatrix}n-1\\k-1\end{bmatrix}重要公式 x^{\overline{n}}=\sum\limits_{k=0}^n\begin{bmatrix}n\\k\end{bmatrix}x^k有符号第一类斯特林数：$S_1(n,k)=(-1)^{n+k}\begin{bmatrix}n\\k\end{bmatrix}$满足 x^{\underline{n}}=\sum\limits_{k=0}^nS_1(n,k)x^k关于$n$的指数生成函数 \sum_{n\ge0}S_1(n,k)\dfrac{x^n}{n!}=\dfrac{1}{k!}(\ln(1+x))^k\\ \sum_{n\ge0}\begin{bmatrix}n\\k\end{bmatrix}\dfrac{x^n}{n!}=\dfrac{1}{k!}(-\ln(1-x))^k快速计算一行可以利用重要公式进行计算，显然我们只需要求$x^{\overline{n}}$，观察$\prod\limits_{i=L}^{R}(x+i)$，其中$R-L+1$为偶数，显然可以将其分成两个长度相同的部分，设左半部分为$f(x)=\sum_{n\ge0}a_nx^n$则右半部分为$f(x+d),d=\dfrac{R-L+1}{2}$，则有 f(x+d)=\sum_{n\ge0}a_n(x+d)^n=\sum_{i\ge0}\sum_{n\ge i}a_n\begin{pmatrix}n\\i\end{pmatrix}d^{n-i}x^i=\sum_{i\ge0}\dfrac{1}{i!}\sum_{n\ge i}n!a_n\dfrac{d^{n-i}}{(n-i)!}x^i设$A_n=n!a_nx^n,B_n=\dfrac{d^{n}}{n!}x^{-n}$，则有 \sum_{n\ge i}a_n\begin{pmatrix}n\\i\end{pmatrix}d^{n-i}x^i=\sum_{n\ge i}A_n\times B_{n-i}很明显的卷积形式，直接FFT/NTT/MTT求解即可。 快速计算一列直接用指数生成函数解决。 第二类斯特林数第二类斯特林数为将$n$个有标号的球分配到$k$个无标号的盒子的方案数，记为$S_2(n,k)$或$\begin{Bmatrix}n\\m\end{Bmatrix}$。递推公式 \begin{Bmatrix}n\\k\end{Bmatrix}=\begin{Bmatrix}n-1\\k-1\end{Bmatrix}+k\times\begin{Bmatrix}n-1\\k\end{Bmatrix}通项公式（容斥） \begin{Bmatrix}n\\k\end{Bmatrix}=\dfrac{1}{k!}\sum\limits_{i=0}^k(-1)^i\begin{pmatrix}k\\i\end{pmatrix}(k-i)^n重要公式 x^n=\sum\limits_{k=0}^n\begin{Bmatrix}n\\k\end{Bmatrix}x^{\underline{k}}关于$n$的指数生成函数 \sum_{n\ge0}\begin{Bmatrix}n\\k\end{Bmatrix}\dfrac{x^n}{n!}=\dfrac{1}{k!}(\exp(x)-1)^k快速计算一行可以利用通项公式计算，式子化为 \begin{Bmatrix}n\\k\end{Bmatrix}=\sum\limits_{i=0}^k\dfrac{(-1)^i}{i!}\dfrac{(k-i)^n }{(k-i)!}=\sum\limits_{i=0}^kA_iB_{k-i}明显的卷积形式，用FFT/NTT/MTT求解。 快速计算一列可以利用生成函数计算，直接求多项式快速幂即可。 斯特林反演两类斯特林数之间的联系： x^n=\sum\limits_{k=0}^nS_2(n,k)x^{\underline{k}}即\begin{pmatrix}x^0\\x^1\\x^2\\...\end{pmatrix}=\begin{pmatrix}S_2(0,0)\\S_2(1,0)&S_2(1,1)\\S_2(2,0)&S_2(2,1)&S_2(2,2)\\...&...&...&...\end{pmatrix}\begin{pmatrix}x^{\underline 0}\\x^{\underline 1}\\x^{\underline 2}\\...\end{pmatrix}\\ x^{\underline{n}}=\sum\limits_{k=0}^nS_1(n,k)x^k即\begin{pmatrix}x^{\underline 0}\\x^{\underline 1}\\x^{\underline 2}\\...\end{pmatrix}=\begin{pmatrix}S_1(0,0)\\S_1(1,0)&S_1(1,1)\\S_1(2,0)&S_1(2,1)&S_1(2,2)\\...&...&...&...\end{pmatrix}\begin{pmatrix}x^0\\x^1\\x^2\\...\end{pmatrix}\\ \sum_{k\ge0}S_2(n,k)S_1(k,m)=[n=m]即S_1\times S_2=S_2\times S_1=I斯特林反演：如果数列$f,g$满足$f_n=\sum\limits_{i=0}^nS_2(n,i)g_i$，则$g_n=\sum\limits_{i=0}^nS_1(n,i)f_i$，反之也成立。 整数分拆将$n$个无标号的球分配到$k$个无标号的盒子中的方案数，记为$p(n,k)$。递推公式 p(n,k)=p(n-1,k-1)+p(n-k,k)关于$n$的常生成函数 \sum_{n\ge 0}p(n,k)x^n=\prod\limits_{i=1}^k\dfrac{1}{1-x^i}-\prod\limits_{i=1}^{k-1}\dfrac{1}{1-x^i}=x^k\prod\limits_{i=1}^k\dfrac{1}{1-x^i}根据常生成函数，可以快速计算$k$相同的$p(n,k)$，对上面的式子取$\ln$，得到 \ln\prod\limits_{i=1}^k\dfrac{1}{1-x^i}=\sum\limits_{i=1}^k-\ln(1-x^i)=\sum\limits_{i=1}^k\sum\limits_{j\ge0}\dfrac{x^{i\cdot j}}{j}将上式取$\exp$再乘上$x^k$就得到了他的形式幂级数。 将$n$个无标号的球分配到一些无标号盒子的方案数记为$p(n)$。显然有 p(n)=\sum\limits_{k=1}^{n}p(n,k)递推公式 p(n)=\sum_{k\ge1}(-1)^{k-1}(p(n-\dfrac{3k^2-k}{2})+p(n-\dfrac{3k^2+k}{2}))常生成函数 \sum_{n\ge0}p(n)x^n=\prod_{i\ge1}\dfrac{1}{1-x^i}同样可以通过先取$\ln$再用$\exp$还原的方法$O(n\log n)$计算，利用递推式直接计算是$O(n\sqrt{n})$的。]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10下UEFI环境安装Ubuntu]]></title>
    <url>%2F2022%2F01%2F28%2FWindows10%E4%B8%8BUEFI%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85Ubuntu%2F</url>
    <content type="text"><![CDATA[Windows10下UEFI环境安装Ubuntu这几天突然想在移动硬盘上装个Ubuntu，在网上找了一些教程之后直接动手尝试了一下，走了不少弯路。 安装环境概述我平时用的笔记本是拯救者R7000，移动硬盘是Seagate的1T固态移动硬盘，待安装的Ubuntu版本为20.04.3，用于制作系统盘的U盘容量大概7GB（实际上大于2GB就行了）。已安装的Win10系统在Legacy模式下无法引导启动。 安装流程网上的大多数教程都是用Legacy模式安装的，然而我尝试了一下，用Legacy模式启动的时候根本进不去Win10，一番折腾之后就放弃了。最后选择了在UEFI模式下安装。 首先需要准备一个足够大的U盘（2GB以上），下载Ubuntu的镜像（ISO）文件并用软碟通（UltraISO）制作系统盘。然后在移动硬盘上分出一个足够大的空间，我分了80GB。 重启计算机，在画面还没出来的时候按Fn+F12选择启动盘，然后选择从刚才制作的系统盘启动。 启动以后就进入安装界面了，这个都是大同小异，重点在于后面的分区，一定要分一个EFI区，/boot不用分，这是与Legacy模式安装流程最大的不同。分好区以后就继续设置、安装。 实际上到这里Ubuntu就已经算安装好了，但是再次启动电脑的时候可能会出现一些问题，比如我就碰到了系统设置移动硬盘为最优先的启动盘，结果导致卡在grub界面进不去的情况。这个时候我们就只能手动引导启动Win10了，在grub命令行界面输入ls查看目录，出现了一些形如(hd,gpt)这样的字符串，这个表示的就是哪个硬盘的哪个分区，我们挨个去找，直到找到系统盘，比如我的系统盘就是(hd0,gpt1)，系统盘里面就有Win10的引导文件，一般路径为1(hd0,gpt1)/efi/Microsoft/Boot/bootmgfw.efi 接下来只要输入指令12gurb&gt; chainloader (hd0,gpt1)/efi/Microsoft/Boot/bootmgfw.efigurb&gt; boot 就可以成功进入Win10系统了。]]></content>
      <categories>
        <category>实用技巧</category>
      </categories>
      <tags>
        <tag>系统安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成函数]]></title>
    <url>%2F2022%2F01%2F10%2F%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[生成函数常生成函数 A(x)=\sum\limits_{n\ge0}a_nx^n设$S=\{a_1,a_2,…,a_k\}$，且$a_i$可以取的次数集合为$M_i$，记$F_i(x)=\sum\limits_{u\in M_i}x^u$，则从$S$中取$n$个元素组成集合的方案数$g(n)$的常生成函数$G(x)=\sum\limits_{i\ge 0}g(i)x^i$满足 G(x)=\prod\limits_{i=1}^kF_i(x)形式幂级数$A(x)$的逆元：$A(x)B(x)=1$逆元存在的条件：$[x^0]A(x)\not=0$常见的逆 A(x)=\sum\limits_{i\ge0}x^i=(1-x)^{-1}\\ A(x)=\sum\limits_{i\ge0}a^ix^i=(1-ax)^{-1}\\ A(x)=\sum\limits_{i\ge0}\begin{pmatrix}i+k-1\\i\end{pmatrix}x^i=[(1-x)^k]^{-1}指数生成函数 A(x)=\sum\limits_{n\ge 0}a_n\dfrac{x^n}{n!}设$S=\{a_1,a_2,…,a_k\}$，且$a_i$可以取的次数集合为$M_i$，记$F_i=\sum\limits_{u\in M_i}\dfrac{x^u}{u!}$，则从$S$中取$n$个元素排成一列的方案数$g(n)$的指数生成函数$G(x)=\sum\limits_{i\ge 0}g(i)\dfrac{x^i}{i!}$，满足 G(x)=\prod\limits_{i=1}^kF_i(x)公式： \exp(x)=\sum\limits_{i\ge0}\dfrac{x^i}{i!}\\ \exp(ax)=\sum\limits_{i\ge0}a^i\dfrac{x^i}{i!}\\ \ln(1+x)=\sum\limits_{i\ge1}(-1)^{i+1}\dfrac{x^n}{i}]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[积性函数]]></title>
    <url>%2F2022%2F01%2F06%2F%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[积性函数若函数$f:N\to R$，满足对于任意一对互质的正整数$p,q(\gcd(p,q)=1)$，都有$f(pq)=f(p)f(q)$，则称$f$为积性函数。根据积性函数的定义，$f(x)$可以表示成下面的形式 f(p_1^{k_1}p_2^{k_2}p_3^{k_3}...p_{n}^{k_n})=f(p_1^{k_1})f(p_2^{k_2})f(p_3^{k_3})...f(p_{n}^{k_n})积性函数的求法：欧拉筛。1234567891011121314151617181920void Euler(int n) &#123; f[1] = 1; //calc_f(x, p)快速计算，f(x^p) for (int i = 2; i &lt;= n; ++i) &#123; if (!flag[i])prime[++*prime] = i, f[i] = calc_f(i, 1); for (int j = 1; j &lt;= *prime; ++j) &#123; int to = i * prime[j]; if (to &gt; n)break; flag[to] = true; if (i % prime[j] == 0) &#123; cnt[to] = cnt[i] + 1;//prime[j]是i最小的素因子，此时i已经有prime[j]因子，所以这里需要将素因子为prime[j]的这一项去掉，把次数+1乘回来 f[to] = f[i] / calc_f(prime[j], cnt[i]) * calc_f(prime[j], cnt[to]); break; &#125; //如果prime[j]不是i的素因子，也就是说to相比i增加了一个素因子，所以直接乘上f(prime[j]) cnt[to] = 1; f[to] = f[i] * calc_f(prime[j], 1); &#125; &#125;&#125; 常见积性函数： \begin{align} 1(n)&=1\\ id(n)&=n\\ \epsilon(n)&=[n=1]\\ \phi(n)&=\sum\limits_{i=1}^n[\gcd(n,i)=1]\\ d(n)&=\sum\limits_{i=1}^n[i|n] \end{align}莫比乌斯反演已知$g(n)$的因数和$f(n)=\sum\limits_{d|n}g(d)$，通过$f$反求$g$。 g(n)=\sum\limits_{d|n}\mu(\dfrac{n}{d})f(d)其中$\mu$称为莫比乌斯函数，定义为 \mu(n)=\begin{cases} 1&n=1\\ (-1)^k&n=p_1p_2p_3...p_k\\ 0&其他 \end{cases}=\begin{cases} (-1)^k&n无平方因子\\ 0&n有平方因子 \end{cases}那么我们有莫比乌斯反演定理1 f(n)=\sum\limits_{d|n}g(d)\Leftrightarrow g(n)=\sum\limits_{d|n}\mu(\dfrac{n}{d})f(d)若存在正整数$N$使得$\forall n\in N,f(n)=g(n)=0$，则有莫比乌斯反演定理2 f(n)=\sum\limits_{n|m,m\le N}g(m)\Leftrightarrow g(n)=\sum\limits_{n|m,m\le N}\mu(\dfrac{m}{n})f(m)TIPS:$\sum\limits_{d|d’}d\mu(\dfrac{d’}{d})=\phi(d’)$ 狄利克雷卷积设$f:N\to R,g:N\to R$是两个函数，则它们的狄利克雷卷积为 (f*g)(n)=\sum\limits_{d|n}f(d)g(\dfrac{n}{d})命题：若$f(n),g(n)$是积性函数，则$h(n)=(f*g)(n)$也是积性函数。定理：$f=g*1\Leftrightarrow g=f*\mu$狄利克雷卷积符合交换律、结合律。一些公式 \begin{align} \epsilon&=\mu*1\\ id&=\phi*1\\ \phi&=\mu*id \end{align}杜教筛快速求积性函数的前缀和，时间复杂度$O(n^{\frac{2}{3}})$。定义梅滕斯函数$M(n)=\sum\limits_{i=1}^n\mu(n)$，可得 M(n)=1-\sum\limits_{i=2}^nM(\lfloor\dfrac{n}{i}\rfloor)用整除分块加速后面的求和，时间复杂度为$O(n^{\frac{3}{4}})$，预处理前$O(n^{\frac{2}{3}})$的数据，则可以将复杂度降到$O(n^{\frac{2}{3}})$。1234567891011ll sumM(ll n) &#123; if (n &lt;= lim)return smu[n]; if (M.count(n))return M[n]; ll ans = 1; for (ll l = 2, r; l &lt;= n; l = r + 1) &#123; ll d = n / l; r = n / d; ans = del(ans, mul(sumM(d), (r - l + 1) % mod)); &#125; return M[n] = ans;&#125;]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>莫比乌斯反演</tag>
        <tag>积性函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wqs二分]]></title>
    <url>%2F2021%2F07%2F29%2Fwqs%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[wqs二分wqs二分是用于求解这样一类问题的：1有若干个物品，要求选出m个物品，且选的时候有某种限制，求出最佳方案。 设$g(i)$表示选$i$个物品的最佳方案wqs二分适用的条件是，将所有的$(i,g(i))$画在二维平面上，这些点是上凸或下凸的。这种题的特点是如果不限制选物品的个数，可以很容易求出来。由于$(i,g(i))$构成一个凸壳，我们考虑二分一个斜率$k$，因为凸壳上斜率是单调的，通过斜率的变化可以找到决策点。当二分出一个$k$的时候，要找到其对应的最优决策点，我们发现与凸壳相切且斜率为$k$的直线的纵截距是$f(x)=g(x)-kx$，$x$就是我们要求的最优决策点。考察一下$f(x)$的意义，选出$x$个物品后最优价值为$f(x)=g(x)-kx$，其实就是原本的物品全都减掉$k$的价值后求出的最大价值，那么根据前面说的，这里就没有个数限制，非常好求。求出最大价值的同时可以求出$x$，这就是我们二分的依据了，根据$x$和要求的$m$之间的大小关系以及凸壳的斜率变化方向，改变二分的边界。]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>wqs二分</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式]]></title>
    <url>%2F2021%2F07%2F24%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前置芝士复数指数幂有欧拉公式 e^{i\theta}=\cos\theta+i\sin\theta显然$e^{i\pi}=1$ 单位根单位根的定义：在复数域下，满足$x^n=1$的$x$被称为$n$次单位根。根据代数基本定理，$n$次单位根一共有$n$个，且所有的$n$次单位根按照幅角排列是均匀分布的，第$k(0\le k&lt;n)$个$n$次单位根为 x_k=e^{i\frac{2k\pi}{n}}$n$个单位根在复平面上平分单位圆。 本原单位根$0$到$n-1$次方的值能生成所有$n$次单位根的$n$次单位根称为$n$次本原单位根。记$n$次本原单位根为$\omega_n=e^{i\frac{2\pi}{n}}=\cos\dfrac{2\pi}{n}+i\sin\dfrac{2\pi}{n}$ 设$n=2m$，有 (\omega_n^k)^2=\omega_m^k\\ \omega_n^{m+k}=-\omega_n^{k}阶与原根欧拉定理 若正整数a,m满足(a,m)=1，则a^{\phi(m)}\equiv 1\pmod{m}若正整数$a,m$满足$(a,m)=1$，则使得$a^n\equiv 1\pmod{m}$的最小正整数$n$称为$a$模$m$的阶，记作$\delta_m(a)$。若$\delta_m(a)=\phi(m)$，则称$a$为$m$的一个原根。 阶的性质： $a^0,a^1,…,a^{\delta - 1}$在模$m$意义下两两不同 $a^{\gamma}\equiv a^{\gamma’}\pmod{m}\Leftrightarrow \gamma\equiv\gamma’\pmod{\delta}$ $\delta |\phi(m)$ 原根的存在定理：只有模$2,4,p^a,2p^a$存在原根，其中$p$为奇质数。 原根的判定定理：设$m&gt;1$，$g$为正整数且$(m,g)=1$，则$g$是$m$的原根当且仅当对于任意$\phi(m)$的质因子$q_i$有$g^{\frac{\phi(m)}{q_i}}\not\equiv 1\pmod{m}$。 正整数$n$若存在原根，则其最小原根是$O(n^{\frac{1}{4}})$的，要求出$n$的所有原根可以通过先求出最小原根$g$，根据$g$来求所有原根。所有原根应满足$g’=g^k$且$(k,\phi(n))=1$。 1234567891011121314151617181920212223242526272829303132333435ll getrt(ll p) &#123; //求p的最小原根 ll tmp = p, phi = 1; vector&lt;int&gt;q; for (int i = 2; i * i &lt;= tmp; ++i) &#123; if (tmp % i == 0) &#123; q.push_back(i); tmp /= i; phi *= i - 1; while (tmp % i == 0)phi *= i, tmp /= i; &#125; &#125; if (tmp != 1)phi *= tmp - 1, q.push_back(tmp); if (p != 2 &amp;&amp; p != 4 &amp;&amp; (p % 4 == 0 || q.size() &gt; 2 || (q.size() == 2 &amp;&amp; q[0] != 2)))return -1; q.clear(); tmp = phi; for (int i = 2; i * i &lt;= tmp; ++i) &#123; if (tmp % i == 0) &#123; q.push_back(phi / i); while (tmp % i == 0)tmp /= i; &#125; &#125; if (tmp != 1)q.push_back(phi / tmp); for (int i = 1; ; ++i) &#123; if (GCD(p, i) &gt; 1)continue; bool tag = true; for (auto j : q) if (ksm(i, j, p) == 1) &#123; tag = false; break; &#125; if (tag)return i; &#125; return -1;&#125; 指标对于质数$p$，假设$g$是$p$的一个原根，则$g^0,g^1,…,g^{p-2}$在模$p$意义下是$1,2,…,p-1$的一个排列。假设对于$1\le x\le p-1$有$g^c\equiv x\pmod{p}$，则称$x$的指标为$c$，记作${\rm ind}(x)=c$。 指标的性质类似于对数，对于$\forall x,y\in[1,p-1]$： ${\rm ind}(x\cdot y)={\rm ind}(x)+{\rm ind}(y)$ ${\rm ind}(x^c)=c\cdot {\rm ind}(x)$ 求指标直接用BSGS。 离散快速傅里叶变换（FFT）两个多项式做乘法，用系数表示法直接算显然需要$O(n^2)$时间复杂度，于是我们考虑用点值表示法来计算，如果我们能求出两个多项式的点值表示法，那么就可以直接相乘来得到多项式相乘后的点值表示法，注意由于两个$n$次多项式相乘后是$2n$次多项式，所以我们需要求$2n$个点值。 点值表示法如果直接求，需要$O(n^2)$计算两个多项式的点值，$O(n^3)$高斯消元解出系数，我们需要将这两步的复杂度优化。求出一个$n$次多项式在每个$n$次单位根下的点值的过程被称为离散傅里叶变换（DFT），将点值重新插值成系数表示法的过程称为逆离散傅里叶变换（IDFT）。下面我们设进行变换的多项式为$n-1$次多项式$A(x)=\sum\limits_{i=0}^{n-1}a_i\times x^i$，其中$n$是2的幂（若不是则补齐），$m=\dfrac{n}{2}$。 FFT考虑对$A(x)$的下角标按奇偶分类，得到 A(x)=\sum\limits_{i = 0}^{n-1}a_ix^i =\sum\limits_{i=0}^{m-1}a_{2i}\times x^{2i}+\sum\limits_{i=0}^{m-1}a_{2i+1}\times x^{2i+1}将右式提一个x出来，得到 A(x)=\sum\limits_{i=0}^{m-1}a_{2i}\times x^{2i}+x\sum\limits_{i=0}^{m-1}a_{2i+1}x^{2i}=\sum\limits_{i=0}^{m-1}a_{2i}(x^2)^i+x\sum\limits_{i=0}^{m-1}a_{2i+1}(x^2)^i我们设 A_0=\sum\limits_{i=0}^{m-1}a_{2i}x^i\\ A_1=\sum\limits_{i=0}^{m-1}a_{2i+1}x^i则 A(x)=A_0(x^2)+x\times A_1(x^2)虽然规模减小了，但是$A_0,A_1$系数是不一样的，那每层往下递归两次还是$O(n^2)$的。由前置芝士我们知道，$\omega_n^{m+k}=-\omega_n^{k}$，$(\omega_n^k)^2=\omega_m^k$，于是就来考虑能不能只求小于$m$的部分。对于$0\le k&lt; m$，我们有 \begin{align} A(\omega_n^k)&=A_0((\omega_n^k)^2)+\omega_n^kA_1((\omega_n^k)^2)&(1)\\ A(\omega_n^k)&=A_0(\omega_m^k)+\omega_n^kA_1(\omega_m^k)&(2) \end{align}考虑$m+k$的部分，我们有 \begin{align} A(\omega_n^{m+k})&=A_0((\omega_n^{m+k})^2)+\omega_n^{m+k}A_1((\omega_n^{m+k})^2)&(3)\\ A(\omega_n^{m+k})&=A_0((-\omega_n^k)^2)-\omega_n^kA_1((-\omega_n^k)^2)&(4)\\ A(\omega_n^{m+k})&=A_0(\omega_m^k)-\omega_n^kA_1(\omega_m^k)&(5) \end{align}观察(2)和(5)，只要求出$0\le k&lt;m$的部分的$A_0,A_1$，我们就能求出$A$了，问题规模缩小到原来的$\dfrac{1}{2}$。到这里，由系数表示法求点值的问题就解决了。复杂度$O(n\log n)$ IDFT现在我们来看，得到了$n$个点值后如何插值得到多项式的系数。假设已知一个$n-1$次多项式$A(x)=\sum\limits_{i=0}^{n-1}a_ix^i$进行DFT后得到了点值$\{b_k\}$，那么求解$a$的过程相当于求解以下方程组 \begin{pmatrix} \omega_{n}^{0\cdot 0}&\omega_n^{0\cdot 1}&...&\omega_n^{0\cdot (n-1)}\\ \omega_{n}^{1\cdot 0}&\omega_n^{1\cdot 1}&...&\omega_n^{1\cdot (n-1)}\\ ...&...&...&...\\ \omega_{n}^{(n-1)\cdot 0}&\omega_n^{(n-1)\cdot 1}&...&\omega_n^{(n-1)\cdot (n-1)} \end{pmatrix}\begin{pmatrix} a_0\\ a_1\\ ...\\ a_{n-1} \end{pmatrix}=\begin{pmatrix} b_0\\ b_1\\ ...\\ b_{n-1} \end{pmatrix}设为$\Omega\times A=B$，则$B=\Omega^{-1}\times A$这里直接给出结论 \Omega^{-1}=\dfrac{1}{n}\begin{pmatrix} \omega_{n}^{-0\cdot 0}&\omega_n^{-0\cdot 1}&...&\omega_n^{-0\cdot (n-1)}\\ \omega_{n}^{-1\cdot 0}&\omega_n^{-1\cdot 1}&...&\omega_n^{-1\cdot (n-1)}\\ ...&...&...&...\\ \omega_{n}^{-(n-1)\cdot 0}&\omega_n^{-(n-1)\cdot 1}&...&\omega_n^{-(n-1)\cdot (n-1)} \end{pmatrix}令$M=\Omega^{-1}\times\Omega$，写出$M_{ij}$的表达式 M_{ij}=\dfrac{1}{n}\sum\limits_{k=0}^{n-1}\omega_n^{(j-i)\cdot k}=\begin{cases} 1& i=j\\ \dfrac{1-\omega_{n}^{(j-i)\cdot n}}{1-\omega_n^{j-i}}=0& i\not=j \end{cases}于是求解$a$的方程就为 \begin{pmatrix} a_0\\ a_1\\ ...\\ a_{n-1} \end{pmatrix}=\dfrac{1}{n}\begin{pmatrix} \omega_{n}^{-0\cdot 0}&\omega_n^{-0\cdot 1}&...&\omega_n^{-0\cdot (n-1)}\\ \omega_{n}^{-1\cdot 0}&\omega_n^{-1\cdot 1}&...&\omega_n^{-1\cdot (n-1)}\\ ...&...&...&...\\ \omega_{n}^{-(n-1)\cdot 0}&\omega_n^{-(n-1)\cdot 1}&...&\omega_n^{-(n-1)\cdot (n-1)} \end{pmatrix}\begin{pmatrix} b_0\\ b_1\\ ...\\ b_{n-1} \end{pmatrix}这就相当于给定了$B(x)=\sum\limits_{i=0}^{n-1}b_ix^i$，求点值$B(\omega_n^{-k}),0\le k&lt;n$该问题的形式与前面求$A(x)$的点值完全相同，唯一的区别就是$\omega_n$的指数多了一个负号，计算的时候把符号加上就行了。时间复杂度也是求点值的复杂度$O(n\log n)$。 模板以上只是利用FFT计算多项式乘法的基本原理，FFT本身常数很大，优化的手段很多，例如蝴蝶变换可以非递归实现FFT，还有两个多项式都需要求点值，这就需要三次FFT，而实际上可以一次FFT求出两个多项式的点值，下面的板子是最终版本，可以直接使用。123456789101112131415161718192021222324252627282930313233343536373839404142struct Complex &#123; double x, y; Complex(double x = 0.0, double y = 0.0) : x(x), y(y) &#123;&#125; Complex operator +(const Complex &amp;s)const &#123; return Complex(x + s.x, y + s.y); &#125; Complex operator -(const Complex &amp;s)const &#123; return Complex(x - s.x, y - s.y); &#125; Complex operator *(const Complex &amp;s)const &#123; return Complex(x * s.x - y * s.y, x * s.y + y * s.x); &#125;&#125;;struct Fast_Fourier_Transfrom &#123; Complex a[N]; int r[N]; void FFT(int len, Complex a[], int type) &#123; for (int i = 0; i &lt; len; ++i) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 1; mid &lt; len; mid &lt;&lt;= 1) &#123; Complex wn = Complex(cos(PI / mid), type * sin(PI / mid)); for (int R = mid &lt;&lt; 1, j = 0; j &lt; len; j += R) &#123; Complex w = Complex(1, 0); for (int k = 0; k &lt; mid; ++k, w = w * wn) &#123; Complex x = a[j + k], y = w * a[j + mid + k]; a[j + k] = x + y; a[j + k + mid] = x - y; &#125; &#125; &#125; &#125; void Mul(int n, int m) &#123; int len = 1, x = 0; //假设n&gt;=m，将第一个多项式的系数放在实部，第二个多项式的系数放在虚部 //最终a[i].x就是指数为i的项的系数 for (; len &lt;= n + m - 2; len &lt;&lt;= 1, ++x); for (int i = 0; i &lt; len; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (x - 1)); memset(a + n, 0, sizeof(Complex) * (len - n + 1)); FFT(len, a, 1); for (int i = 0; i &lt;= len; ++i) a[i] = a[i] * a[i]; FFT(len, a, -1); for (int i = 0; i &lt;= n + m - 2; ++i) a[i].x = a[i].y / len / 2; &#125;&#125;FFT; 快速数论变换（NTT）假设质数$p$满足$p=r2^l+1$，$g$是$p$的原根，用$g_n=g^{\frac{p-1}{n}}$替换FFT中的$\omega_n$。当项数$n\le 2^l$时，与$\omega_n$相似的性质仍然成立： $g_{2n}^{2k}\equiv g_n^k\pmod{p}$ $g_{2n}^n\equiv-1\pmod{p}$ $\sum\limits_{k=0}^{n-1}g_{n}^{ik}g_n^{-kj}=\begin{cases}n&amp;i=j\\0&amp;i\not=j\end{cases}\pmod{p}$，其中$0\le i,j&lt;n$ 所以将$\omega_n$直接替换成$g_n$，DFT、IDFT的过程仍然正确，这样构成的算法就是NTT。值得注意的是，用NTT求解的多项式系数是模$p$后的结果，所以如果需要精确的系数，就需要选用较大的模数。 常见模数： $65537=2^{16}+1,g=3$ $167772161=5\times2^{25}+1$ $469762049=7\times2^{26}+1$ $998244353=119\times 2^{23}+1,g=3$ $1004535809=479\times2^{21}+1,g=3$ $4179340454199820289=29\times 2^{57}+1,g=3$ 模板仿照FFT直接写出NTT的模板。123456789101112131415161718192021222324252627282930313233343536373839404142434445struct Number_Theoretic_Transform &#123; ll G = 3, Gi = 332748118, mod = 998244353; //特别注意，封装mod常数非常大，如果不是为了用MTT还是放外面好 ll a[N], b[N]; int r[N]; ll FastPow(ll a, ll b) &#123; ll ans = 1; for (; b; b &gt;&gt;= 1, (a *= a) %= mod) if (b &amp; 1)(ans *= a) %= mod; return ans; &#125; ll ADD(ll a, ll b) &#123; a += b; return a &gt;= mod ? a - mod : a; &#125; ll DEL(ll a, ll b) &#123; a -= b; return a &lt; 0 ? a + mod : a; &#125; void NTT(int len, ll a[], int type) &#123; for (int i = 0; i &lt; len; ++i) if (i &lt; r[i]) swap(a[i], a[r[i]]); for (int mid = 1; mid &lt; len; mid &lt;&lt;= 1) &#123; ll gn = FastPow(type ? G : Gi, (mod - 1) / (mid &lt;&lt; 1)); for (int R = mid &lt;&lt; 1, j = 0; j &lt; len; j += R) &#123; ll g = 1; for (int k = 0; k &lt; mid; ++k, g = g * gn % mod) &#123; ll x = a[j + k], y = g * a[j + mid + k] % mod; a[j + k] = ADD(x, y); a[j + mid + k] = DEL(x, y); &#125; &#125; &#125; &#125; void Mul(int n, int m) &#123; int len = 1, x = 0; for (; len &lt;= n + m - 2; len &lt;&lt;= 1, ++x); for (int i = 0; i &lt; len; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (x - 1)); memset(a + n, 0, sizeof(ll) * (len - n + 1)); memset(b + m, 0, sizeof(ll) * (len - m + 1)); NTT(len, a, 1); NTT(len, b, 1); for (int i = 0; i &lt; len; ++i) a[i] = a[i] * b[i] % mod; NTT(len, a, 0); ll inv = FastPow(len, mod - 2); for (int i = 0; i &lt;= n + m - 2; ++i) a[i] = a[i] * inv % mod; &#125;&#125;NTT; 任意模数NTT（MTT）在NTT的基础上我们可以推广出求解模数为任意值的多项式运算方法。其基本思想为选取若干个不同的NTT模数，通过NTT分别求出运算结果，最后利用exCRT将这些结果合并，由exCRT的性质我们知道最终合并的结果是在模NTT模数之积意义下的，所以需要保证NTT模数之积是大于运算结果的，这样就能求出运算结果的实际值，当然任意模意义下的值也能求了。 这里以取三个模数做多项式乘法为例。设某一项系数待求答案为$x$，三个模数为$A,B,C$，则有 \begin{cases} x\equiv x_0\pmod{A}\\ x\equiv x_1\pmod{B}\\ x\equiv x_2\pmod{C} \end{cases}合并前两个方程得到 x_0+k_0A=x_1+k_1B\\ k_0\equiv\dfrac{x_1-x_0}{A}\pmod{B}这就意味着$x\equiv x_0+k_0A\pmod{AB}$，令$x_3=x_1+k_0A$，继续合并得 x_3+k_3AB=x_2+k_2C\\ k_3\equiv\dfrac{x_2-x_3}{AB}\pmod{C}于是最终得到 x\equiv x_3+k_3AB\pmod{ABC}123456789101112131415161718192021222324252627282930313233343536struct Multiple_Theoretic_Transform &#123; Number_Theoretic_Transform NTT[3]; ll ADD(ll a, ll b, ll p) &#123; a += b; return a &gt;= p ? a - p : a; &#125; ll DEL(ll a, ll b, ll p) &#123; a -= b; return a &lt; 0 ? a + p : a; &#125; ll mul(ll a, ll b, ll p) &#123; ll ans = 0; for (; b; b &gt;&gt;= 1, a = ADD(a, a, p)) if (b &amp; 1)ans = ADD(ans, a, p); return ans; &#125; ll ksm(ll a, ll b, ll p) &#123; ll ans = 1; for (; b; b &gt;&gt;= 1, a = mul(a, a, p)) if (b &amp; 1)ans = mul(ans, a, p); return ans; &#125; void init() &#123; NTT[0].mod = 167772161, NTT[0].G = 3, NTT[0].Gi = NTT[0].FastPow(3, NTT[0].mod - 2); NTT[1].mod = 469762049, NTT[1].G = 3, NTT[1].Gi = NTT[1].FastPow(3, NTT[1].mod - 2); NTT[2].mod = 998244353, NTT[2].G = 3, NTT[2].Gi = NTT[2].FastPow(3, NTT[2].mod - 2); &#125; void Mul(int n, int m, ll a[], ll b[], ll p) &#123; init(); for (int i = 0; i &lt; 3; ++i) &#123; for (int j = 0; j &lt; n; ++j)NTT[i].a[j] = a[j]; for (int j = 0; j &lt; m; ++j)NTT[i].b[j] = b[j]; NTT[i].Mul(n, m); &#125; for (int i = 0; i &lt;= n + m - 2; ++i) &#123; ll k0 = mul(DEL(NTT[1].a[i], NTT[0].a[i], NTT[1].mod), ksm(NTT[0].mod, NTT[1].mod - 2, NTT[1].mod), NTT[1].mod); ll x = ADD(NTT[0].a[i], mul(k0, NTT[0].mod, NTT[2].mod), NTT[2].mod); ll k3 = mul(DEL(NTT[2].a[i], x, NTT[2].mod), ksm(NTT[0].mod * NTT[1].mod % NTT[2].mod, NTT[2].mod - 2, NTT[2].mod), NTT[2].mod); a[i] = ADD(ADD(NTT[0].a[i] % p, mul(k0 % p, NTT[0].mod % p, p), p), mul(k3 % p, NTT[0].mod * NTT[1].mod % p, p), p); &#125; &#125;&#125;MTT; 其他运算也是类似的先分别求答案再合并。 拉格朗日插值拉格朗日插值定理$n$个点值$(x_i,y_i),(1\le i\le n)$，满足$x_i\not=x_j,(i\not=j)$，它们唯一确定一个$n-1$次多项式$f(x)$ f(x)=\sum\limits_{i=1}^ny_i\prod\limits_{j\not=i}\dfrac{x-x_j }{x_i-x_j}如果已知$x_i=i$的连续$n$个点值，就可以$O(n)$地求出任意一个点值$f(x_0)$。12345678910111213141516171819202122232425ll solve(int x) &#123; //求出f(x)，已知x=0~n的点值 //处理分母，这里逆元可以递推，偷懒就快速幂 muln[1] = mod - 1, mulp[1] = 1; for (int i = 2; i &lt;= n + 1; ++i) &#123; muln[i] = (mod - muln[i - 1] * ks(i, mod - 2) % mod) % mod; mulp[i] = mulp[i - 1] * ksm(i,mod - 2) % mod; &#125; //处理分子 L[0] = x, R[n] = x - n; for (int i = 1; i &lt; n; ++i) &#123; L[i] = L[i - 1] * ((x - i + mod) % mod) % mod; R[n - i] = R[n - i + 1] * ((x - n + i + mod) % mod) % mod; &#125; ll ans = 0; for (int i = 0; i &lt;= n; ++i) &#123; if (i == 0) (ans += f[i] * R[1] % mod * muln[n] % mod) %= mod; else if (i == n) (ans += f[i] * L[n - 1] % mod * mulp[n] % mod) %= mod; else (ans += f[i] * L[i - 1] % mod * R[i + 1] % mod * muln[n - i] % mod * mulp[i] % mod) %= mod; &#125; return ans;&#125; 牛顿迭代给定多项式$g(x)$，求满足$g(f(x))=0$的形式幂级数$f(x)$。牛顿迭代用于求解$f(x)$前$n$项。 $n=1$时，解$g(a_0)=0$得到$a_0$ 如果已知前$n$项$f(x)\equiv f_0(x)=a_0+a_1x+…+a_{n-1}x^{n-1}\pmod{x^n}$ 则$f(x)\equiv f_0-\dfrac{g(f_0(x))}{g’(f_0(x))}\pmod{x^{2n}}$ 多项式（形式幂级数）求逆设$h(x)$是给定的形式幂级数，求它的逆$f(x)$，则$g(f(x))=\dfrac{1}{f(x)}-h(x)=0$，得到的迭代形式为 f(x)\equiv 2f_0(x)-f_0^2(x)h(x)\pmod{x^{2n}}12345678910111213141516171819void Inv(int n, ll f[], ll h[]) &#123; //求h的逆，答案放在f中，n为项数 f[0] = FastPow(h[0], mod - 2); for (int len = 2, x = 2; (len &gt;&gt; 1) &lt; n; len &lt;&lt;= 1, ++x) &#123; for (int i = 0; i &lt; len; ++i)a[i] = f[i], b[i] = h[i]; memset(a + len, 0, sizeof(ll) * len); memset(b + len, 0, sizeof(ll) * len); for (int i = 0; i &lt; (len &lt;&lt; 1); ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (x - 1)); NTT(len &lt;&lt; 1, a, 1); NTT(len &lt;&lt; 1, b, 1); for (int i = 0; i &lt; (len &lt;&lt; 1); ++i) f[i] = a[i] * DEL(2, a[i] * b[i] % mod) % mod; NTT(len &lt;&lt; 1, f, 0); ll inv = FastPow(len &lt;&lt; 1, mod - 2); for (int i = 0; i &lt; len; ++i) f[i] = f[i] * inv % mod; memset(f + len, 0, sizeof(ll) * len); &#125;&#125; 多项式（形式幂级数）开方设$h(x)$是给定的形式幂级数，求它的逆$f(x)$，则$g(f(x))=f^2(x)-h(x)=0$，得到的迭代形式为 f(x)\equiv f_0(x)-\dfrac{f_0^2(x)-h(x)}{2f_0(x)}\pmod{x^{2n}}12345678910111213141516171819202122ll invf[N];void Sqrt(int n, ll f[], ll h[]) &#123; f[0] = sqrt(h[0]);//h[0]为完全平方数 ll inv2 = FastPow(2, mod - 2); for (int len = 2, x = 2; (len &gt;&gt; 1) &lt; n; len &lt;&lt;= 1, ++x) &#123; memset(invf, 0, sizeof(ll) *len); Inv(len, invf, f); for (int i = 0; i &lt; len; ++i)a[i] = f[i], b[i] = h[i]; memset(a + len, 0, sizeof(ll) * len); memset(b + len, 0, sizeof(ll) * len); for (int i = 0; i &lt; (len &lt;&lt; 1); ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (x - 1)); NTT(len &lt;&lt; 1, a, 1); NTT(len &lt;&lt; 1, b, 1); NTT(len &lt;&lt; 1, invf, 1); for (int i = 0; i &lt; (len &lt;&lt; 1); ++i) f[i] = DEL(a[i], DEL(a[i] * a[i] % mod, b[i]) * invf[i] % mod * inv2 % mod); NTT(len &lt;&lt; 1, f, 0); ll inv = FastPow(len &lt;&lt; 1, mod - 2); for (int i = 0; i &lt; len; ++i) f[i] = f[i] * inv % mod; memset(f + len, 0, sizeof(ll) * len); &#125;&#125; 多项式（形式幂级数）对数考虑$(\ln(f(x)))’=f’(x)\dfrac{1}{f(x)}$，求导很明显可以$O(n)$，求积分也是$O(n)$，求逆$O(n\log n)$，因此总复杂度是$O(n\log n)$。12345678910void Ln(int n, ll f[], ll h[]) &#123; //求ln(h)，答案放在f中，n为项数 Inv(n, f, h); for (int i = 0; i &lt; n - 1; ++i)b[i] = h[i + 1] * (i + 1) % mod; for (int i = 0; i &lt; n; ++i)a[i] = f[i]; Mul(n, n - 1); f[0] = 0; for (int i = 1; i &lt; n; ++i) f[i] = a[i - 1] * FastPow(i, mod - 2) % mod;&#125; 多项式（形式幂级数）指数设$h(x)$是给定的形式幂级数，满足$[x^0]h(x)=0$，设$f(x)=\exp(h(x))$，则有$g(f(x))=\ln(f(x))-h(x)=0$，得到迭代形式为 f(x)\equiv f_0(x)(1-\ln(f_0(x))+h(x))\pmod{x^{2n}}12345678910111213141516171819202122ll lnf[N];void Exp(int n, ll f[], ll h[]) &#123; //求exp(h)，答案放在f中，n为项数 f[0] = 1; for (int len = 2, x = 2; (len &gt;&gt; 1) &lt; n; len &lt;&lt;= 1, ++x) &#123; memset(lnf, 0, sizeof(ll) * len); Ln(len, lnf, f); for (int i = 0; i &lt; len; ++i)a[i] = f[i], b[i] = h[i]; memset(a + len, 0, sizeof(ll) * len); memset(b + len, 0, sizeof(ll) * len); for (int i = 0; i &lt; (len &lt;&lt; 1); ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (x - 1)); NTT(len &lt;&lt; 1, a, 1); NTT(len &lt;&lt; 1, b, 1); NTT(len &lt;&lt; 1, lnf, 1); for (int i = 0; i &lt; (len &lt;&lt; 1); ++i) f[i] = a[i] * ADD(DEL(1, lnf[i]), b[i]) % mod; NTT(len &lt;&lt; 1, f, 0); ll inv = FastPow(len &lt;&lt; 1, mod - 2); for (int i = 0; i &lt; len; ++i) f[i] = f[i] * inv % mod; memset(f + len, 0, sizeof(ll) * len); &#125;&#125; 多项式（形式幂级数）快速幂求$f^k(x)\pmod{x^n}$，等同于求$\exp(k\ln f)\pmod{x^n}$，当然这里需要保证$[x^0]f(x)=1$。123456void Pow(int n, ll f[], ll h[], ll k) &#123; //求h^k，答案放在f中，n为项数 Ln(n, f, h); for (int i = 0; i &lt; n; ++i)h[i] = f[i] * k % mod; Exp(n, f, h);&#125;]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[群论]]></title>
    <url>%2F2021%2F05%2F07%2F%E7%BE%A4%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[等价类对于集合$X$，它的一个关系是集合$X\times X$的一个子集$R$，如果对于$x,y\in X$有$(x,y)\in R$，则称$x,y$有关系$R$，记作$xRy$。设关系$R$是集合$X$上的一个等价关系，对于$x\in X$，令$x_R=\{y\in X|xRy\}$，则称$x_R$为代表元为$x$的一个$R$等价类，所有$R$等价类构成集合$X$的一个分划。 置换群群的定义若集合$S\not=\varnothing$和$S$上的运算$\circ$构成的代数结构$(S,\circ)$满足： 封闭性:$S\times S\to S$ 结合律:$\forall a,b,c\in S.(a\circ b)\circ c=a\circ(b\circ c)$ 单位元:$\exists e\in S.\forall a\in S.a\circ e=e\circ a=a$ 逆元:$\forall a\in S.\exists b\in S.a\circ b=b\circ a=e$，记作$a^{-1}$ 则称$(S,\circ)$是一个群，若一个群满足交换律则称为阿贝尔群，否则称为非阿贝尔群。若$T\subseteq S$且$(T,\circ)$也是群，则称$(T,\circ)$是$(S,\circ)$的子群。 置换置换的定义有限集合到自身的双射$f:A\leftrightarrow A$称为置换，集合$S=\{a_1,a_1,…,a_n\}$上的置换可表示为 f= \begin{pmatrix} a_1 & a_2 & ... & a_n\\ a_{p_1} & a_{p_2} & ... & a_{p_n} \end{pmatrix}表示将$a_i$映射为$a_{p_i}$。 $n$元集合上的置换有$n!$个 将置换$f$的每个$i$指向$p_i$，得到一个环的森林 置换的复合对于两个置换$f=\begin{pmatrix}a_1&amp;a_2&amp;…&amp;a_n\\a_{p_1}&amp;a_{p_2}&amp;…&amp;a_{p_n}\end{pmatrix}$和$g=\begin{pmatrix}a_{p_1}&amp;a_{p_2}&amp;…&amp;a_{p_n}\\a_{q_1}&amp;a_{q_2}&amp;…&amp;a_{q_n}\end{pmatrix}$，有其复合 f\circ g= \begin{pmatrix} a_1 & a_2 & ... & a_n\\ a_{q_1} & a_{q_2} & ... & a_{q_n} \end{pmatrix}置换群显然集合$S$上的所有置换关于置换的复合满足群的条件，因此$(f的全集,\circ)$构成一个群，这个群的任意一个子群称为置换群。 循环置换循环置换是一类特殊的置换，可表示为 (a_1\;a_2\;...\;a_m)= \begin{pmatrix} a_1 & a_2 & ... & a_{m - 1} & a_m\\ a_2 & a_3 & ... & a_m & a_1 \end{pmatrix}若两个循环置换不含有相同的元素，称他们是不相交的，有：任意一个置换都可以分解为若干个不相交的循环置换的复合，如 \begin{pmatrix} a_1 & a_2 & a_3 & a_4 & a_5\\ a_3 & a_1 & a_2 & a_5 & a_4 \end{pmatrix}= (a_1\;a_3\;a_2)\circ(a_4\;a_5)设$g_i=(a_i,a_{i+1},…,a_m,a_1,a_2,…,a_{i-1})$，定义$G=\{g_0,g_1,…,g_{n-1}\}$称为正$n$边形的旋转群。 群对集合的作用设$(G,\circ)$是一个群，其单位元为$e$，$X$是一个集合，群$G$对集合$X$的一个作用是一个$G\times X$到$X$的映射$f$，满足： $\forall x\in X.f(e,x)=x$ $\forall g,h\in G.f(h\circ g,x)=f(h,f(g,x))$ 简记$f(g,x)$为$g_f(x)$。$X$上的$G$关系：$R_G=\{(x,y)|x,y\in X\land(\exists g\in G.y=g(x))\}$$R_G$是等价关系，它将$X$划分为若干个等价类，每个等价类称为$X$上的一个$G$-轨道。 Burnside引理设有限群$(G,\circ)$作用在有限集$X$上，则$X$上的$G$-轨道数量为 N=\dfrac{1}{\left|G\right|}\sum\limits_{g\in G}\Psi(g)\\ \Psi(g)=\sum\limits_{x\in X}[g(x)=x]例如对于正$n$边形的旋转群$g$，有 \Psi(g_i)=m^{g_i环数量}=m^{(n,i)}一个经典问题是给一个$n$元环的节点涂上颜色，有$m$种颜色，通过旋转相同的涂色方案为同一个方案，求方案数。 N=\dfrac{1}{n}\sum\limits_{i=0}^{n-1}m^{(n,i)}=\dfrac{1}{n}\sum\limits_{d|n}\phi(d)m^{\frac{n}{d}}置换群的轮换指标轮换的形式：把置换中每个环上的节点按顺序记录下来，它是置换的另一种形式，比如$g=[3,4,5,6,1,2]=(135)(246)$置换型：如果$n$元置换$g$中有$b_i$个长度为$i$的轮换（其实就是环，$1\le i\le n$），则称这个置换$g$型为$1^{b_1}2^{b_2}…n^{b_n}$ 设$(G,\circ)$是一个$n$元置换的置换群，它的轮换指标为 P_G(x_1,x_2,...,x_n)=\dfrac{1}{\left|G\right|}\sum\limits_{g\in G}x_1^{b_1}x_2^{b_2}...x_n^{b_n}正$n$边形的旋转群的轮换指标： P_G=\dfrac{1}{n}\sum\limits_{d|n}\phi(d)x_d^{n/d}正$n$边形的二面体群的轮换指标： P_G=\dfrac{1}{2n}\phi(d)x_d^{n/d}+\begin{cases} \dfrac{1}{2}x_1x_2^{\frac{n-1}{2}}&n为奇数\\ \dfrac{1}{4}(x_2^{\frac{n}{2}}+x_1^2x_2^{\frac{n-2}{2}})&n为偶数 \end{cases}关于正方体的置换群： 顶点置换群：$P_G=\dfrac{1}{24}(x_1^8+8x_1^2x_3^2+9x_2^4+6x_4^4)$ 边置换群：$P_G=\dfrac{1}{24}(x_1^{12}+8x_3^4+6x_1x_2^5+3x_2^6+6x_4^3)$ 面置换群：$P_G=\dfrac{1}{24}(x_1^6+8x_3^2+6x_2^3+3x_1^2x_2^2+6x_1^2x_4)$]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>群论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈论]]></title>
    <url>%2F2021%2F04%2F08%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[博弈论博弈论主要研究的是：在一个游戏中，进行游戏的多位玩家的策略。 公平组合游戏公平组合游戏的定义如下： 游戏有两人参与，二者轮流做出决策，双方均知道游戏的完整信息。 任意一个游戏者在某一确定状态可以作出的决策集合只与当前的状态有关，而与游戏者无关。 游戏中的同一个状态不可能多次抵达，游戏以玩家无法行动为结束，且游戏一定会在有限步后以非平局结束。 博弈图（有向图游戏）和状态博弈中可能出现的某一局面称为一个状态。将每个状态视为一个节点，再从每个状态向它的后继状态连边，我们就可以得到一个博弈状态图。定义必胜状态为先手必胜状态，必败状态为先手必败状态，则有： 没有后继状态的状态是必败状态 一个状态是必胜状态当且仅当存在一个后继状态为必败状态 一个状态时必败状态当且仅当它的所有后继状态都是必胜状态 显然，当博弈图是一个DAG的时候我们可以直接逆拓扑出所有状态是必胜还是必败。博弈图也被称为有向图游戏，其实质为在一个DAG上有唯一的起点，起点上有一个棋子，两位玩家分别将棋子沿有向边移动，无法移动者输。任何一个公平组合游戏都可以转化为有向图游戏。 SG函数定义$mex$函数为集合中最小的非负整数，即 {\rm mex}(S)=\min\{x\}\;(x\not\in S,x\in N)对于状态$x$和它的所有$k$个后继状态$y_1,y_2,…,y_k$，定义SG函数 {\rm SG}(x)=\begin{cases} 0 & k=0\\ {\rm mex}(\{ {\rm SG}(y_1),{\rm SG}(y_2),...,{\rm SG}(y_k)\}) & k > 0 \end{cases}对于由$n$个有向图游戏组成的组合游戏，设它们的起点分别为$s_1,s_2,…,s_n$，则有SG定理： 当且仅当{\rm SG}(s_1)\oplus{\rm SG}(s_2)\oplus ... \oplus{\rm SG}(s_n)\not=0时，先手必胜Nim博弈给定n堆物品，第i堆物品有a[i]个，两名玩家轮流行动，每次可以取走任一堆的任意个物品，可以取完但不能不取，取走最后一件物品者胜，问先手是否有必胜策略。首先给出结论：当且仅当$a[1]\oplus a[2]\oplus…\oplus a[n]\not=0$时先手必胜。显然可以证明下面三个结论： 没有后继的状态是必败状态，此时$a[1]\oplus a[2]\oplus…\oplus a[n]=0$ 对于$a[1]\oplus a[2]\oplus…\oplus a[n]\not=0$的局面一定存在某种取法使得取后$a[1]\oplus a[2]\oplus…\oplus a[n]=0$ 对于$a[1]\oplus a[2]\oplus…\oplus a[n]=0$的局面一定不存在某种取法使得取后$a[1]\oplus a[2]\oplus…\oplus a[n]=0$ 阶梯博弈甚么是阶梯博弈？阶梯博弈指的是我们可以将状态进行分层（1~k），上层状态每次能且只能向下一层转移的博弈。给出结论：阶梯博弈等效于奇数层阶梯的Nim博弈。其实非常好理解，偶数层的状态移动到奇数层时，只要将这个状态再向下移一层，这个状态就与胜负无关了。 巴什博弈有一堆n个石子，两名玩家轮流从其中取石子，每次至少取1个最多取m个，取走最后一个石子的玩家获胜，问先手是否存在必胜策略。这个或者说这类问题的解法都很直接，从0开始枚举状态找规律，发现如果每次取的石子数在[p,q]，那么从1开始就是q个必胜3态、p个必败态…这样重复的。 斐波那契博弈有一堆n个石子，两名玩家轮流从其中取石子，先手不能一次将石子取完且最少取一颗，之后每次取的石子数不能超过上次去的个数的2倍且至少为1，取走最后一个石子的玩家获胜，问先手是否有必胜策略。结论：先手必败，当且仅当n为斐波那契数。根据齐肯多夫定理：任何一个正整数都可以表示成不连续的若干个斐波那契数之和，]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂记（一）]]></title>
    <url>%2F2021%2F03%2F31%2F%E6%9D%82%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[UVA1451 平均值 Average题目地址 Description给定一个长度为n的01串，选一个长度至少为L的连续子串，使得子串中数字的平均值最大。如果有多解，子串长度应尽量小；如果仍有多解，起点编号尽量小。序列中的字符编号为1~n，因此[1,n]就是完整的字符串。$1\le n\le 100000,1\le L\le 1000$。 Solution 1设01串的前缀和为sum，则[l,r]的平均值可以表示为$\dfrac{sum[r]-sum[l-1]}{r-(l-1)}$，该式可以看作是点(l-1,sum[l-1])和(r,sum[r])的斜率表达式，那么题意就可以转化为：给定n+1个节点（l-1的范围和r的范围取并后的集合大小是n+1），要求选出两个节点使得他们的横坐标之差至少为L，且斜率最大，若有多解取横坐标之差最小的，若还有多解取横坐标较小的。对于每个点x，我们只考虑横坐标比x小的点，那么显然我们取到的决策点就是过x且与左边所有点的下凸包的切点，因此我们需要在枚举x的过程中动态维护x-1的下凸包（注意，不是维护x的凸包）。那么如何快速找到这个切点呢？比较直接的想法是直接二分，这并没有问题，复杂度是$O(n\log n)$也可以接受，但实际上由于sum是随着x的增大而单调不降的，所以很容易证明这个问题具有决策单调性，也就是说随着x的增大决策点是单调不降的，因此我们可以用一个单调队列，尾部维护凸包，头部维护决策点。 Source Code1234567891011121314151617181920212223int main() &#123; int T = fast_IO::read(); while (T--) &#123; int n = fast_IO::read(), L = fast_IO::read(); scanf("%s", s + 1); for (int i = 1; i &lt;= n; ++i)sum[i] = sum[i - 1] + (s[i] ^ 48); //max&#123;(sum[j]-sum[i-1])/(j-(i-1))|j&gt;=i+L-1&#125; int ansl = 1, ansr = L; int head = 0, tail = 0; for (int i = 0; i &lt;= n - L; ++i) &#123; while (tail - head &gt; 1 &amp;&amp; (sum[i - 1] - sum[q[tail - 2] - 1]) * (i - q[tail - 1]) &gt;= (sum[i - 1] - sum[q[tail - 1] - 1]) * (i - q[tail - 2]))--tail; q[tail++] = i; while (tail - head &gt; 1 &amp;&amp; (sum[i + L - 1] - sum[q[head + 1] - 1]) * (i + L - q[head]) &gt;= (sum[i + L - 1] - sum[q[head] - 1]) * (i + L - q[head + 1]))++head; ll tmp = (sum[i + L - 1] - sum[q[head] - 1]) * (ansr - ansl + 1) - (sum[ansr] - sum[ansl - 1]) * (i + L - q[head]); if (tmp &gt; 0 || (tmp == 0 &amp;&amp; i + L - q[head] &lt; ansr - ansl + 1)) &#123; ansl = q[head]; ansr = i + L - 1; &#125; &#125; printf("%d %d\n", ansl, ansr); &#125; return 0;&#125; Solution 2还有一种比较明显的解法是二分平均值，验证只需要将每个元素都减去平均值，判断有没有一个长度至少为len的区间使得区间和为0即可。 七夕祭题目地址 Description有n行m列个摊位，可以对任意相邻摊位进行交换，而且行列分别首尾相邻，指定其中的T个摊位，问能否通过交换使得每行或每列的指定摊位个数一样多，并求最小交换次数。 $1\le n,m\le 100000，0\le T\le \min(n\cdot m, 100000)$ Solution首先，我们一定可以通过相邻互换将任何一个摊位移到任何一个位置，因此要判断能否使得每行的指定摊位数一样多或每列的指定摊位数一样多，只需要看T是否整除n、m。当T整除n、m的时候，我们就可以分别求出每行、每列应该分别为$\dfrac{n}{T},\dfrac{m}{T}$个指定摊位。显然，行方向上的移动不改变列上的值，列方向上的移动不改变行上的值，因此行列是独立的，分开处理，这样实际上就是个一维的问题而不是二维的。那么现在来考虑单独的行（列也一样）该如何计算，首先我们得到每行的指定摊位数$a_i$。由于行首尾相连，所以一行实际上是一个简单环。考虑移动的过程可以拆成多个移动，每次只移动一个单位，所以我们可以将所有的移动进行拆分，这样的话在每个相邻点连的边上会有一个转移的数量和方向，我们不妨规定$a_i\to a_{i-1}$的方向为正方向，设从某个点i沿着正方向移动的摊位数为$x_i$。那么就可以写出我们的目标函数： \left|x_1\right|+\left|x_2\right|+\left|x_3\right|+...+\left|x_{n-1}\right|+\left|x_n\right|现在我们的目的就是使目标函数最小。考虑到函数中变元较多，我们列出这些变元之间的关系。令$w=\dfrac{T}{n}$，即最终每行的指定摊位数，那么就可以得到如下方程组： \begin{cases} a_1-x_1+x_2=w\\ a_2-x_2+x_3=w\\ ...\\ a_{n-1}-x_{n-1}+x_n=w\\ a_n-x_n+x_1=w \end{cases}显然，该方程组的秩为n-1，我们无法直接求出所有的x，但是我们不妨设$x_1$为自由元，那么其他的x都可以用$x_1$表示： \begin{cases} x_1=x_1\\ x_2=x_1-(a_1-w)\\ x_3=x_1-(a_1+a_2-2w)\\ ...\\ x_{n-1}=x_1-(a_1+a_2+...+a_{n-2}-(n-2)w)\\ x_n=x_1-(a_1+a_2+...+a_{n-1}-(n-1)w) \end{cases}不难看出，右式中减号后面的部分有明显的规律，我们记为$c$那么目标函数就变形为 \left|x_1-c_1\right|+\left|x_1-c_2\right|+\left|x_1-c_3\right|+...+\left|x_1-c_{n-1}\right|+\left|x_1-c_n\right|这里面不确定的只有$x_1$，那么问题就转化为：数轴上有n个点，坐标分别为$c_1,c_2,…,c_n$，现在要在数轴上选一点，使得各点到这个点的距离之和最小，这就是一个经典问题了。首先给出结论：$x_1$取的是$c$的中位数，下面给出一种证明方法。假设$c$已排好序，根据绝对值不等式$\left|a\right|+\left|b\right|\ge\left|a+b\right|$，有如下推导 \begin{align} &\left|x_1-c_1\right|+\left|x_1-c_2\right|+\left|x_1-c_3\right|+...+\left|x_1-c_{n-1}\right|+\left|x_1-c_n\right|\\ &=\left|x_1-c_1\right|+\left|c_n-x_1\right|+\left|x_1-c_2\right|+\left|c_{n-1}-x_1\right|...\\ &\ge (c_n-c_1)+(c_{n-1}-c_2)+... \end{align}若不等号左式能取到右式，则说明右式为下确界，即为我们要求的最值。那么可不可以取到呢？我们取中位数，则右式中每一个括号内的一对c与中位数差的绝对值之和正好是其差的绝对值，因此右式是左式的下确界，且在$x_1$取$c$的中位数时目标函数值最小。 到此，这道题的算法就完全分析清楚了。 Source Code12345678910111213141516171819202122232425262728293031323334int row[N], col[N];ll sum[N];ll solve(int *a, int n, int w) &#123; for (int i = 1; i &lt;= n; ++i)a[i] -= w; ll ans = 0; sum[1] = 0; for (int i = 1; i &lt; n; ++i)sum[i + 1] = sum[i] + a[i]; sort(sum + 1, sum + n + 1); for (int i = 1; i &lt;= n; ++i) ans += abs(sum[n + 1 &gt;&gt; 1] - sum[i]); return ans;&#125;int main() &#123; int n = fast_IO::read(), m = fast_IO::read(), k = fast_IO::read(); for (int i = 1; i &lt;= k; ++i) &#123; ++row[fast_IO::read()]; ++col[fast_IO::read()]; &#125; if (k % n &amp;&amp; k % m)puts("impossible"); else if (k % n == 0 &amp;&amp; k % m == 0) &#123; printf("both "); printf("%lld", solve(row, n, k / n) + solve(col, m, k / m)); &#125; else if (k % n == 0) &#123; printf("row "); printf("%lld", solve(row, n, k / n)); &#125; else &#123; printf("column "); printf("%lld", solve(col, m, k / m)); &#125; return 0;&#125; 几何学中的欧拉公式 V-E+F = 2其中V为顶点数，E为边数，F为面数 组合数中的几个公式 k\begin{pmatrix}n\\k\end{pmatrix}=n\begin{pmatrix}n-1\\k-1\end{pmatrix}\\ \sum\limits_{i=0}^n\begin{pmatrix}n\\i\end{pmatrix}(k-1)^{n-i}=k^n随机排列在随机排列的时候用random_shuffle是可以被卡掉的。使用如下方式排列12mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());shuffle(a + 1, a + n + 1, rng);]]></content>
      <categories>
        <category>小结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图论（四）]]></title>
    <url>%2F2021%2F03%2F30%2F%E5%9B%BE%E8%AE%BA%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[图论杂记杂技 竞赛图（有向完全图）竞赛图即有向完全图指的是任意两点间有且仅有一条有向边的图。性质： 竞赛图没有自环、二元环；若竞赛图存在环，则一定存在三元环；若存在一个环大于三元，则一定存在另一个三元的小环。 任意竞赛图都有哈密顿路径（经过所有点一次的路径）。 图存在哈密顿回路的充要条件是强连通。 哈密顿问题中，对于n阶竞赛图，当n大于等于2时一定存在哈密顿道路 竞赛图中入度小的点一定能够达到入度大于等于该点的点，其缩点后的DAG中只有一个source、一个sink 兰道定理兰道定理用于判定竞赛图。将一个竞赛图的每一个点的出度从小到大排序后得到的序列称为竞赛图的比分序列。兰道定理： 一个长度为n的序列s=\{s_1\le s_2\le...\le s_n\},n\ge 1是合法的比分序列当且仅当：\\ \forall 1\le k\le n,\sum\limits_{i=1}^{k}s_i\ge C_k^2\\ 当k=n时这个式子必须取等号]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性基]]></title>
    <url>%2F2020%2F12%2F02%2F%E7%BA%BF%E6%80%A7%E5%9F%BA%2F</url>
    <content type="text"><![CDATA[线性基线性基用于求解这样的问题：在n个数中选任意个数，求满足某个性质的异或和。什么是线性基？线性基是一个数集，其中若干个数异或起来可以得到原数集中任何一个数。 性质原数集中任意一个数都可以由线性基里面的一些数异或得到。线性基里面任意个数异或起来都不等于0.线性基里面数的个数唯一，且在保证前面性质的基础上个数最少。 构造这里直接给出线性基的构造方法 1234567891011void _insert(ll x) &#123; //插入数x for (ll i = 50; ~i; --i) &#123; if (!((x &gt;&gt; i) &amp; 1))continue; if (base[i])x ^= base[i]; else &#123; base[i] = x; break; &#125; &#125;&#125; 问题求解最大值直接从高位到低位贪心，如果异或当前的线性基可以使得答案变大就异或。即1234567ll getmax() &#123; ll ans = 0; for (ll i = 50; ~i; --i) if ((ans ^ base[i]) &gt; ans) ans ^= base[i]; return ans;&#125; 为什么这样做是对的呢？考虑我们上面的构造过程，P[i]一定是考虑了更高位的线性基的，所以只要保证当前位会使答案增加即可，低位的总贡献无论如何都不会比一个高位的贡献大。 区间查询最大值在求最大值的基础上，我们可以得到序列中求区间最大值的算法，该算法还支持动态扩大区间。我们构造前缀线性基，即对每个位置i构造[1,i]的线性基，并且记录线性基上插入的数字的位置，保证这个位置尽量靠后。更多实现细节看模板1234567891011121314151617181920212223242526272829303132void _insert(int x, int loc) &#123; //做前缀线性基，先复制[1,loc-1]的，在这个基础上插入x for (int i = 0; i &lt;= 31; ++i) base[loc][i] = base[loc - 1][i], pos[loc][i] = pos[loc - 1][i]; for (int i = 31, now = loc; ~i; --i) &#123; if (!(x &gt;&gt; i))continue; if (base[loc][i] == 0) &#123; base[loc][i] = x; pos[loc][i] = now; break; &#125; //pos记录线性基中插入的数在原序列的位置，尽量保留靠后的数 //由于其中保留的数只可能是之前插入的，所以保存的位置不会超过loc if (now &gt; pos[loc][i]) &#123; jh(now, pos[loc][i]); jh(x, base[loc][i]); &#125; x ^= base[loc][i]; &#125;&#125;int query(int l, int r) &#123; if (l &gt; r)jh(l, r); int ans = 0; //最终查询的时候，只需要查看r处的线性基，由于前面我们保证了线性基中的数位置尽量靠后 //所以只用看线性基中的数是否&gt;=l即可 for (int i = 31; ~i; --i) &#123; if (pos[r][i] &gt;= l &amp;&amp; (base[r][i] ^ ans) &gt; ans) ans ^= base[r][i]; &#125; return ans;&#125; 最小值这个很显然。如果是问线性基能异或出的最小值，那就是最小的base如果是问原数集能异或出的最小值，那就再看看有没有数不能插入线性基，如果有，最小值就是0。 第k小值在前面构造的线性基的基础上进行改进处理，使得每一位上的线性基最高位就是这一位。123456void presolve() &#123; for (ll i = 50; ~i; --i) for (int j = 0; j &lt; i; ++j) if (base[i] &gt;&gt; j) &amp; 1) base[i] ^= base[j];&#125; 查询的时候，就可以通过k的二进制来选择是否异或上某个线性基了。1234567891011121314ll query(int k) &#123; //tot为线性基中插入的元素个数 //如果插入元素比元素总数少，说明可以异或出0，特判一下 if (k == 1 &amp;&amp; tot &lt; n)return 0; //线性基求解的是不为0的第k小，因此如果有0就应该求第k-1小 if (tot &lt; n)--k; ll ans = 0; presolve(); for (ll i = 0; i &lt; 50; ++i) if (base[i]) &#123; if (k &amp; 1)ans ^= base[i]; k &gt;&gt;= 1; &#125;&#125; 判断一个数能否被线性基异或得出尝试将这个数插入线性基，能插入说明不能，不能插入说明能。]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论（三）]]></title>
    <url>%2F2020%2F11%2F25%2F%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[2-SATSAT问题指的是给出一些条件（未知量经过逻辑运算的结果），问是否存在一种合法的方案使得其满足所有条件。而2-SAT问题是一种特殊的SAT问题，它限制了每个逻辑运算的表达式中最多有两个未知量。 二元逻辑运算的转化为了解决2-SAT问题，我们需要将所有给出的二元逻辑运算式进行转化，变成形如“若A取值为x则B取值为y”这样的条件，通常情况下，我们将取值限定在0和1。那么对于各种逻辑运算我们就可以进行转化： A and B = 0 —&gt; 若A=1则B=0，若B=1则A=0 A or B = 1 —&gt; 若A=0则B=1，若B=0则A=1 … 诸如此类，我们可以将所有的二元逻辑运算式表述成如上的形式。特别地，如果有A=1这样的表达式，我们可以转化成“若A=0，则A=1”。 建图那么为什么要进行这样的转化呢？因为这样的话，我们就可以将“某元素取值为x”这样的一个表述抽象成一个点，通过连边的方式来构建不同元素取值之间的关系。具体地，根据上面的例子，我们将每个点a拆成两个点a0和a1，分别表示“a取值为0”和“a取值为1”，对于“若A=x则B=y”，我们连有向边(Ax, By)，这样的话如果我们能在图上从点P走到点Q，就说明若命题P成立则命题Q成立。那么显然，如果能从a0走到a1且能从a1走到a0，则必然矛盾，这一步我们可以用tarjan求强连通分量解决。反之，则一定存在合法方案满足所有的二元逻辑运算式。 求解O(N+M)求一组可行解首先当然是通过tarjan求强连通分量，最后如果有a0与a1在同一个强连通分量内，说明无解。那么缩完点后，我们如何来找到一组合法的解呢？这里先给出策略：缩点后按照逆拓扑序，即与拓扑序刚好相反的顺序找到一个未被染色的点并染成黑色，然后将与这个强连通分量中的点矛盾的所有强连通分量全部染成白色，重复这一过程，最后所有染成黑色的强连通分量里的点就是一组可行解。那么如何证明这种策略的正确性呢？首先通过前面的缩点我们保证了强连通分量内没有矛盾，那么我们只需要证明染色的过程没有矛盾。显然，我们在染黑色点的时候已然将其对立点所在联通块全部染成白色，染色过程不会产生矛盾，现在只需要说明我们的染色过程能够覆盖到每一个未知量。我们假设某一个未知量的两个对应元素都被染成了白色，那么考虑我们的染色过程，某个点被染成白色必然是因为其对立点被染成了黑色，这就产生了矛盾，所以不存在同一个未知量的两个对应元素都被染成白色，所以这两个点必然是一白一黑。如此，我们就证明了这个方法的正确性。 那么具体如何来操作呢？实际上非常方便，因为我们在缩点的过程中会对所有强连通分量进行编号，而这个编号我们从小到大来编，这样的话越靠后的强连通分量获得的编号实际上越小（因为tarjan是用dfs实现的），因此强连通分量的编号实际上就是上面提到的“逆拓扑序”。那么结果就很明显了，对于未知量a，若$ltk[a_0] &lt; ltk[a_1]$，则$a=0$；若$ltk[a_1]&lt;ltk[a_0]$，则$a=1$ O(NM)求最小字典序解我们只需要枚举每一个未知量，若其取值合法就继续下去，否则取另一个值并继续下去。 关于O(NM)做法的一个优化如果我们能在遍历到x时就能判断出x是否能走到x’，就可以O(n+m)求解了，而这个预处理我们通过传递闭包实现。 传递闭包什么是传递闭包？一个n顶点DAG的传递闭包可以定义为一个n阶布尔矩阵$T=\{t_{i,j}\}$，若从i到j存在一条路径，则$t_\{i,j\}=1$，否则$t_{i,j}=0$。实际上，传递闭包揭示的是两点间的传递关系，即两点间是否存在直接或间接的关系。]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>2-sat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算几何（一）]]></title>
    <url>%2F2020%2F11%2F19%2F%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近点对问题平面直角坐标系上有若干个点，求其任意点对距离的最小值 模板12345678910111213141516171819202122232425262728293031323334353637383940struct Node &#123; double x, y; int tag; Node() &#123;&#125; Node(double x, double y, int tag = 0): x(x), y(y), tag(tag) &#123;&#125; bool operator &lt;(const Node s)const &#123; return x &lt; s.x || (x == s.x &amp;&amp; y &lt; s.y); &#125;&#125;p[N], tmp[N];bool cmp(Node x, Node y) &#123; return x.y &lt; y.y || (x.y == y.y &amp;&amp; x.x &lt; y.x); &#125;double getdis(Node x, Node y) &#123; return sqrt(pow(x.x - y.x, 2) + pow(x.y - y.y, 2)); &#125;double getmin(int l, int r) &#123; if (l == r)return 0; if (r - l == 1)return getdis(p[l], p[r]); if (r - l == 2) &#123; double ans = getdis(p[l], p[l + 1]); ans = min(ans, getdis(p[l + 1], p[r])); ans = min(ans, getdis(p[l], p[r])); return ans; &#125; int mid = l + r &gt;&gt; 1, tot = 0; double ans = min(getmin(l, mid), getmin(mid + 1, r)); for (int i = l; i &lt;= mid; ++i) if (p[mid].x - p[i].x &lt;= ans) tmp[tot++] = Node(p[i].x, p[i].y, 0); for (int i = mid + 1; i &lt;= r; ++i) if (p[i].x - p[mid].x &lt;= ans) tmp[tot++] = Node(p[i].x, p[i].y, 1); sort(tmp, tmp + tot, cmp); for (int i = 0; i &lt; tot; ++i) &#123; if (tmp[i].tag)continue; for (int j = 1; j &lt;= 7 &amp;&amp; i + j &lt; tot; ++j) &#123; if (!tmp[j].tag)continue; ans = min(ans, getdis(tmp[i], tmp[i + j])); &#125; &#125; return ans;&#125;void init(int n) &#123; for (int i = 0; i &lt; n; ++i)p[i] = Node(fast_IO::read(), fast_IO::read()); sort(p, p + n);&#125;]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学（二）]]></title>
    <url>%2F2020%2F11%2F18%2F%E6%95%B0%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[BSGSBSGS用于求解形如$A^x\equiv B\pmod{P}$的高次剩余问题。在这里我们先引入一些基础的数论知识。 欧拉函数及欧拉定理欧拉函数$\phi(x)$表示x内与x互质的数的个数，比如$\phi(6)=2$，$\phi(8)=4$欧拉函数的计算公式：设$n=p_1^{k_1}p_2^{k_2}…p_m^{k_m}$，则有 phi(n)=n\times\dfrac{p_1-1}{p_1}\times\dfrac{p_2-1}{p_2}\times...\times\dfrac{p_m-1}{p_m}欧拉定理：$若a,n互质，则a^{\phi(n)}\equiv 1\pmod{n}$ 欧拉降幂首先我们有广义欧拉定理 a^b=\begin{cases} a^{b\bmod \phi(p)} & \gcd(a,p)=1\\ a^b & \gcd(a,p)\not=1,b]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫环问题]]></title>
    <url>%2F2020%2F11%2F17%2F%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[经典问题简述有n个人，按编号1,2,3,…,n围成一圈，1与n相邻，现在从1开始往2的方向报数，报到m的人出列，然后下一个人从1开始重新报数，最后留下的人编号是几？ O(nm)暴力模拟最朴素的想法，我们直接模拟报数的过程，暴力比较简单这里不多做解释。 O(n)解法我们考虑能不能通过递推的方式求解，为了方便计算，我们先将所有人的编号用0~n-1表示，然后考虑每次有人出列后，将所有人的编号重排。比如对于n=5,m=3，其原编号为0 1 2 3 4在2出列后，编号为0 1 x 3 4重排后为2 3 x 0 1我们观察一下出列后重排前后序列之间的关系我们设出列时的人编号为k，重排前某人编号为p(p!=k)，重排后同一人编号为q，出列前总人数N那么显然有q=(p-(k+1)+N)%N，且k=(m-1)%N，我们只需要看，0向后移动了k+1位，就可以很容易推出该结论所以p=(q+k)%N=(q+m)%N，参照我们上面的定义，其实递推式已经很明显了为了方便描述，设$f(i,m)$为i人按题目的游戏规则最后出列人的编号(0~i-1)，则有 \begin{cases} f(1,m)=0\\ f(i,m)=(f(i-1,m)+m)\bmod i \end{cases}于是我们的问题就能线性求解了 123for (int i = 2; i &lt;= n; ++i) ans = (ans + m) % i;++ans;//我们的编号是0~n-1，题目要求是1~n O(logn)解法O(n)的解法似乎已经是最优解了，但人类不愿止步于此，于是又搞出来一个$O(\log n)$解法，当然，这里的$O(\log n)$是针对m比较小的情况，也就是认为m是一个常数，实际上m如果太大复杂度依然和$O(n)$或者$O(m)$差不多。 第一个解法我们考虑改变递推的策略，考虑当一圈人报数回到0时是什么样子，当人数减小到$m$时对剩下的部分按$O(n)$递推方法求解，换句话说，我们加速上述算法中$n&gt;m$的部分。我们依然是0~n-1表示当前人的编号，报过一圈后从最后一个出列的人开始从0起重编。例如n=8，m=3，那么初始序列为0 1 2 3 4 5 6 7报数后为0 1 x 3 4 x 6 7重排后为2 3 x 4 5 x 0 1现在我们依然是想通过$i-1$的答案推出$i$的答案，所以我们看看重排后的序列与重排前有什么关系我们设$i-1$规模的答案为q，%i%规模的答案为p首先我们观察到，最后一个x后人的个数为i%m，那么如果q &lt; i % m，则$p=q+(i-i\bmod m)$，也就是将直到最后一个x的部分的人数加回来否则，$p=q-i\bmod m+\lfloor\dfrac{q-i\bmod m}{m-1}\rfloor$，也就是说先减掉后面0~i%m-1的部分，然后加上前面删掉的人数，这里由于我们用的q是删后的序号，所以应该是除以$m-1$而不是除以$m$来得到删掉的人数。12345678int getans(int n, int m) &#123; if (n == 1)return 0; if (n &lt;= m)return (getans(n - 1, m) + m) % n; int s = getans(n - n / m, m) - n % m; if (s &lt; 0)s += n; else s += s / (m - 1); return s;&#125; 第二个解法（有问题）该解法可以求出第k(从0开始计数)个出列的人的编号，令k=n-1则得到原问题的答案。显然我们可以知道，第k个出列的人是第$k\cdot m+m-1$次报数的人（这里以及以后所有的“第”后面都是从0开始计数的，便于计算）那么我们通过这次报数往回追踪，每次计算上一次他是第几个报的数，就能找到最初当这个人报的数在$0~n-1$时报的数，即他的原始编号（从0计）。此处我们利用的是总报数的次数与编号的关系，所以没有重排。我们设报第p次的人为x，下一次他报数的次数为第q次，显然p可以表示为$p=a\cdot m+b,(0\le b&lt; m)$那么显然经过p次报数，出列了a个人，这时还剩n-a人，所以q=p+n-a，反过来就是p=q-n+a现在的问题就是a是多少，我们需要建立a与q的关系，这样才能由q算出p，由上面的算式可以推出$q=p+n-a=a\cdot(m-1)+n+b$由于x在报数后存活，所以b &lt; m-1，因此$a=\lfloor\dfrac{q-n}{m-1}\rfloor$（这一步我觉得有问题）最终算式就是$p=q-n+\dfrac{q-n}{m-1}$所以我们的策略就很明显了 12345int getans(int n, int m, int k) &#123; if (m == 1)return n - 1; for (k = k * m + m - 1; k &gt;= n; k = k - n + (k - n) / (m - 1)); return k;&#125;]]></content>
      <categories>
        <category>专题</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>约瑟夫环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串（二）]]></title>
    <url>%2F2020%2F11%2F12%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[马拉车（Manacher）与回文自动机（PAM）回文串反转串$R(S)$：一个字符串$S=S[1]S[2]…S[n]$，其反转串$R(S)=S[n]…S[2]S[1]$回文串：满足$S=R(S)$的字符串回文中心：奇数长度的回文串为$\dfrac{n+1}{2}$，偶数长度的回文串为$\dfrac{n}{2}$和$\dfrac{n}{2}+1$之间回文半径：回文中心到左右端点的距离。回文与Border：回文串$S$的回文前（后）缀等价于其Border。 Manacher首先为了避免讨论奇偶长度，将字符串$S$的首尾以及相邻两字符之间插入一个$S$字符集以外的字符$*$，得到$S^{*}=*S[1]*S[2]*…*S[n]*$。在$S^*$上重新定义极长回文串为长度为奇数且最大，且满足$S=R(S)$的字符串。 定义$Len[i]$为以$i$为回文中心的最大回文半径，为Manacher的求解目标。定义最右回文串$P$为所有已求得的回文串中，右端点最大的回文串。设已经求出$Len[1],Len[2],…,Len[i-1]$，此时的$P$为$S^*[L,R]$，回文中心为$p$，对$i$和$p,R$的关系进行讨论： $i&gt;R$，则从$i$处向左右暴力扩展，得到回文半径$Len[i]$以及新的$P$； $i\le R$，这就意味着$i\in(p,R]$，因此在$[L,p)$可以找到$i$的对称位置$j=2p-i$，而$Len[j]$是已经求过的，所以继续根据$Len[j]$的情况讨论： $Len[j]&lt; j-L+1$，说明以$j$为回文中心的极长回文串并没有超出$P$的范围，所以$Len[i]=Len[j]$； $Len[j]\ge j-L+1$，说明以$j$为回文中心的极长回文串可能会超出$P$的范围，而根据$p$对称过去的部分在$R$后面，并没有考察过，因此$Len[i]$首先继承了$Len[j]$中不超过$P$的范围，即$j-L+1$这部分，然后从这个状态继续向左右暴力扩展。 12345678910111213141516171819202122232425void Manacher(char s[], int len[], int n) &#123; for (int i = n - 1; ~i; --i)s[i + 1 &lt;&lt; 1] = '*', s[i &lt;&lt; 1 | 1] = s[i]; s[0] = '*'; n = n &lt;&lt; 1 | 1; len[0] = 1; int L = 0, R = 0, p = 0; for (int i = 1; i &lt; n; ++i) &#123; if (i &gt; R) &#123; len[i] = 0; while (i + len[i] &lt; n &amp;&amp; i - len[i] &gt;= 0 &amp;&amp; s[i + len[i]] == s[i - len[i]]) ++len[i]; p = i, L = i - len[i] + 1, R = i + len[i] - 1; &#125; else &#123; int j = (p &lt;&lt; 1) - i; if (len[j] &lt; j - L + 1)len[i] = len[j]; else &#123; len[i] = j - L + 1; while (i + len[i] &lt; n &amp;&amp; i - len[i] &gt;= 0 &amp;&amp; s[i + len[i]] == s[i - len[i]]) ++len[i]; p = i, L = i - len[i] + 1, R = i + len[i] - 1; &#125; &#125; &#125;&#125; 复杂度分析对于$i&gt;R$和$Len[j]\ge j-L+1$的情况，暴力扩展操作每进行一次都会使得$R$增加，而$R$的最大值为$\left|S^*\right|$，因此总复杂度为$O(\left|S^*\right|)$。 用途首先是可以求$Len[i]$，即每个位置的回文半径。可以求本质不同的回文子串的数量，因为本质不同的回文子串只会在$R$增大的时候增加，所以可以得到一个性质：对于长度为$n$的字符串$S$，其本质不同的回文子串个数最多只有$n$个。 回文自动机（PAM）PAM的结构与ACAM类似。PAM的节点最多$n$个，每个节点表示了一种回文串。用$S(u)$表示节点$u$所代表的回文串。$len[u]=\left|S(u)\right|$后继边：每个后继边上有一个字母$ch$。用$trans(u,ch)=v$表示$u$节点有后继边$ch$指向$v$节点，则有$S(v)=chS(u)ch$，且$len[v]=len[u]+2$。失配边：每个节点都有一个失配边，用$fail[u]=v$，表示$u$节点的失配边指向了$v$节点。则有$S(v)$是$S(u)$的最大Border，即最长回文后缀。 需要注意的是，奇数与偶数的回文串是有差别的，因此我们的PAM中不能只有一个根，应该有表示奇数和偶数长度的两个根，偶数根的$len$为$0$，奇数根的$len$为$-1$，且这两个根的$fail$指针互相指向对方。那么接下来依次考察$S$的每个字符来构造PAM，设当前我们所在的节点是$now$，那么我们就去考察$S[i]$与$S[i-len[now]-1]$是否相等，如果不相等就跳到$fail[now]$继续比较，直到比较成功，这里就会发现当除了根都无法匹配的时候，一定会在奇数根处匹配成功，这是符合要求的。若在某处匹配成功，且此时$now$并没有$S[i]$的后继边，那么就需要添加一个新的节点。新的节点就需要求$fail$，从新节点的父节点处向上搜整条$fail$链，找到第一个匹配的位置，即为所求的$fail$链。1234567891011121314151617181920212223242526struct PAM &#123; int c[N][26], fail[N], tot, rt0, rt1, len[N]; vector&lt;int&gt;to[N]; void build(char s[], int n) &#123; rt0 = ++tot, rt1 = ++tot; len[rt0] = 0, len[rt1] = -1; fail[rt0] = rt1; fail[rt1] = rt0; int now = rt0; for (int i = 1; i &lt;= n; ++i) &#123; int nt = s[i] - 'a'; while (i - len[now] - 1 &lt; 0 || s[i] != s[i - len[now] - 1]) now = fail[now]; if (!c[now][nt]) &#123; c[now][nt] = ++tot; len[tot] = len[now] + 2; int x = fail[now]; while (i - len[x] - 1 &lt; 0 || s[i] != s[i - len[x] - 1]) x = fail[x]; if (tot != c[x][nt])fail[tot] = c[x][nt], to[c[x][nt]].push_back(tot); else fail[tot] = rt0, to[rt0].push_back(tot); &#125; now = c[now][nt]; &#125; &#125;&#125;A; PAM Series前面提到了一个性质：回文串的回文后缀就等价于回文串的border。所以Border Series运用到PAM上，就有了PAM Series，即：某个回文串的回文后缀最多可能有$n$个，但是将这些回文后缀按长度排序，可以构成$O(\log n)$个等差数列。 后缀数组（SA）首先需要了解几个字符串中的基本定义： 子串：字符串s中任意截取的一段字符串t称t为s的子串 后缀：字符串s中从任一位置到字符串末尾的子串称为后缀，记为suf(i) 后缀数组：将s的所有后缀按照字典序进行排序，后缀对应的下标组成后缀数组，记sa[i]表示排名为i的后缀起始位置，rk[i]表示起始位置为i的后缀排名 SA求法这里给出一种常用解法。 基本思想：我们通过倍增的思想，对每个位置以长度为1的子串开始排序，每次将排序的长度翻倍，这样的话就能利用上一次排序的结果通过$\log n$次双关键字排序得到新的排序结果，而这里的排序我们选择基数排序来降低复杂度。 12345678910111213141516171819202122232425262728void radix_sort() &#123; memset(tong, 0, sizeof(int) * (m + 1)); //b存储第一关键字，其内顺序由第二关键字决定 for (int i = 1; i &lt;= n; ++i)++tong[rk[b[i]]]; for (int i = 1; i &lt;= m; ++i)tong[i] += tong[i - 1]; for (int i = n; i; --i)sa[tong[rk[b[i]]]--] = b[i];&#125;void getsa() &#123; m = 27; for (int i = 1; i &lt;= n; ++i) b[i] = i, rk[i] = s[i] - 'a' + 1; radix_sort(); for (int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; int tot = 0; for (int i = n - k + 1; i &lt;= n; ++i)b[++tot] = i;//没有第二关键字的排名靠前 for (int i = 1; i &lt;= n; ++i) if (sa[i] &gt; k)//枚举第二关键字 b[++tot] = sa[i] - k;//sa[i] - k是第一关键字 radix_sort();//求出sa swap(b, rk);//b是旧的rk，以此计算新的rk存储在rk中 rk[sa[tot = 1]] = 1; for (int i = 2; i &lt;= n; ++i) if (b[sa[i]] == b[sa[i - 1]] &amp;&amp; b[sa[i] + k] == b[sa[i - 1] + k])rk[sa[i]] = tot;//两个关键字都与前一个相同，排名也相同 else rk[sa[i]] = ++tot; if (tot == n)break; m = tot; &#125;&#125; LCP求法后缀数组最重要的作用就是可以求LCPLCP，即最长公共前缀，也就是两个字符串的前缀中相同且最长的子串长度。在这里，我们定义LCP(i,j)为suf(sa[i])和suf(sa[j])的LCP，即排名分别为i和j的两个后缀的LCP。显然我们有： $LCP(i,j)=LCP(j,i)$ $LCP(i,i)=n-sa[i]+1$ 接下来就需要证明几个重要的定理 LCP Lemma LCP(i,k)=\min\{LCP(i,j),LCP(j,k)|1\le i\le j\le k\}设$x=suf(sa[i]),y=suf(sa[j]),z=suf(sa[k]),p=min(LCP(i,j),LCP(j,k))$显然x与y的前p个字符相等，y与z的前p个字符相等，因此x与z的前p个字符相等，即$LCP(i,k)\ge p$j在i和k之间，根据字典序，LCP(i,j)与LCP(j,k)都大于等于LCP(i,k)，因此$LCP(i,k)\le p$综上，$LCP(i,k)=p=min(LCP(i,j),LCP(j,k))$ LCP Theorem根据LCP Lemma，我们不难得出 LCP(i,k)=\min\{LCP(i,i+1),LCP(i+1,k)\}=...=\min\{LCP(j,j-1)|1\le i< j\le k\}Height数组height数组是求LCP中最重要的一环。我们定义height[i]=LCP(i,i-1)，为了描述方便，设h[i]=height[rk[i]]则有 h[i]\ge h[i-1]-1我们设k=sa[rk[i-1]-1]，显然LCP(rk[i-1],rk[k])=h[i-1]现在我们来看看suf(k+1)与suf(i): $s[k]\not=s[i-1]$此时h[i-1]=0，LCP Theorem显然成立 $s[k]=s[i-1]$此时suf(i)是suf(i-1)去掉首字符得到的，suf(k+1)是suf(k)去掉首字符得到的，因此suf(i)和suf(k+1)之间的排名关系与suf(i-1)和suf(k)之间的排名关系相同，所以rk[k+1]&lt; rk[i]，而且，LCP(rk[k+1],rk[i])=LCP(rk[k],rk[i-1])-1=h[i-1]-1根据定义，h[i]=LCP(rk[i],rk[i]-1)接下来只要证明$\max\{LCP(rk[i], j)|j&lt; rk[i]\}=LCP(rk[i],rk[i]-1)$又因为rk[k+1]&lt;=rk[i]-1，就可得出h[i]&gt;=LCP(rk[k+1],rk[i])=h[i-1]-1而这个证明非常简单，根据字典序，suf(sa[j])的前h[i]个字符只能是suf(sa[rk[i]-1])的前h[i]个字符变小形成，这就保证了j减小的过程中LCP(rk[i],j)不会变大。 求LCP有了上面的性质和定理，我们就可以在线性复杂度内求出height数组123456789101112void getheight() &#123; int k = 0; for (int i = 1; i &lt;= n; ++i)rk[sa[i]] = i; for (int i = 1; i &lt;= n; ++i) &#123; //这里i枚举的是位置而不是排名 if (rk[i] == 1)continue; int j = sa[rk[i] - 1]; if (k)--k;//h[i]&gt;=h[i-1]-1，因此从h[i-1]-1开始检验 while (i + k &lt;= n &amp;&amp; j + k &lt;= n &amp;&amp; s[i + k] == s[j + k])++k;//直接找 height[rk[i]] = k; &#125;&#125; 根据LCP Theorem和height的定义，$LCP(i,j)=\min\{height[k]|i&lt;k\le j\}$我们用ST表来维护height的区间最小值，即可做到O(1)查询LCP 12345678910111213int LCP(int l, int r) &#123;//l和r都是rk值 if (l == r)return n - sa[l] + 1; if (l &gt; r)swap(l, r); ++l; int k = r - l + 1; return min(ST[l][k], ST[r - (1 &lt;&lt; k) + 1][k]);&#125;void init(int n) &#123; for (int i = 1; i &lt;= n; ++i)ST[i][0] = height[i]; for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) ST[i][j] = min(ST[i][j - 1], ST[i + (1 &lt;&lt; j - 1)][j - 1]);&#125;]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>后缀数组SA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划（二）]]></title>
    <url>%2F2020%2F11%2F05%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[DP的优化形式优化有时在解决DP问题时会遇到时间或空间复杂度过高的情况，这时候从DP的形式上进行优化是从根本上改进复杂度，典型的处理方式有预处理、分阶段DP等： 预处理：在DP过程中出现的大量重复的计算，往往可以通过预处理来节省重复计算的时间，通常我们在DP前预处理，或者在DP过程中处理出最值。 分阶段DP：在某些DP中将DP拆分成若干个不相关的转移，分开考虑，也许可以降低复杂度。 例题一、最长公共子序列给定长度为N,M的数组A,B，求最长公共上升子序列的长度。 $N,M\le 5000$ Solution设dp[i,j]表示数组A考虑到i，数组B考虑到j且以B[j]结尾的最长公共上升子序列长度。那么显然，当$A_i=B_j$时，我们有$dp[i][j] = \max\{dp[i-1][k]|k&lt;j,B_k&lt;B_j\}+1$但是呢，这样转移总时间复杂度是$O(n^3)$的，因此我们需要对我们的DP形式进行优化。考虑到$A_i=B_j$，那么实际上对于同一个$A_i$，对k的限制是相同的，因此我们只需要在枚举j的过程中动态维护$\max\{dp[i-1][k]|B_k&lt;A_i\}$，直接转移即可。 决策单调性优化四边形不等式优化对于如下形式的dp： f(i,j)=f(i,k-1)+f(k,j)+w_{i,j}若$w$满足四边形不等式： 任意$i\le i’\le j\le j’$，有$w_{i,j}+w_{i’,j’}\le w_{i’,j} + w_{i,j’}$ 任意$i’\le i\le j\le j’$，有$w_{i,j}\le w_{i’,j’}$ 则 f(i,j)+f(i',j')\le f(i',j)+f(i,j')可得$f(i,j)$的决策一定在$f(i,j-1)$的决策与$f(i-1,j)$的决策之间。 1D/1D动态规划方程优化对于形如 f(i)=\min\{f(j)+w_{j,i}|j\le i\}若$w$满足四边形不等式，则$f(i)$的决策也一定单调。这里的决策也就是j的实际取值 例题一、诗人小G题面 Solution由题意推得 f(i)=\min\{f(j)+\left|sum_i-sum_j+(i-j-1)-L\right|^p|j]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划（一）]]></title>
    <url>%2F2020%2F10%2F28%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[DP类型DP的一般形式是表示出能代表出与后续或答案有关的当前的状态，并在这些状态中进行转移DP的难点在于状态的设计和转移的优化。由于DP属于一种思想，不同的情况下状态设计和转移都不一样，下面对于每种DP都会给出问题来讲解。 序列DP将问题放在序列上，在序列上设计状态和转移，是一种非常常见的DP。题目：洛谷P2519 [HAOI2011]problem a 模型建立求最少有多少人没说真话，可以先求最多有多少人说真话。我们考虑将所有人的成绩排序后的一个序列A。第i个人说的是真话，当且仅当$A_{a_i+1}=…=A_{n-b_i}$，将这个区间看成一条线段，这样的话n个人就是n条线段。不难发现，如果两条线段相交但不重合，说明两个人中至少一人说了谎，而且对某一线段重合的线段个数不能超过线段的长度（包含的点数）。这样的话，我们的问题就转化成，对于n个线段，选出最多的线段个数，使得这些线段要么不相交，要么完全重合且对于同一个线段重合的线段个数不超过该线段的长度。 状态设计及转移优化重合的线段我们都放到一起，记一个总数并与长度取较小值，这样的话任意两条线段都是不重合的，那么就只用考虑不相交了如何我们以右端点为第一关键字，以左端点为第二关键字进行排序，显然我们遍历所有线段，那么如何设计状态呢？设dp[i]为前i个线段中能选的线段的最多个数，那么转移方程显然为$dp[i]=dp[last]+cnt$，其中last为右端点小于i左端点的最后一个线段，cnt为前面提到的总数。对每个i枚举j，复杂度为$O(n^2)$，所以我们要对这部分进行优化。考虑到我们的线段是以r为右端点为第一关键字排序的，也就是说线段的右端点是有序的，那么我们就可以二分找到右端点比i的左端点小的最靠后的线段，将dp记录成前缀最大值，就可以$O(\log n)$查找线段，$O(1)$转移了。 Solution(Accepted)1234567891011121314151617181920212223242526272829303132333435363738struct Segment &#123; int l, r, cnt; Segment() &#123;&#125; Segment(int l, int r): l(l), r(r) &#123; cnt = 1; &#125; bool operator &lt;(const Segment s)const &#123; return r &lt; s.r || (r == s.r &amp;&amp; l &lt; s.l); &#125;&#125;s[N], S[N];int dp[N];//二分查找，找到需要的线段int bin(int l, int r, int x) &#123; while (l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if (S[mid].r &lt;= x)l = mid + 1; else r = mid - 1; &#125; return r;&#125;int main(void) &#123; int n = fast_IO::read(), tot = 0; for (int i = 1; i &lt;= n; ++i) s[i] = Segment(fast_IO::read() + 1, n - fast_IO::read()); sort(s + 1, s + n + 1); for (int i = 1; i &lt;= n; ++i) &#123; if (s[i].l &gt; s[i].r)continue; if (s[i].l == s[i - 1].l &amp;&amp; s[i].r == s[i - 1].r) &#123; if (S[tot].cnt &lt; S[tot].r - S[tot].l + 1) ++S[tot].cnt; &#125; else S[++tot] = s[i]; &#125; dp[1] = S[1].cnt; for (int i = 2; i &lt;= tot; ++i) &#123; int pre = bin(1, i - 1, S[i].l - 1); dp[i] = max(dp[i - 1], dp[pre] + S[i].cnt);//转移 &#125; fast_IO::write(n - dp[tot]); return 0;&#125; 区间DP区间DP的状态一般表示为$dp[i][j][…]$，即区间$[i,j]$这一段的答案。 例题CF1132F. Clear the String题目大意是给你一个长度为$n\le 500$的字符串，每次可以删去一段由相同字符构成的连续子串，问删完所有字符最少需要多少次操作。 Solution这是一道非常模板的区间DP，我们设$dp[l][r]$为删去区间$[l,r]$的所有字符需要的最少操作次数。至于转移，区间DP常用的方法是枚举区间大小进行转移，这里也是如此。我们从小到大枚举区间的大小，然后枚举该大小的区间： 若区间两端相等，说明可以通过删去中间后两端连在一起删 若区间两端不相等，我们将区间分成两段，分别去删，取最小的次数。 于是我们的转移方程就出来了： $s[l]=s[r],dp[l][r]=min\{dp[l+1][r],dp[l][r-1]\}$ $s[l]\not=s[r],dp[l][r]=min\{dp[l][r],dp[l][k]+dp[k+1][r]|l\le k&lt; r\}$ 123456789for (int len = 2; len &lt;= n; ++len) &#123; for (int l = 1, r = len; r &lt;= n; ++l, ++r) &#123; if (s[l] == s[r])dp[l][r] = min(dp[l + 1][r], dp[l][r - 1]); else &#123; for (int k = l; k &lt; r; ++k) dp[l][r] = min(dp[l][r], dp[l][k] + dp[k + 1][r]); &#125; &#125;&#125; 数位DP数位DP常用于统计或查找一个区间满足条件的数，然后按数位顺序DP，一般需要仔细分情况讨论。常见处理方式有：拆成[1,R]和[1,L)，记忆化，预处理等。洛谷P2657 [SCOI2009] windy 数 状态建立及转移一道相当常规的数位DP，我们可以将[L,R]的答案拆成[1,R]-[1,L-1]的答案，这样的话我们只要能计算1到x的windy数就可以了。我们设dp[i][j]表示i位数最高位为j时的windy数，显然的转移是$dp[i][j]=sum(dp[i-1][k])$，其中k满足$abs(k-j)\ge 2$接下来我们就用dp来求解[1,x]的所有windy数12345678910111213141516171819202122232425262728293031323334353637383940414243444546int dp[N][N], num[N];void presolve() &#123; for (int i = 0; i &lt;= 9; ++i)dp[1][i] = 1; //这里要包括0的原因是我们dp的过程中，类似于20 30这些数依然是windy数，所以0虽然不是windy数，但却能产生贡献 for (int i = 2; i &lt;= 10; ++i) &#123; for (int j = 0; j &lt;= 9; ++j) &#123; for (int k = 0; k &lt;= 9; ++k) &#123; if (abs(j - k) &lt;= 1)continue; dp[i][j] += dp[i - 1][k]; //为什么这里j k要从0开始呢？这是考虑到我们会求在高位都一定时，从某位开始的所有windy数 //此时这些位就可能是0了 &#125; &#125; &#125;&#125;int solve(int x) &#123; if (!x)return 0; int ans = 0; for (*num = 0; x; x /= 10) num[++*num] = x % 10; for (int i = *num - 1; i &gt;= 1; --i) for (int j = 1; j &lt;= 9; ++j)//这里j不从0开始的原因很简单，j为0的话实际上数字就不是i位了，会重复计算 ans += dp[i][j]; //唯独*num位数最麻烦 for (int i = 1; i &lt; num[*num]; ++i) ans += dp[*num][i]; //接下来专注于最高位为num[*num]时的*num位数 for (int i = *num - 1; i &gt;= 1; --i) &#123; //从次高位开始一直到最低位，每一步计算当前位比num[i]小的数的所有贡献（因为后面的所有数都能取到， //只用考虑当前位与高一位是否冲突），之后只剩这一位为num[i]的情况，我们就再去求下一位的所有贡献 for (int j = 0; j &lt; num[i]; ++j) &#123; if (abs(j - num[i + 1]) &gt;= 2) ans += dp[i][j]; &#125; if (abs(num[i + 1] - num[i]) &lt; 2)return ans; //这时已经不可能再有多的贡献，因为在接下来的计算中我们的前提就是前面的所有位都是确定的，所以此处必然使剩下的所有数不成立 &#125; return ans + 1;//上面的计算并没有包括自身，此处要加上自身&#125;int main(void) &#123; presolve(); int l = fast_IO::read(), r = fast_IO::read(); fast_IO::write(solve(r) - solve(l - 1)); return 0;&#125; 概率DP概率DP是求事件概率或期望的DP的总称。对于求概率问题，有时利用补集转化，或者将其转化为计数问题；对于求期望问题，大多时候利用期望的线性性来解决问题。 贝叶斯公式条件概率$P(y|x)$联合概率$P(y,x)$$P(x,y)=P(y|x)P(x)=P(x)P(y)$$P(x,y)=P(x|y)P(y)$贝叶斯公式：$P(y|x)=\dfrac{P(x|y)P(y)}{P(x)}$ 例题：期望的线性性洛谷P3239 [HNOI2015]亚瑟王题目概述：给你$N$张牌，每张牌有一个发动概率$P_i$以及伤害$D_i$。共有$R$回合，每回合会按编号从小到大依次考虑本次游戏中还未发动的卡牌，依次尝试发动；如果发动成功，进入下一回合。求期望伤害之和。共$T$组数据。$T\le 444,N\le 220,R\le 132$ 这个题如果直接去算每一局的期望，非常难设状态（需要状压），而根据期望的线性性，我们考虑每张牌被发动的概率，那么总伤害就为每张牌造成的期望伤害之和。我们设dp[i][j]表示前i张牌中一共出了j张的概率，sump[x]表示x这张牌在整局游戏中被打出来的概率。对于转移，首先我们来看sump的转移，我们枚举前i-1张牌中出牌数j，由题意可知i之前打出的j张牌都不会考虑到第i张牌（因为打出去以后本轮就结束了），同时也说明有r-j轮可能会考虑到第i张牌，于是我们的转移方程就出来了，$sump[i]=\sum\limits_{j=0}^rdp[i-1][j]\cdot(1-(1-p[i])^{r-j})$，此处要注意，我们将“中间某处选第i张牌”采用了补集转换的思想，因为求出“中间没有任何一处选第i张牌”显然是更方便的。再来看看dp[i][j]的转移，这里显然要分两种情况讨论：是否选择了当前的第i张牌： 没有选择，那么$dp[i][j]=dp[i-1][j]\cdot (1-p[i])^{r-j}$，与上面类似，这里是后面r-j轮都不选i 若选择了，那么$dp[i][j]=dp[i-1][j-1]\cdot(1-(1-p[i])^{r-j+1})$，也是类似，前j-1张不可能选到i 最后答案即为$\sum\limits_{i=1}^nsump[i]\times d[i]$ 1234567891011121314151617181920212223242526272829303132double p[N], dp[N][N], sump[N], sum[N][N];int d[N];int main() &#123; int T = fast_IO::read(); while (T--) &#123; memset(dp, 0, sizeof(dp)); memset(sump, 0 , sizeof(sump)); int n = fast_IO::read(), r = fast_IO::read(); for (int i = 1; i &lt;= n; ++i) scanf("%lf%d", p + i, d + i); for (int i = 1; i &lt;= n; ++i) &#123; sum[i][0] = 1; for (int j = 1; j &lt;= r; ++j) sum[i][j] = sum[i][j - 1] * (1 - p[i]); //注意到我们后面总是用到1-p[i]的幂，先预处理 &#125; dp[1][0] = sum[1][r]; dp[1][1] = sump[1] = 1 - sum[1][r]; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= r; ++j) &#123; sump[i] += dp[i - 1][j] * (1 - sum[i][r - j]); dp[i][j] += dp[i - 1][j] * sum[i][r - j]; if (j)dp[i][j] += dp[i - 1][j - 1] * (1 - sum[i][r - j + 1]); &#125; &#125; double ans = 0; for (int i = 1; i &lt;= n; ++i)ans += sump[i] * d[i]; printf("%.10f\n", ans); &#125; return 0;&#125; 树形DP树形DP是指基于树形结构的动态规划，一般有： 树的直径：DP记录子树内的最长路 树的重心：DP记录子树大小 树上点权独立集：DP记录子树的根是否选择 树形依赖背包：在dfs序上DP，或通过将父节点的DP值传入孩子DP 虚树：后面会重点讲 … 虚树在原树上保留需要的点和它们的LCA的树成为虚树，换句话说，我们尽可能合并了中间的点。虚树适用于对同一棵树多次查询且查询的总点数在某一范围内的情况。我们对每次查询建一棵虚树，该树的点树不会超过查询点个数的2倍，这样就保证了复杂度。对于建树的过程，都是同样的方法，根据要求来合并被忽略的树链上的信息。 建树虚树的最大难点在于建树。首先我们预处理出整颗树的dfs序dfn，因为dfs序是沿着树链递增的。使用一个栈，栈底到栈顶的元素形成虚树的一个树链（从上到下）。对于一次查询，将所有的关键点按照dfn进行排序，然后从dfn小的点开始以此操作每个关键点，根据栈中树链的信息进行建树。具体过程如下： 如果栈为空或者只有一个元素，此时将点入栈 否则取lca=LCA(st[top],x)，若lca=st[top]，说明x是st[top]的后代，因此将x入栈，表示延长当前树链。 否则说明x与当前的st[top]分属于两个不同的链，而根据dfs序的性质，此时st[top]已经是一条链的终点。所以此时我们需要将lca的包含st[top]的部分退栈，退出来的部分构成一条树链。如果此时lca不在栈中，则lca也要入栈以保证虚树的结构，最后将x入栈。 最后将栈中剩余的元素相邻连边（剩下的全都是链的顶点和最后一条链，也可以看成是一条长链） 123456789101112131415161718192021222324void _insert(int x) &#123; if (top == 0) &#123; st[++top] = x; return; &#125; int lca = LCA(st[top], x); while (top &gt; 1 &amp;&amp; dep[lca] &lt;= dep[st[top - 1]]) &#123; add(st[top], st[top - 1], getval(st[top], st[top - 1])); --top; &#125; if (dep[lca] &lt; dep[st[top]])add(st[top], lca, getval(st[top], lca)), --top; if (!top || st[top] != lca)st[++top] = lca; st[++top] = x;&#125;bool cmp(int x, int y) &#123; return dfn[x] &lt; dfn[y]; &#125;void BuildTree(int n) &#123; for (int i = 1; i &lt;= n; ++i) node[i] = fast_IO::read(); sort(node + 1, node + n + 1, cmp); for (int i = 1; i &lt;= n; ++i)_insert(node[i]); for (int i = 1; i &lt; top; ++i) add(st[i], st[i + 1], getval(st[i], st[i + 1])); top = 0;&#125; 状压DP基于状态压缩的DP是由于状态用单个简单的变量直接存储导致空间浪费，而采用压缩的状态的动态规划，例如： 插头DP：维护当前已决策和未决策的一条Z字形轮廓线的插头状态，用括号序列配对插头，每次只需分情况考虑即可，不过这类DP状态较多，需要细心调。 例题、Tourism[POI2014]TUR-Tourism 给定一个n个点m条边的无向图，每个点有点权，保证任意两点之间简单路径长度不超过10。现在要求选出一些点，使得每个点要么自己被选，要么其相邻的点被选。一个方案的代价定义为选取点的点权和，求最小代价。$n\le 20000,m\le 25000,0\le A_i\le10000$ 思路考虑任意两点简单路径长度不超过10这个条件。我们不妨把生成树做出来，这样的话树的深度不超过10，于是我们就可以讲某点到根的路径上所有点的选取情况进行状态压缩。由于生成树并不能包含无向图中所有的边，因此点之间可能通过非树边连在一起。为了考虑这种情况，这里对每个点而言就有三种状态：被选取、未被选取但已被覆盖、未被选取且未被覆盖。因此我们使用三进制数来维护一个点到根路径上点的状态，这样一共有$O(3^{10})$种状态。于是我们就在这棵生成树上DP，首先设状态dp[i][j]表示对于i节点，当其到根节点的状态为j时，生成树中除了节点i到根上的点以外所有dfs序比i小的节点全被覆盖时的最小代价。至于转移，我们分别考虑选当前点和不选当前点的情况： 若不选当前点，如果前面走过的点中有一个点被选且存在一条边连接这两个点，当前点的状态就是被覆盖。 若选当前点，如果前面走过的点有点没被覆盖且存在一条边连接这两个点，则那个点的状态就要改为被覆盖 可以看出，两类转移都需要我们先找出所有指向已走过点的返祖边。最后再将当前点被覆盖的两个状态的dp值取小上传。另外，这里由于空间复杂度高，需要使用滚动数组，或者可以直接将第一维表示为深度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int getst(int st, int x) &#123; return st / mi[x] % 3; &#125;//0表示选取该点，1表示不选取该点且该点已覆盖，2表示不选取该点且该点未覆盖void dfs(int x) &#123; vis[x] = true; int tot = 0; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (!vis[k])continue; if (dep[k] &lt; dep[x]) fa[++tot] = k; &#125; if (!dep[x]) &#123; //根节点 dp[0][0] = v[x]; dp[0][1] = INF; dp[0][2] = 0; &#125; else &#123; for (int i = 0; i &lt; mi[dep[x] + 1]; ++i)dp[dep[x]][i] = INF; for (int i = 0; i &lt; mi[dep[x]]; ++i) &#123; //枚举父节点的状态 int st1 = 2, st2 = i;//st1是当前点不选时x的状态，st2是选x时x到根节点的状态 for (int j = 1; j &lt;= tot; ++j) &#123; if (getst(i, dep[fa[j]]) == 0)st1 = 1; else if (getst(i, dep[fa[j]]) == 2)st2 -= mi[dep[fa[j]]]; &#125; dp[dep[x]][i + st1 * mi[dep[x]]] = min(dp[dep[x]][i + st1 * mi[dep[x]]], dp[dep[x] - 1][i]); dp[dep[x]][st2] = min(dp[dep[x]][st2], dp[dep[x] - 1][i] + v[x] ); &#125; &#125; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (vis[k])continue; dep[k] = dep[x] + 1; dfs(k); for (int j = 0; j &lt; mi[dep[k]]; ++j) dp[dep[x]][j] = min(dp[dep[k]][j], dp[dep[k]][j + mi[dep[k]]]); &#125;&#125;int main() &#123; mi[0] = 1; for (int i = 1; i &lt;= 11; ++i)mi[i] = mi[i - 1] * 3; int n = fast_IO::read(), m = fast_IO::read(); for (int i = 1; i &lt;= n; ++i)v[i] = fast_IO::read(); for (int i = 1; i &lt;= m; ++i)add(fast_IO::read(), fast_IO::read()); int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (!vis[i]) &#123; dfs(i); ans += min(dp[0][0], dp[0][1]); &#125; &#125; printf("%d", ans); return 0;&#125; DP套DP背包专题背包是线性DP中的重要模型 0/1背包所谓0/1背包，就是一堆物品分别有价值w[i]和占用空间v[i]，每种物品都是一个，现在要用空间大小为m的背包装物品，求出所装物品的价值和最大值是多少。而最基础的想法，就是直接设状态$dp[i][j]$表示前i个物品中用大小为j的背包能得到的最大价值，转移也很明显$dp[i][j]=max\{dp[i-1][j-v[i]]+w[i]|v[i]\le j\le m\}$。我们发现每次转移只和上一行有关，于是可以用滚动数组优化空间。更仔细地观察发现，我们都是用前面的值去更新后面的值，于是我们改变j的枚举顺序，从大到小枚举，就可以只用一维数组来达到目的。这样的话空间复杂度$O(m)$，时间复杂度$O(nm)$ 123for (i = 1; i &lt;= n; ++i) for (j = m; j &gt;= v[i]; --j) dp[j] = max(dp[j], dp[j - v[i]] + w[i]); 完全背包完全背包就是在0/1背包的基础上对物品的个数没有限制，求相同的问题。其实只要我们把上面优化过的0/1背包改变枚举顺序，就是完全背包了，因为我们允许对同一个物品重复选择。123for (i = 1; i &lt;= n; ++i) for (j = v[i]; j &lt;= m; ++j) dp[j] = max(dp[j], dp[j - v[i]] + w[i]); 多重背包上面两种背包都是非常特殊的情况，更一般的，我们考虑每个物品i分别有$C[i]$个，那么问题就变成了多重背包。一种非常暴力的做法就是将$C[i]$个物品全部拆开，将问题变成0/1背包，这样的话时间复杂度是$O(\sum\limits_{i=1}^nC[i]m)$。这个复杂度是比较高的，那么有没有什么更好的办法呢？ 二进制拆分我们还是考虑将$C[i]$拆分，但我们采用更优秀的拆分方法，使得拆出来的物品尽量少，而且这些物品的组合可以表示$1\sim C[i]$中的任何一个数。我们考虑将其拆分成$C[i]=2^0+2^1+2^2+…+2^k+rest,rest&lt;2^{k+1}$，这样的话对于$x&lt;2^{k+1}$都可以很容易凑出，而对于$2^{k+1}&lt; x\le C[i]$，我们发现$x-rest&lt; 2^{k+1}$，也就是说$x-rest$是可以通过前面的部分组合出来的，因此我们可以组合出任意一个x。 123456//C进行拆分for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; (1 &lt;&lt; j) &lt;= C[i]; ++j) vt[++tot] = (1 &lt;&lt; j) * v[i], wt[tot] = (1 &lt;&lt; j) * w[i]; if (C[i])vt[++tot] = C[i] * v[i], wt[tot] = C[i] * w[i];&#125; 这样同样将问题转化成了0/1背包，但是时间复杂度更优秀，为$O(nm\log\max(C_i))$。 单调队列优化我们仔细观察转移的过程，寻找规律，来看看转移方程$dp[i][j]=\max\{dp[i-1][j],dp[i-1][j-k\cdot v[i]]+k\cdot w[i]|k\in [1,\min(\dfrac{m}{C[i]},C[i])]\}$我们发现，j mod v[i]相同时的j之间才会产生转移，于是我们可以按这个进行分组。而考虑到能转移到j的是区间$[j-C[i]*v[i],j]$的最大值，因此我们用复杂度优秀的单调队列来完成维护最大值的工作。那么总复杂度是多少呢？我们枚举了n类物品，对每类物品i分成C=v[i]类，枚举k的范围是$\dfrac{m}{v[i]}$，因此总复杂度为$O(nm)$ 1234567891011for (int i = 1; i &lt;= n; ++i) &#123; for (int ret = 0; ret &lt; v[i]; ++ret) &#123; head = 1, tail = 0; for (int k = 0; k * v[i] + ret &lt;= m; ++k) &#123; while (tail &gt;= head &amp;&amp; k - q[head] + 1 &gt; C[i])++head; dp[i][k * v[i] + ret] = dp[i - 1][q[tail] * v[i] + ret] + k * w[i]; while (tail &gt;= head &amp;&amp; dp[i - 1][q[tail] * v[i] + ret] &lt; dp[i][k * v[i] + ret])--tail; q[++tail] = k; &#125; &#125;&#125; 分组背包给定N组物品，规定每组物品中最多选一个，求大小为m的背包能装的最大价值。事实上我们只需要先枚举组，再枚举背包的容量，再枚举组内物品就行了。倒序枚举背包容量，空间复杂度降到一维。1234for (int i = 1; i &lt;= n; ++i) for (int j = m; j &gt;= 0; --j) for (int k = 1; k &lt;= C[i]; ++k) dp[j] = max(dp[j], dp[j - v[i][k]] + w[i][k]); 树上背包咕咕咕]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学（一）]]></title>
    <url>%2F2020%2F10%2F28%2F%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[裴蜀定理$a\cdot x +b\cdot y=c,x,y\in N_+$成立的充要条件是$\gcd(a,b)|c$该定理可推广至多个未知数方程。 GCDGCD就是最大公约数，最大公约数和最小公约数的求法都非常简单，这里直接给出求法。最大公约数：通常采用辗转相除法，也可以使用更相减损术。我们主要用辗转相除法（欧几里得算法）。gcd具有一些性质： $\gcd(a,b)=\gcd(-a,b)$ $\gcd(a,b)=\gcd(b,a\bmod b)$，这个性质应用于辗转相除法 $\gcd(a,b)=\gcd(b, a -b)$，这个性质应用于更相减损术 12345ll GCD(ll a, ll b) &#123; while (a %= b) swap(a, b); return a;&#125; exGCD扩展欧几里得定律，用于求解形如$a\cdot x+b\cdot y=\gcd(a, b)$的不定方程。下面我们来简单说明一下其原理：由性质2可知$\gcd(a,b)=\gcd(b,a\bmod b)$我们设$\gcd(b,a\bmod b)=b\cdot x’+(a\bmod b)\cdot y’$则有$a\cdot x+b\cdot y=b\cdot x’+(a\bmod b)\cdot y’$我们知道，$a\bmod b=a-b\cdot\lfloor \dfrac{a}{b}\rfloor$由此得$a\cdot x + b\cdot y=a\cdot y’+b\cdot(x’-\lfloor\dfrac{a}{b}\rfloor\cdot y’)$因此我们可以知道，$x,y$的一组可行解为$(x,y)=(y’,x’-\lfloor\dfrac{a}{b}\rfloor\cdot y’)$那么其边界条件是什么呢？我们知道，欧几里得算法执行到最后$a’\bmod b’=0$，即$a’$一定是$b’$的整数倍，所以在我们递归下一次时，$y’$的系数实际上变成了0，而$x’$的系数为$b’$，且$b’=\gcd(a,b)$，因此边界条件为$x=1,y=0$。 于是我们的解法就出来了，递归地实现欧几里得算法，当求到边界时设$x=1,y=0$，然后在回溯的过程中根据上述推导的公式一步步求解。 1234567891011//这里要采用递归写法，因为要回溯ll exGCD(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; ll gcd = exGCD(b, a % b, x, y), tmpx = x; x = y; y = tmpx - a / b * y; return gcd;&#125; 显然，这里我们求出了一组可行解，很容易得出该不定方程的通解为$x’=x_0+\dfrac{k\cdot b}{\gcd(a,b)},y’=y_0-\dfrac{k\cdot a}{\gcd(a,b)}$。得到这个结果后，我们可以推导出一般的二元一次不定方程解法。对于$a\cdot x+b\cdot y=c$，若$\gcd(a,b)\not|c$则无解，否则我们将$a\cdot x_0+b\cdot y_0=\gcd(a,b)$变形为 a\cdot\dfrac{x_0\cdot c}{\gcd(a,b)} + b\cdot \dfrac{y_0\cdot c}{\gcd(a,b)}=c由此可知$x_1=\dfrac{c\cdot x_0}{\gcd(a,b)},y_1=\dfrac{c\cdot y_0}{\gcd(a,b)}$我们设$d\in Q$，则$a\cdot(x_1+d\cdot b)+b\cdot(y_1-d\cdot a)=c$显然，$\min\{d\}=\dfrac{1}{\gcd(a,b)}$，设$d_x=d_{\min}\cdot b,d_y=d_{\min}\cdot a$，则通解形式为 x = x_1+k\cdot d_x\\ y = y_1+k\cdot d_y\\ k\in ZCRT中国剩余定理，用于求解一元模方程组，即模意义下的一元方程组（每个方程的模数不同）使用CRT的前提是所有模方程的模数互质即对于 \begin{cases} x\equiv a_1\pmod {m_1}\\ x\equiv a_2\pmod {m_2}\\ ...\\ x\equiv a_n\pmod {m_n}\\ \end{cases}其中$m_1,m_2,…,m_n$两两互质 我们定义$M=\prod m_i$考虑每一个方程，只要我们能求出$x_i$使得$x_i$是$M_i=\dfrac{M}{m_i}$的倍数且$x_i\equiv 1\pmod{m_i}$，那么最终结果就是$\sum a_i\cdot x_i\bmod M$然后我们考虑一下我们对$x_i$的定义，我们会惊奇地发现，实际上$x_i=M_i^{-1}\cdot M_i$，其中$M_i^{-1}$为$M_i$在模$m_i$意义下的逆元所以我们最终的解为$x=\sum a_i\cdot M_i^{-1}\cdot M_i\bmod M$，此处求的是x的最小正整数解，通解$x’=x + k\cdot M$。1234567891011121314151617181920212223242526272829303132ll m[N], a[N], M;ll mul(ll a, ll b) &#123; ll ans = 0; for (; b; a = (a &lt;&lt; 1) % M, b &gt;&gt;= 1) if (b &amp; 1) (ans += a) %= M; return ans;&#125;ll EXGCD(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; ll gcd = EXGCD(b, a % b, x, y), tmpx = x; x = y; y = ((tmpx - a / b * y) % M + M) % M; return gcd;&#125;ll CRT() &#123; ll ans = 0, x, y; M = 1; for (int i = 1; i &lt;= n; ++i) &#123; m[i] = fast_IO::read(), a[i] = fast_IO::read(); M *= m[i]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; ll Mi = M / m[i]; EXGCD(Mi, m[i], x, y);//m[i]互质，所以Mi与m[i]互质，满足exgcd的条件 (ans += mul(mul(a[i], x), Mi)) %= M; &#125; return ans;&#125; exCRTCRT的使用条件是m[i]互质，如果m[i]不互质，我们引入扩展中国剩余定理。注意，exCRT的解法是完全跳出CRT思想的，不要认为exCRT是CRT的升级版。首先我们来考虑只有两个模方程的模方程组 \begin{cases} x\equiv a_1\pmod{m_1}\\ x\equiv a_2\pmod{m_2} \end{cases}这两个方程显然可以写成 x=a_1+m_1\cdot y_1\\ x=a_2+m_2\cdot y_2所以有 a_1+m_1\cdot y_1=a_2+m_2\cdot y_2\\ a_1-a_2=m_2\cdot y_2-m_1\cdot y_1我们令$m_1\cdot a+m_2\cdot b=\gcd(m_1,m_2)$由裴蜀定理，当$\gcd(m_1,m_2)\not|(a_1-a_2)$无解，否则$y_1=-\dfrac{a_1-a_2}{\gcd(m_1,m_2)}\cdot a,y_2=\dfrac{a_1-a_2}{\gcd(m_1,m_2)}\cdot b$我们令$A=a_1+m_1\cdot y_1$，则该模方程组的解为$x\equiv A\pmod{ { \rm{lcm} } (m_1,m_2)}$这时候相当于我们将这两个模方程合并了，那么推广一下，对任意个数的模方程都可以这样合并。12345678910111213141516171819202122232425262728293031ll mul(ll a, ll b, ll p) &#123; ll ans = 0; for (; b; a = (a &lt;&lt; 1) % p, b &gt;&gt;= 1) if (b &amp; 1)(ans += a) %= p; return ans;&#125;ll exGCD(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; ll gcd = exGCD(b, a % b, x, y), tmpx = x; x = y; y = tmpx - a / b * y; return gcd;&#125;ll exCRT(int n) &#123; ll a1 = a[1], m1 = m[1]; for (int i = 2; i &lt;= n; ++i) &#123; ll a2 = (a[i] % m[i] + m[i]) % m[i], m2 = m[i]; ll del = ((a1 - a2) % m2 + m2) % m2 , x, y; ll gcd = exGCD(m1, m2, x, y); m2 /= gcd; if (del % gcd)return -1;//由裴蜀定理，无解 ll y1 = -mul(x, del / gcd, m2); a1 += m1 * y1; m1 = m1 * m2; a1 = (a1 % m1 + m1) % m1; &#125; return a1;&#125;]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串（一）]]></title>
    <url>%2F2020%2F10%2F28%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[哈希Hash是一种单射函数，将各种东西映射成一个整数值。字符串Hash就是指将字符串映射成一个整数值的方法，通常用于比较字符串是否相等。定义$H(S)$表示将字符串$S$通过方法$H$映射成的整数值。Hash并不能保证当$H(S)=H(T)$时$S=T$，当出现$H(S)=H(T),S\not=T$时我们称出现了哈希冲突，在构造Hash方法的时候要尽量避免哈希冲突。 我们常说的Hash字符串通常是指将字符串看成若干进制下的整数，然后将整数对一个比较大的质数取模后的结果作为哈希值，称为多项式取模Hash。根据生日悖论，模哈中使用的模数$Mod$最好超过Hash检验次数的平方。 常见哈希方法自然溢出利用unsigned long long 自然溢出，直接用Hash[i]=Hash[i-1]*p+idx(s[i])但$2^{64}$本身是一个合数，选择合数作为模数相当于选了很多小模数，若其因子中包含零点就会很容易构造哈希冲突。 单哈希自己规定模数，Hash[i]=(Hash[i-1]*p+idx(s[i]))%mod这里mod也为素数，且mod越大哈希冲突率越小但是单模Hash也有比较容易的方法构造Hash冲突。 双（多）哈希我们将同一个字符串用不同的模数哈希两（多）次构成一个pair，这样的话就更加保险。目前没有已知的比较好的方法构造多模哈希冲突。 子串的哈希值求出一个字符串的哈希值后，其子串的哈希值是可以O(1)求出的。 H(S[L,R])=\sum\limits_{i=L}^RS[i]\times B^{R-i}\pmod{Mod}令$F(i)=H(Prefix[i])$则 H(S[L,R])=F(R)-F(L-1)\times B^{R-L+1}KMPBorder如果字符串$S$的同长度的前缀和后缀完全相同，即$Prefix[i]=Suffix[i]$则称此前缀（后缀）为一个Boader，有时也把Boader的长度简称Boader。特别地，字符串本身也可以是它的Boader，视具体情况而定。 对于字符串$S$和正整数$p$，如果有$S[i]=S[i-p]$，对于$p&lt;i\le \left|S\right|$成立，则称$p$为字符串$S$的一个周期。若字符串$\left|S\right|$的周期$p$满足$p|\left|S\right|$，则称$p$为$\left|S\right|$的一个循环节。 重要性质： $p$是$S$的周期$\Leftrightarrow\left|S\right|-p$是$S$的Boader S的boader的boader也是S的boder 若$p,q$均为$S$的周期，则$(p,q)$也为$S$的周期 一个串的Boader数量是$O(n)$的，但他们组成了$O(\log n)$个等差数列 next数组定义$next[i]=Prefix[i]$的最大非平凡Boader，$next[1]=0$。 next的构建考虑$Prefix[i]$的所有长度大于1的Boader去掉最后一个字母以后，就是$Prefix[i-1]$的Boader。因此在求解$next[i]$的时候，我们只需要依次检查$next[i-1],next[next[i-1]],…,0$，看看其后面一个字符是否等于$S[i]$。 1234567891011121314nt[0] = -1, nt[1] = 0;for (int i = 2; i &lt;= lens; ++i) &#123; nt[i] = nt[i - 1]; while (nt[i] &amp;&amp; s[i] != s[nt[i] + 1]) nt[i] = nt[nt[i]]; if (s[i] == s[nt[i] + 1])++nt[i];&#125;或nt[0] = -1;i = 0, j = -1;while (i != lens) &#123; if (j == -1 || s[i] == s[j])nt[++i] = ++j; else j = nt[j];&#125; 复杂度分析上面的算法看上去是$O(n^2)$的，实际上它的复杂度是$O(n)$。考虑势能分析，我们求了$n$次$next$，每次的实际代价为$c_i=1$，设势能$\Phi(D_i)$为第$i$次操作时$Prefix[j]$的Boader数量。显然$\Phi(D_0)=0$，而$\Phi(D_i)\ge 0$，那么就总复杂度是$\sum c_i+\Phi(D_n)-\Phi(D_0)=n+\Phi(D_n)\le n+n$ 因此上面求next的算法的复杂度是$O(2n)$的。实际上，更通俗的理解是$Prefix[j]$的Boader的增加量一定大于等于减少量，而Boader的增加量不会超过$O(n)$，因此减少量也是$O(n)$的。 匹配考虑当匹配的过程中出现不匹配的情况时，t串用于匹配的前缀缩短直到能再次与s匹配，然后检查下一个位置，那么实际上再次匹配时是用前一次的Boader来匹配的，所以直接跳next就行了。复杂度分析与求next一模一样，都是$O(n)$。123456789101112i = j = 0;while (i &lt; lens) &#123; if (j == -1 || s[i] == t[j]) &#123; ++i; ++j;//匹配成功，继续匹配 if (j == lent) &#123; //这里成功匹配了一个完整的模式串 //进行相应操作 j = nt[j];//其实这里的nt[j]直接就是0了，从第一个开始配 &#125; &#125; else j = nt[j];&#125; 扩展KMP其实和KMP的推导差不多，求解的问题是$S$中的每一个后缀与$T$的最长公共前缀。12345678910111213141516171819void EXKMP(char s1[],char s2[]) &#123; int i = 0, j, po, len = strlen(s1), l2 = strlen(s2); getNext(s2); while(s1[i] == s2[i] &amp;&amp; i &lt; l2 &amp;&amp; i &lt; len)++i; extend[0] = i; po = 0; for(i = 1; i &lt; len; i++) &#123; if(nt[i - po]+i &lt; extend[po] + po) //第一种情况，直接可以得到extend[i]的值 ex[i] = nt[i - po]; else &#123; //第二种情况，要继续匹配才能得到extend[i]的值 j = extend[po] + po - i; if(j &lt; 0)j = 0; //如果i&gt;extend[po]+po则要从头开始匹配 while(i + j &lt; len &amp;&amp; j &lt; l2 &amp;&amp; s1[j + i] == s2[j])++j; extend[i] = j; po = i; //更新po的位置 &#125; &#125;&#125; Trie树Trie树即字典树，用树形结构存储多个字符串，构建方法其实很简单：从根节点开始往下找，如果有当前串的对应字符就走到下个点，否则开新节点，像这样录入所有的字符串即可。123456void insert(char *s) &#123; int now = root, len = strlen(s); for (int i = 0; i &lt; len; ++i) if (son[now][s[i]])now = son[now][s[i]]; else now = son[now][s[i]] = ++tot;&#125; 可持久化Trie树与主席树的思想类似，我们可以构造可持久化Trie树，也是考虑结构相同的Trie树可减，合并相同部分节省空间。12345678void insert(int pre. int &amp;now, char *s) &#123; now = ++tot; for (int i = 0; i &lt; 26; ++i) c[now][i] = c[pre][i]; sum[now] = sum[pre] + 1; if (!*s)return; insert(c[pre][*s], c[now][*s], s + 1);&#125; AC自动机KMP只支持单模式串的匹配，而AC自动机支持多模式串匹配。事实上，AC自动机就相当于将KMP的Border概念扩展到了多模式串上。AC自动机是一种离线数据结构。 构建我们将所有的模式串建成一棵Trie树，然后类似于KMP，我们要求fail指针。fail指针的求法与KMP求next类似，求某个点的节点就从它的父节点开始不断跳fail，直到匹配成功。复杂度分析依然是势能分析，以fail指针的深度增量为势能，显然总势能是$O(\sum\left|S\right|)$的，所以总复杂度是$O(\sum\left|S\right|)$的。 匹配至于匹配，类比KMP的匹配，每次匹配失败的时候就去跳fail链，直到匹配成功。而根据fail指针的含义，每个点的fail指针指向的字符串都是其本身的一个后缀，如果某个点代表的字符串匹配成功了，那么代表其向上的整条fail链都出现了一次。因此我们可以先标记每个点匹配成功的次数，然后在fail树上统计答案。 模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct ACAM &#123; int tot, c[N][26], fail[N], v[N], id[N], ans[N]; vector&lt;int&gt;to[N]; void insert(char s[], int x) &#123; int n = strlen(s), now = 0; for (int i = 0; i &lt; n; ++i) &#123; int to = s[i] - 'a'; if (!c[now][to])c[now][to] = ++tot; now = c[now][to]; &#125; id[x] = now; ++v[now]; &#125; void getfail() &#123; queue&lt;int&gt;q; q.push(0); while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int i = 0; i &lt; 26; ++i) &#123; if (!c[x][i])continue; int y = fail[x]; while (y &amp;&amp; !c[y][i])y = fail[y]; if (c[y][i] &amp;&amp; y != x)fail[c[x][i]] = c[y][i], to[c[y][i]].push_back(c[x][i]); else fail[c[x][i]] = 0, to[0].push_back(c[x][i]); q.push(c[x][i]); &#125; &#125; &#125; void dfs(int x) &#123; for (auto y : to[x]) &#123; dfs(y); ans[x] += ans[y]; &#125; &#125; void getans(char s[]) &#123; int n = strlen(s), now = 0; for (int i = 0; i &lt; n; ++i) &#123; int to = s[i] - 'a'; while (now &amp;&amp; !c[now][to])now = fail[now]; if (c[now][to]) &#123; now = c[now][to]; ++ans[now]; &#125; &#125; dfs(0); &#125;&#125;A; Border Series这是一个非常重要的性质：虽然长度为$n$的字符串的border可能有$n$个，但是如果我们把这些border按长度排序，那么它们可以构成$O(\log n)$个等差数列。]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>KMP</tag>
        <tag>AC自动机</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不讲道理算法]]></title>
    <url>%2F2020%2F10%2F28%2F%E4%B8%8D%E8%AE%B2%E9%81%93%E7%90%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[个人觉得分块和莫队都是相当暴力不讲道理的算法 分块首先来说说分块。顾名思义，把一段区间分成一块一块的。分成一块块的有什么好处呢？如果我们要进行区间修改区间查询，当这个区间中包含了整个块时，如果我们知道了这个块的一些信息，就没必要对块内的元素一个个进行修改或查询，如此就达到了降低复杂度的目的。于是分块的策略就很清楚了，对于当前操作的区间[L,R]，对于其中的整块我们整体修改或查询，而两边可能有的非整块元素则暴力修改，再将两端所属的块更新，这些元素个数显然不会超过两个块的大小，所以时间复杂度就有了保证。那么块的大小应该怎么确定呢？理论上，如果区间长度为$n$，则当块大小为$\sqrt{n}$时时间复杂度是最优的，每次操作复杂度为$O(\sqrt{n})$。123456789101112131415161718192021222324252627282930313233//以区间加和区间求和为例void update(int l, int r, ll data) &#123; if (bel[l] == bel[r]) &#123; for (int i = l; i &lt;= r; ++i) a[i] += data; block[bel[l]].sum += (r - l + 1) * data; return; &#125;//同一块直接改 for (int i = l; i &lt;= bel[l] * nbl; ++i) a[i] += data;//左边角 block[bel[l]].sum += (bel[l] * nbl - l + 1) * data; for (int i = bel[l] + 1; i &lt; bel[r]; ++i) block[i].sum += nbl * data, block[i].del += data;//中间整块 for (int i = (bel[r] - 1) * nbl + 1; i &lt;= r; ++i) a[i] += data;//右边角 block[bel[r]].sum += (r - (bel[r] - 1) * nbl) * data;&#125;//查询也类同ll query(int l, int r) &#123; ll ans = 0; if (bel[l] == bel[r]) &#123; for (int i = l; i &lt;= r; ++i) ans += a[i] + block[bel[i]].del; return ans; &#125; for (int i = l; i &lt;= bel[l] * nbl; ++i) ans += a[i] + block[bel[i]].del; for (int i = bel[l] + 1; i &lt; bel[r]; ++i) ans += block[i].sum; for (int i = (bel[r] - 1) * nbl + 1; i &lt;= r; ++i) ans += a[i] + block[bel[i]].del; return ans;&#125; 莫队莫队是在分块的基础上，更暴力的一种算法。对于只有查询的题目，我们可以通过移动l r指针，计算相应的添加或者删除某个元素得到的贡献来得到所有查询的答案，但是这样的话复杂度可能达到$n^2$。由于只有查询，我们可以将这些要查询的区间改变顺序，使得两个指针移动的距离尽量减少，从而达到降低复杂度的目的。考虑将整个区间分块，然后将所有查询进行双关键字排序，第一关键字为左端点所在的块，第二关键字为右端点本身。这样的话，对于左端点，在同一块内的转移每次不会超过$\sqrt{n}$，不同块之间的转移不会超过$\sqrt{n}$；对于右端点，在左端点在同一块时，右端点是单调不降的，即最多$n$，而在左端点不同块之间的转移不会超过$\sqrt{n}$因此总时间复杂度为$O(n\sqrt{n})$。1234567891011121314151617181920212223242526272829303132struct Query &#123; int l, r, id; Query() &#123;&#125; Query(int r, int l, int id): l(l), r(r), id(id) &#123;&#125; bool operator &lt;(const Query s)const &#123; return bel[l] &lt; bel[s.l] || (bel[l] == bel[s.l] &amp;&amp; r &lt; s.r); &#125;&#125;q[N];//双关键字排序void ins(int x) &#123; ... //此处对新加进来的元素计算贡献&#125;void del(int x) &#123; ... //此处删去某个元素的贡献&#125;int main() &#123; ... for (int i = 1; i &lt;= n; ++i)bel[i] = (i - 1) / *bel + 1; ... sort(q + 1, q + m + 1); int l = 1, r = 0; for (int i = 1; i &lt;= m; ++i) &#123; while (r &lt; q[i].r)ins(++r); while (l &gt; q[i].l)ins(--l); while (r &gt; q[i].r)del(r--); while (l &lt; q[i].l)del(l++); //直接移动l r指针计算贡献 ANS[q[i].id] = ans;//记录答案 &#125; for (int i = 1; i &lt;= m; ++i) printf("%lld\n", ANS[i]); return 0;&#125; 带修莫队带修莫队实际上就是在普通莫队的基础上增加一个时间轴，来表示修改的时间点。分块策略与普通莫队类似，还是先l r分块，然后还要对同一块内的修改排序(假设为单点修改)在移动完l r指针后，再去移动时间轴指针t，类似地进行相应修改，基本思想其实是一致的。123456789101112131415161718192021222324struct Node &#123; int l, r, pre, bh; inline bool operator &lt;(register Node s)const &#123; if (blo[s.l] ^ blo[l])return s.l &lt; l; if (blo[s.r] ^ blo[r]) return s.r &lt; r; return s.pre &lt; pre; &#125; //此处pre记录时间戳，即当前查询在第几次修改后&#125;q[N];...int main() &#123; ... for (int i = 1; i &lt;= m; ++i) &#123; while (r &lt; q[i].r)ins(++r); while (l &gt; q[i].l)ins(--l); while (r &gt; q[i].r)del(r--); while (l &lt; q[i].l)del(l++); while (now &lt; q[i].pre)change(++now); while (now &gt; q[i].pre)change(now--); //除了l r指针外还有now指针 ans[q[i].bh] = sum; &#125; ...&#125; 树上莫队树上莫队用于解决树上问题，我们将树上问题转化为序列问题，从而使用莫队求解。如何将一个树上的问题转化成一个序列问题呢？我们借助dfs序（括号序列）达到这一点。首先指定根，对于每个点x，我们记录其在dfs过程中第一次遇到时dfs序为st[x]，第二次遇到时dfs序为ed[x]，并记录这两个dfs序对应的点euler[st[x]]=euler[ed[x]]=x。不难发现，在dfs序组成的长度为2n的序列中，如果在某一段区间[l,r]内st[x]和ed[x]同时存在，那么x必然不在原树上euler[l]和euler[r]的最短路径中，且为其中某个节点的后代。由此我们就能联想到，记录当前区间x是否出现过，进行相应的加或减操作，就可以统计出路径上的真实情况，形象地理解的话考虑从一个点到另一个点的过程中，先走到了中间某个点的其他分支，再走回来，走过去的过程中我们将中间的点都计入贡献，而回来时再将其删掉，这样就保证了正确性。当然，上面给出的是一个相当模糊的概述，如果我们模拟一下就会发现，要分两种情况(设查询的点对为(x, y)，其中st[x] &lt; st[y])： LCA(x, y)为x，这时候只需要从ed[x]走到st[y]就可以了，从st[x]开始没有意义 LCA(x, y)不为x，这时候要注意，我们的区间[st[x], st[y]]中显然是不包括LCA的(为什么)，所以对于这个查询，我们还要记录下其LCA，在计算答案时将LCA计入答案，但是要记住，计入答案后要立刻删掉，不能影响到后面的答案计算，因为区间内实际上是没有LCA这个点的dfs序的。 下面给出树上数颜色的模板洛谷SP10707 COT2 - Count on a tree II1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283struct Query &#123; int l, r, lca, id; Query() &#123;&#125; Query(int l, int r, int lca, int id): l(l), r(r), lca(lca), id(id) &#123;&#125; bool operator &lt;(const Query s)const &#123; return block[l] &lt; block[s.l] || (block[l] == block[s.l] &amp;&amp; r &lt; s.r); &#125;&#125;q[N];void add(int x, int y) &#123; b[++num] = y, nt[num] = p[x], p[x] = num; b[++num] = x, nt[num] = p[y], p[y] = num;&#125;void dfs1(int x) &#123; sz[x] = 1; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x])continue; fa[k] = x; dep[k] = dep[x] + 1; dfs1(k); if (sz[son[x]] &lt; sz[k])son[x] = k; sz[x] += sz[k]; &#125;&#125;void dfs2(int x, int chain_number) &#123; st[x] = ++tot; euler[tot] = x; bel[x] = chain_number; if (son[x])dfs2(son[x], chain_number); for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x] || k == son[x])continue; dfs2(k, k); &#125; ed[x] = ++tot; euler[tot] = x;&#125;int LCA(int x, int y) &#123; while (bel[x] != bel[y]) &#123; if (dep[bel[x]] &lt; dep[bel[y]])jh(x, y); x = fa[bel[x]]; &#125; if (dep[x] &lt; dep[y])return x; return y;&#125;void del(int x) &#123; if (!--cnt[c[x]])--ans; &#125;void opt(int x) &#123; if (use[x])del(x); else if (!(cnt[c[x]]++))++ans; use[x] ^= 1;&#125;int main(void) &#123; int n = fast_IO::read(), m = fast_IO::read(); *block = sqrt(n &lt;&lt; 1); for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i)block[i] = (i - 1) / *block + 1; for (int i = 1; i &lt;= n; ++i)c[i] = Hash[i] = fast_IO::read(); for (int i = 1; i &lt; n; ++i)add(fast_IO::read(), fast_IO::read()); sort(Hash + 1, Hash + n + 1); *Hash = unique(Hash + 1, Hash + n + 1) - Hash - 1; for (int i = 1; i &lt;= n; ++i) c[i] = lower_bound(Hash + 1, Hash + *Hash + 1, c[i]) - Hash; dfs1(1); dfs2(1, 1); for (int i = 1; i &lt;= m; ++i) &#123; int x = fast_IO::read(), y = fast_IO::read(), lca = LCA(x, y); if (st[x] &gt; st[y])jh(x, y); if (lca == x)q[i] = Query(st[x], st[y], 0, i); else q[i] = Query(ed[x], st[y], lca, i); &#125; sort(q + 1, q + m + 1); int l = 1, r = 0; for (int i = 1; i &lt;= m; ++i) &#123; while (r &lt; q[i].r)opt(euler[++r]); while (l &gt; q[i].l)opt(euler[--l]); while (r &gt; q[i].r)opt(euler[r--]); while (l &lt; q[i].l)opt(euler[l++]); if (q[i].lca)opt(q[i].lca); ANS[q[i].id] = ans; if (q[i].lca)opt(q[i].lca); &#125; for (int i = 1; i &lt;= m; ++i) printf("%d\n", ANS[i]); return 0;&#125; 回滚莫队咕咕咕]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治（二）]]></title>
    <url>%2F2020%2F10%2F28%2F%E5%88%86%E6%B2%BB%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CDQ分治和整体二分都属于离线算法 CDQ分治CDQ分治的流程与普通分治的流程区别在于，当我们递归解决[L,M]和[M+1,R]区间后，除了将两个子区间的答案合并还要再加上右区间对左区间的贡献。CDQ分治主要用于求解偏序问题。 下面用一个简单的示例说明CDQ的基本思想。 CDQ分治求逆序数求逆序数实质是一个二维偏序问题，相当于一个由有序点对$(x,y)$组成的集合，求对于每个$(x_i,y_i)$有多少对$(x_j,y_j)$使得$x_i&gt;x_j且y_i&lt;y_j$的和。首先一个区间其下标必然是有序的，于是我们只用考虑用$y$如何进行统计。那么参照上面所说的CDQ分治的思想，我们分别计算左右区间的逆序对个数并求和，然后算出右区间对左区间的贡献，总和即为整个当前区间的逆序对数。 1234567891011121314151617181920ll CDQ(int *p, int len) &#123; //p开始的len个元素为当前区间，区间长度为len if (len == 1)return 0;//只有一个数显然逆序数为0 int mid = len &gt;&gt; 1; ll ans = CDQ(p, mid) + CDQ (p + mid, len - mid);//分治，左右区间分别求解 //此处应该将整个区间排序用双指针算出右区间对左区间的贡献，考虑到我们分治的过程 //我们可以直接在分治过程中通过归并排序来减少复杂度 int i = 0, j = mid, k = 0; while (i &lt; mid &amp;&amp; j &lt; len) &#123; if (p[i] &lt;= p[j])tmp[k++] = p[i++];//不构成逆序对 else &#123; ans += mid - i;//p[i]后面的数都比p[i]大，因此也比p[j]大，将这部分计入右区间对左区间的贡献 tmp[k++] = p[j++]; &#125; &#125; while (i &lt; mid)tmp[k++] = p[i++]; while (j &lt; len)tmp[k++] = p[j++]; for (int i = 0; i &lt; k; ++i)p[i] = tmp[i];//tmp存储的是归并后有序的区间，用其更新p return ans;&#125; 其他问题值得一提的是，通常在进行CDQ分治之前我们会将数组排序，来确保可以通过计算右区间中每个点对左区间的贡献来得到正确答案。对于多维偏序问题，我们依然可以使用CDQ分治，例如三维偏序，我们可以对第一维排序、第二维CDQ、第三维用数据结构或CDQ统计答案。来看一个三维偏序的问题。洛谷P3810 【模板】三维偏序（陌上花开）我们很容易就想到，先以a为第一关键字、b为第二关键字、c为第三关键字排序，每次将区间分成两半，这样左区间的a都是小于等于右区间的a的，这样我们只需要计算对右边每对(b,c)左边有多少对满足条件的(b,c)即可显然，b如果在两个区间内分别有序，我们的计算将会非常方便，用双指针扫一遍，若右区间的b大于等于左区间的b，则此时左区间的c就有可能对右区间的c产生贡献，因此我们用一个c值域上的树状数组维护当前有多少产生贡献的c，在右区间的b小于左区间的b时查询此时的贡献。但是这里存在一个问题，此处我们用CDQ分治，要求只能是左区间对右区间产生贡献，但如果有a b c相同的元素分别属于左右区间，这时候右区间对左区间也能产生贡献。而我们的解决方法就是在开始的时候就对整个数组进行去重操作，记录下每个元素的个数有多少，然后对不同元素间进行上述分治+树状数组求解，每个元素的答案再加上相同元素个数-1（其他所有元素都对他产生贡献）就是该元素真正的答案。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;#define jh(x, y) x ^= y ^= x ^= y#define lowbit(x) (x &amp; -x)const double pi = 3.141593;typedef long long ll;const int N = 2e5 + 5, INF = 0x3f3f3f3f, mod = 1e9 + 7;using namespace std;namespace fast_IO &#123; ll read() &#123; char c; ll x = 0; bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r' &amp;&amp; ~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; void write(ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;struct Node &#123; int a, b, c, tot = 0, cnt; Node() &#123;&#125; Node(int c, int b, int a): a(a), b(b), c(c) &#123;&#125; bool operator &lt;(const Node s)const &#123; return a &lt; s.a || (a == s.a &amp;&amp; (b &lt; s.b || (b == s.b &amp;&amp; c &lt; s.c))); &#125; bool operator !=(const Node s)const &#123; return a != s.a || b != s.b || c != s.c; &#125;&#125;a[N], tmp[N], b[N];int ans[N], n, k, c[N];void update(int x, int data) &#123; while (x &lt;= k) &#123; c[x] += data; x += lowbit(x); &#125;&#125;int query(int x) &#123; int ans = 0; while (x) &#123; ans += c[x]; x -= lowbit(x); &#125; return ans;&#125;void CDQ(Node *p, int len) &#123; if (len == 1)return; int mid = len &gt;&gt; 1; CDQ(p, mid); CDQ(p + mid, len - mid); int i = 0, j = mid, k = 0; while (i &lt; mid &amp;&amp; j &lt; len) &#123; if (p[i].b &lt;= p[j].b) &#123; update(p[i].c, p[i].cnt); tmp[k++] = p[i++]; &#125; else &#123; p[j].tot += query(p[j].c); tmp[k++] = p[j++]; &#125; &#125; while (j &lt; len) &#123; p[j].tot += query(p[j].c); tmp[k++] = p[j++]; &#125; for (int t = i - 1; ~t; --t)update(p[t].c, -p[t].cnt); while (i &lt; mid)tmp[k++] = p[i++]; for (int i = 0; i &lt; len; ++i)p[i] = tmp[i];&#125;int main(void) &#123; //freopen("1.in", "r", stdin); int cnt = 0; n = fast_IO::read(), k = fast_IO::read(); for (int i = 1; i &lt;= n; ++i) a[i] = Node(fast_IO::read(), fast_IO::read(), fast_IO::read()); sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] != a[i - 1])b[++cnt] = a[i], b[cnt].cnt = 1; else ++b[cnt].cnt; &#125; CDQ(b + 1, cnt); for (int i = 1; i &lt;= n; ++i)ans[b[i].tot + b[i].cnt - 1] += b[i].cnt; for (int i = 0; i &lt; n; ++i) printf("%d\n", ans[i]); return 0;&#125; 事实上，CDQ是可以不断套娃的，三维偏序问题还可以通过CDQ套CDQ来解决。第一层CDQ与上面的过程类似，只不过我们不需要进行树状数组的操作，只是在原来的update和query处打上tag标记，表示这个位置是计入答案或者统计答案。在排序完成后我们在CDQ内对同一区间进行第二层CDQ，此时的区间是以b为第一关键字，c为第二关键字排序后的结果，因此跟一层CDQ就非常类似的，唯独是在第二层CDQ中计入和统计答案时要注意第一层CDQ中打的标记，比如如果当前左区间的c小于等于右区间的c，但是第一层中并没有给他打标记，就说明当前右区间的元素实际上在第一层时是在左区间，于是就不能进行贡献统计。 123456789101112131415161718192021222324252627282930313233343536void CDQ2(Node *p, int len) &#123; if (len == 1)return; int mid = len &gt;&gt; 1; CDQ2(p, mid); CDQ2(p + mid, len - mid); int i = 0, j = mid, k = 0, sum = 0; while (i &lt; mid &amp;&amp; j &lt; len) &#123; if (p[i].c &lt;= p[j].c) &#123; sum += p[i].tag; tmp[k++] = p[i++]; &#125; else &#123; if (!p[j].tag)tt[p[j].tot] += sum; tmp[k++] = p[j++]; &#125; &#125; while (j &lt; len) &#123; if (!p[j].tag)tt[p[j].tot] += sum; tmp[k++] = p[j++]; &#125; while (i &lt; mid)tmp[k++] = p[i++]; for (int i = 0; i &lt; len; ++i)p[i] = tmp[i];&#125;void CDQ(Node *p, int len) &#123; if (len == 1)return; int mid = len &gt;&gt; 1; CDQ(p, mid); CDQ(p + mid, len - mid); int i = 0, j = mid, k = 0; while (i &lt; mid &amp;&amp; j &lt; len) &#123; if (p[i].b &lt;= p[j].b)tmp[k] = p[i], tmp[k++].tag = p[i++].cnt; else tmp[k] = p[j++], tmp[k++].tag = 0; &#125; while (j &lt; len)tmp[k] = p[j++], tmp[k++].tag = 0; while (i &lt; mid)tmp[k] = p[i], tmp[k++].tag = p[i++].cnt; for (int i = 0; i &lt; len; ++i)a[i] = p[i] = tmp[i]; CDQ2(a, len);&#125; 以此类推，其实无论多少维的偏序问题我们都可以通过CDQ套娃来解决。 整体二分咕咕咕]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>CDQ分治</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治（一）]]></title>
    <url>%2F2020%2F10%2F28%2F%E5%88%86%E6%B2%BB%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基本分治分治的基本思想是：将一个问题分成若干个子问题，对每个子问题进行求解，再将所有子问题的解合并得到问题的解。我们通过一个简单实用的例子来说明该类算法的思想。 归并排序尽管我们几乎不会手写归并排序，但其思想对分治的理解是很有帮助的。考虑我们需要排序的序列[1,n]，如果其子序列[1,mid]和[mid+1,r]都是有序的，我们怎么做才能将其合并成一个有序序列呢？我们用两个指针分别遍历两个子序列，每次将两个指针指向的元素中较小的那个元素加入新的序列，最终得到的序列就是有序的。于是我们的分治策略就出来了，对于序列[l,r]，先将其分成两半分别进行排序，再进行合并。显然合并操作每一层总时间是O(n)的，而每次将序列分半，最多分$\log n$次，所以总复杂度为$O(n\log n)$。这里我们就将合并一个序列的问题变成合并两个子序列的子问题，再将两个排好序的子序列进行合并，就得到了最终的有序序列。123456789101112131415void merge(int l, int r) &#123; if (l == r)return;//只有一个元素当然是有序的 int mid = l + r &gt;&gt; 1; merge(l, mid); merge(mid + 1, r);//分成两个序列，进行排序 int i = l, r = mid + 1, tot = l - 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (a[i] &lt; a[j]) b&#123;++tot] = a[i++]; else b[++tot] = a[j++]; &#125; while (i &lt;= mid)b[++tot] = a[i++]; while (j &lt;= r)b[++tot] = a[j++];//将其余元素放入当前序列 for (int i = l; i &lt;= r; ++i)a[i] = b[i];&#125; 树分治点分治现在，我们要对一棵树进行基于点的分治，首先选择一点作为当前无根树的根，将无根树化为有根树，再去递归地处理每一个与根连接的子树。那么问题来了，如何选点呢？显然，我们希望递归的层数尽量少，自然不能胡乱选点。在点分治中我们选择一棵树的重心作为根。何为重心？即将某个点删去后，剩余节点数量最多的树点的数量最少，则该点称为重心。重心可以DP求解，复杂度$O(n)$：dfs求得每个子树大小，选取一个根x删掉后，剩余树中节点最大值为$\max\{sz[y_1],sz[y_2],…,sz[y_n],sum-sz[x]\}$，从所有x中选择该最大值最小的节点作为根。 123456789101112void getrt(int x, int fa) &#123; sz[x] = 1; maxn[x] = 0; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa || vis[k])continue; getrt(k, x); sz[x] += sz[k]; maxn[x] = max(maxn[x], sz[k]); &#125; maxn[x] = max(maxn[x], sum - sz[x]); if (maxn[rt] &gt; maxn[x])rt = x;&#125; 那么，知道了如何找根，分治的过程怎么写呢？参考下面的模板 1234567891011121314void solve(int x) &#123; vis[x] = true;//我们用vis来标记已经搜过的根，以此来确定子树的边界 ... calc(x);//处理x处，也就是当前子树的答案 for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (vis[k])continue; sum = sz[k]; maxn[0] = INF; rt = 0; getrt(k, 0);//找到k子树中合适的根 solve(rt);//分治 &#125;&#125; 至于其中的calc怎么写，根据题目会有变化。 边分治]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论（二）]]></title>
    <url>%2F2020%2F10%2F28%2F%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[网络流甚么是网络流？在有向图G=(V, E)中： 有唯一的一个源点S（入度为0，为出发点） 有唯一的一个汇点T（出毒为0，为结束点） 图中每条弧(u, v)都有一个非负容量c(u, v) 满足上述条件的图G称为网络流图，记为$G=(V,E,C)$ 可行流每条弧(u, v)上给定一个实数f(u, v)满足：有$0\le f(u,v)\le c(u,v)$，则f(u, v)称为弧(u, v)上的流量。如果有一组流量满足条件： 源点s：流出量=整个网络流的流量 汇点t：流入量=整个网络流的流量 中间点：总流入量=总流出量 那么整个网络中的流量称为一个可行流。 最大流在所有的可行流中，流量最大的一个流（满足流量最大的可行流可能不止一个）的流量称为最大流。 求法最大流的求法非常多，最常用的应该是Dinic。Dinic算法是在FF/EK算法的基础上优化的。 Ford-Fulkerson算法在这里我们引入残余容量和增广路的概念：残余容量是指当前的网络流图中边的容量-边的流量，增广路则是指从源点到汇点的一条所有边的残余容量都不为0的路径。显然，直接去找增广路然后尽可能地增大流量这种做法是有问题的，比如下面这张图 如果我们找到的增广路是1-&gt;2-&gt;3-&gt;4，最终得到的答案是1，而显然这里1-&gt;3-&gt;4和1-&gt;2-&gt;4得到的答案是2。如何解决呢？对于每一条边我们都添上一条反向边，每当将某条边的流量增加时，增加其反向边的容量，增加的容量与增加的流量相同。为何正确？考虑上面那张图，我们无法求出正确答案无非就是因为3-&gt;4这条边满流了，而满流的原因是1-&gt;2流过了2-&gt;3，因此如果能从1-&gt;3流到2-&gt;4，相当于中间的2-&gt;3这条边根本就没有选到，也就是说，我们撤销了2-&gt;3中的一部分流量。简要概括就是，对于一条流量本不该那么大的边，我们可以通过连到尾端的边对其进行撤销的操作。 FF算法的复杂度是$O(Mf)$，用bfs实现的FF算法即Edmond-Karp算法的复杂度是$O(nm^2)$ Dinic算法在前面算法的基础上，就有了Dinic算法。我们每次将网络流图进行分层，每个点只能走到比这个点高一层的点，进行dfs找增广路，重复操作直到没有增广路。如何分层？如果一条边(u, v)的容量不为0，且v还没有被分层，那么v就是u的下一层。 模板123456789101112131415161718192021222324252627282930313233343536373839bool bfs() &#123; memset(dist, -1, sizeof(dist)); memset(flag, 0, sizeof(flag)); q[++tail] = st; dist[st] = 0; while (head &lt;= tail) &#123; int k = q[head++]; for (int e = p[k]; e; e = nt[e]) &#123; int kk = b[e]; if (w[e] &gt; 0 &amp;&amp; dist[kk] == -1) &#123; dist[kk] = dist[k] + 1; if (!flag[kk]) &#123; flag[kk] = true; q[++tail] = kk; &#125; &#125; &#125; &#125; return dist[ed] &gt; 0;&#125;int dfs(int x, int minv) &#123; if (x == ed)return minv; int flow = 0; for (int e = p[x], tmp; e &amp;&amp; minv; e = nt[e]) &#123; int k = b[e]; if (dist[k] == dist[x] + 1 &amp;&amp; w[e] &gt; 0 &amp;&amp; (tmp = dfs(k, min(w[e], minv - flow)))) &#123; w[e] -= tmp; w[e ^ 1] += tmp; flow += tmp; &#125; &#125; if (flow &lt; minv)dist[x] = -1; return flow;&#125;int Dinic() &#123; int ans = 0; while (bfs()) ans += dfs(st, INF); return ans;&#125; 上面的代码中有几处优化： flow表示当前点x流出的流量，显然在x处尽量流完可以避免走重复路 若最终x点流出的流量比增广路（准确说应该是多路增广路）上的流量小，后面一定不可能再增广到x点了，于是将这个点的分层去掉，相当于跳过这个点 还有一种当前弧优化，即在dfs过程中记录每个点增广到哪一条边，去更新前向星建图中的$first[x]$，这样是避免重复访问不必要的边，但通常优化不是很大，也没必要用。 最小割什么是最小割？就是一张网络流图，割掉一些边使得源点与汇点不连通，割掉的这些边的容量和的最小值。一个著名的定理：最大流=最小割。所以求最小割我们只需要求最大流就行了。 最小割的割边求出了最小割，我们还想知道具体是割了哪些边。只需要从源点沿着残量网络标记下所有经过的点，标记过的点和未标记过的点之间的连边就是割掉的边。1234567891011121314void dfs(int x) &#123; vis[x] = true; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (vis[k])continue; if (w[e])dfs(k); &#125;&#125;void getans() &#123; dfs(st); for (int i = 1; i &lt;= m; ++i) if (vis[edge[i].x] ^ vis[edge[i].y]) ans[++tot] = edge[i].id;&#125; 最小费用最大流最小费用最大流问题建立在最大流问题的基础之上，对每条边赋予一个单位流量的费用，问达成最大流时的最小总费用是多少。根据我们求最大流的方法，每次我们找出一条增广路，保证这条增广路上单位流量费用的和最小，产生的贡献即为$flow\cdot fee$。至于反向边的费用，自然是边的费用的相反数。 12345678910111213141516171819202122232425262728293031323334353637bool bfs() &#123; memset(dist, 0x3f, sizeof(int) * (n + m + 3)); memset(flag, 0, sizeof(bool) * (n + m + 3)); q[0] = st, dist[st] = 0; int head = 0, tail = 1; while (head != tail) &#123; int k = q[head++]; if (head == N)head = 0; flag[k] = false; for (int e = p[k]; e; e = nt[e]) &#123; int kk = b[e]; if (w[e] &gt; 0 &amp;&amp; dist[kk] - dist[k] &gt; f[e]) &#123; dist[kk] = dist[k] + f[e]; pre[kk] = e; if (!flag[kk]) &#123; flag[kk] = true; q[tail++] = kk; if (tail == N)tail = 0; &#125; &#125; &#125; &#125; return dist[ed] != 0x3f3f3f3f;&#125;int MCF() &#123; int maxflow = 0, mincost = 0; while (bfs()) &#123; int minn = INF; for (int i = ed; i != st; i = b[pre[i] ^ 1])minn = min(minn, w[pre[i]]); for (int i = ed; i != st; i = b[pre[i] ^ 1]) &#123; w[pre[i]] -= minn; w[pre[i] ^ 1] += minn; &#125; maxflow += minn; mincost += minn * dist[ed]; &#125; return mincost;&#125; 上下界网络流]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论（一）]]></title>
    <url>%2F2020%2F10%2F27%2F%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最短路最短路是非常常见的问题，求解方法和各种应用也很多，首先来看一些常用的、基本的最短路求法。 FloydFloyd是一种用DP求解最短路的方法，基本思想就是；对于每个起点和终点，枚举中间点，进行状态转移。转移方程为$d_{x,y}=\min\{d_{x,k}+d_{k,y}|1\le k\le n\}$其时间复杂度为$O(n^3)$，主要用来求任意两点间的最短路。除了Floyd算法，下面的其他最短路算法都是单源最短路的求解。12345for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (d[i][j] &gt; d[i][k] + d[k][j]) d[i][j] = d[i][k] = d[k][j]; Bellman-Ford（SPFA）Bellman-Ford算法最核心的操作称为松弛操作，其思想为：用当前节点的最短路更新其连接点的最短路。朴素的Bellman-Ford算法非常暴力，直接遍历所有点进行松弛操作，直到没有点可以被松弛，这样做复杂度显然是非常高的，于是我们考虑用队列来进行优化，将所有更新过的点加入队列，每次取出一个点进行松弛，直到队列为空，这便是SPFA。 但是即使用队列优化过，SPFA依然复杂度很高，为$O(|V|\cdot|E|)$，只是大多数情况下可以跑得很快，利用网格图之类的特殊结构可以卡掉这种算法，所以如果题目中明显是没有负边的，求最短路的时候我们采用别的方法。 1234567891011121314151617181920void spfa(int st) &#123; dist[st] = 0; queue&lt;int&gt;q; q.push(st); while (!q.empty()) &#123; int k = q.front(); q.pop(); flag[k] = false; for (int e = p[k]; e; e = nt[e]) &#123; int kk = b[e]; //下面是松弛操作，由于dist初始化值较大，我们将不等式变形 if (dist[kk] - dist[k] &gt; w[e]) &#123; dist[kk] = dist[k] + w[e]; if (!flag[kk]) &#123; q.push(kk);//kk不在队列中则入队 flag[kk] = true; &#125; &#125; &#125; &#125;&#125; 负环判定SPFA有一个好处（大概是唯一一个）就是不怕负边以及可以判定负环，判定方法也很简单，我们可以记录每个点入队的次数，如果这个次数达到了总节点数说明图中存在负环。 差分约束系统差分约束系统用于将不等式问题转换成最短路问题并求解，我们对于不等式$a-b\ge c$连边a to b，边权为-c，表示的是从a到b至少需要减少c，那么求完最短路后，a与b的差就是大于等于c的。以下不等式都可以变成上述形式建边：$a - b &gt; c即a-b\ge c+1$$a-b\le c即b-a\ge -c$$a-b &lt; c即b-a\ge -c+1$$a-b=c即a-b\ge c且b-a\ge -c$$a-b\not= c即b-a\ge-c + 1或a-b\ge c + 1$ 然后我们跑一遍SPFA，如果出现负环说明无解，否则我们可以跑出一组解。 上模板洛谷P5960 【模板】差分约束算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546int dist[N], num, p[N], b[N], nt[N], w[N], de[N], in[N], n, m;bool flag[N];void add(int x, int y, int z) &#123; b[++num] = y, w[num] = z; nt[num] = p[x], p[x] = num;&#125;void spfa(int st) &#123; dist[st] = 0; queue&lt;int&gt;q; q.push(st); while (!q.empty()) &#123; int k = q.front(); q.pop(); flag[k] = false; for (int e = p[k]; e; e = nt[e]) &#123; int kk = b[e]; if (dist[kk] - dist[k] &gt; w[e]) &#123; dist[kk] = dist[k] + w[e]; if (!flag[kk]) &#123; q.push(kk); flag[kk] = true; if (++in[kk] &gt; n) &#123; puts("NO");//出现负环 exit(0); &#125; &#125; &#125; &#125; &#125;&#125;int main() &#123; n = fast_IO::read(), m = fast_IO::read(); for (int i = 1; i &lt;= m; ++i) &#123; int a = fast_IO::read(), b = fast_IO::read(), c = fast_IO::read(); add(b, a, c); //a - b &lt;= c //化为b - a &gt;= -c //根据前面的结论，连边b-&gt;a，边权为c &#125; memset(dist, 63, sizeof(dist)); for (int i = 1; i &lt;= n; ++i)add(n + 1, i, 0);//超级源连上所有点 spfa(n + 1);//跑最短路 for (int i = 1; i &lt;= n; ++i) fast_IO::write(dist[i]), putchar(' '); return 0;&#125; DijkstraFloyd是如此之慢！SPFA也是如此之慢！那么我们怎么求点数和边数在1e5级别的单源最短路呢？我们使用Dijkstra算法来解决这样的问题，Dijkstra本质是贪心和BFS求最短路，其基本思想是保证每个点只能遍历一次，每次去找dist最小的点对其连接的点进行更新。更具体地，将Dijkstra算法过程描述为：从源点的dist=0开始，每次取出优先队列中最小的点并打上标记，对其连接的点进行更新，然后将其连接的没有打标记的节点加入优先队列，重复操作直到优先队列为空。如何说明其正确性呢？直观来看确实很难说明，但我们可以用反证法来简单证明。假设点x在出队后优先队列中还有点y可以使dist[x]减小，那么dist[y]必然小于dist[x]，而根据优先队列的性质，dist[x]大于等于x出队后优先队列内任何一点的dist值，即$dist[x]\ge dist[y]$，矛盾。因此可以保证x出队后其dist值是最小的。 12345678910111213141516171819202122232425struct Node &#123; int bh; ll dist; Node()&#123;&#125; Node(int bh, ll dist): bh(bh), dist(dist) &#123;&#125; bool operator &lt;(const Node s)const &#123; return dist &gt; s.dist; &#125;&#125;;priority_queue&lt;Node&gt;q;void dijkstra(int st) &#123; //dist初始化为较大值 dist[st] = 0; q.push(Node(st, 0)); while (!q.empty()) &#123; Node k = q.top(); q.pop(); if (flag[k.bh])continue; flag[k.bh] = true; for (int e = p[k.bh]; e; e = nt[e]) &#123; int kk = b[e]; if (dist[kk] - dist[k.bh] &gt; w[e]) &#123; dist[kk] = dist[k.bh] + w[e]; if (!flag[kk])q.push(Node(kk, dist[kk])); &#125; &#125; &#125;&#125; Tarjantarjan是非常实用的图论算法，使用tarjan可以解决很多图论问题。 强连通分量首先我们来看tarjan的一个经典应用：求有向图强连通分量（联通块）。强连通分量，即图的一个子集，其中每个点都可以到达其他任意一个点。要想搞清楚tarjan算法，主要是要弄明白这两个数组有何作用、如何实现：dfn和low其中dfn[x]较为简单，其含义为x的搜索序，你也可以理解为dfs过程中x的时间戳。重点需要理解的是low[x]的含义，一般来说我们描述为“他表示从x处开始搜索，能走到的最小的搜索序是多少。”但实际上这个说法是比较含糊的，与x连接的某个点为k，则从x处开始搜索时不能搜回fa处，且若k在此前其在x后已经搜索过，则不再继续搜索，并用dfn[k]更新low[x]的值， 而对于其他连接的节点，需要取其low最小值。对于k，我们用其dfn值更新x的low值的原因是，从x处能搜到曾经搜过的k，那么从k开始就有可能存在一个强联通块包含了x，因此我们将x的low值更新，再通过回溯时对low值的更新，一步步更新回k点，若low[k]与dfn[k]相等，就说明从k开始绕了一圈又找到了k，也就是说找到了强连通分量。那么如何对应地找到其中所有的节点呢？我们通过栈来实现，在dfs过程中，若遇到没搜过的点，则将其入栈，最后在low[x]=dfn[x]处，因为从x处最终能走回x，回溯到x时，途中的所有节点都在栈中，而中途可能遇到的分支都会在相同的过程中全部出栈（不在环中的自成一个强连通分量），因此从栈顶到栈中x的位置，中间的节点正好在一个强连通分量中，所以我们只需要不断弹栈，直到将x弹出栈，所有弹出的元素都归为一个强联通块中，可以证明，这样求得的强联通块是最大强联通块，将强联通块抽象成点，这便是缩点。 12345678910111213141516171819202122232425void tarjan(int x) &#123; dfn[x] = low[x] = ++tot; st[++top] = x; flag[x] = true;//在栈中 for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (!dfn[k]) &#123; tarjan(k); low[x] = min&#123;low[x], low[k]);&#125; &#125; else if (flag[k])low[x] = min(low[x], dfn[k]); //从某点出发的路径中有k（因为k还在栈中），则可能会成环。 &#125; if (dfn[x] == low[x]) &#123; //相等则成环 ++totltk;//联通块数量+1，也表示了当前联通块数量 while (st[top + 1] != x) &#123; ltk[st[top]] = totltk; f(totltk, x);//可能通过x对联通块内进行一些信息的统计 flag[st[top]] = false;//标记出栈 --top; &#125; //将栈中元素弹出至x也被弹出 &#125;&#125; 割点（割顶）理解了如何计算并使用dfn及low后，我们来看如何求无向图的割点。割点指的是若将联通无向图中的某点及其连接的边删去后，图中连通分量个数增加，则称这个点为割点。其中求dfn与low的过程与求强连通分量的过程基本相同，但我们不需要使用栈，对于任何一个走过的点我们都用其dfn值更新x的low值，至于具体原因，首先我们需要知道怎么求出割点。对于x，假设其从fa搜索过来，连接着某点k，则若low[k]==dfn[x]，说明x为割点。为什么呢？因为如果将x删掉，k与fa必然不属于同一个联通块，若删掉x后k与fa属于同一个联通块，那么low[k]必然会小于dfn[x]，这也就是为什么我们对每个走过的点都用其dfn值更新x的low值，就是为了保证求出的割点一定能保证k与fa不在任何同一个联通块中。然后我们就会考虑到一个特殊的点：第一个搜索的点，这个点是没有fa的。那么如何确定第一个点是不是割点呢？我们记录第一个点被包含在多少个最大的除去x后的联通块中，其实也就是在第一个点进行连接点的遍历时，若该点没有访问过则算入记录，这个应该比较显然，那么只要这个记录比1大，就说明将x删去后会产生多个联通块，即x为割点。于是我们的算法就出来了123456789101112131415void tarjan(int x, int fa) &#123; dfn[x] = low[x] = ++tot; int child = 0 ; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (!dfn[k]) &#123; tarjan(k, x); if (low[k] == dfn[x] &amp;&amp; x != fa)gd[x] = true;//是割点 low[x] = min(low[x], low[k]); if (x == fa)child++;//统计我们要的东西 &#125; else low[x] = min(low[x], dfn[k]);//全部更新 &#125; if (child &gt;= 2)flag[x] = true;//是割点&#125; 另外，根据上述求法，我们还可以统计出断开点x后联通块增加的个数：对于第一个搜索的点，显然联通块增加的个数就是child - 1；对于其他的点，联通块增加的个数应当是x被判为割点的次数。1234567if (low[k] == dfn[x] &amp;&amp; x != fa)gd[x] = true;改为if (low[k] == dfn[x] &amp;&amp; x != fa)++delta[x];if (child &gt;= 2)flag[x] = true;改为if (child &gt;= 2)delta[x] = child - 1; 桥在无向图中，若删去某边使得图的联通块数量增加，则该边称为桥。桥的求法非常简单，根据其定义，只要删去该边联通块数量增加的就是桥，因此在tarjan的过程中，若我们通过某条边找到的low值比dfn[x]大，说明该边就是桥。1234567891011121314151617181920212223void tarjan(int x) &#123; dfn[x] = low[x] = ++*dfn; st[++*st] = x; flag[x] = true; for (int e = p2[x]; e; e = nt2[e]) &#123; int k = b2[e]; if (vis[e])continue; if (!dfn[k]) &#123; vis[e] = vis[e ^ 1] = true;//考虑到可能有重边，这里我们标记边而不是点 tarjan(k); vis[e] = vis[e ^ 1] = false; low[x] = min(low[x], low[k]); if (low[k] &gt; dfn[x])can[id2[e]] = true; &#125; else if (flag[k])low[x] = min(low[x], dfn[k]); &#125; if (low[x] == dfn[x]) &#123; while (st[*st + 1] != x) &#123; flag[st[*st]] = false; --*st; &#125; &#125;&#125; （点/边）双连通分量强连通分量的概念是针对有向图的，对于无向图，我们称任意两点存在至少两条点不重复的路径的极大子图为点双连通分量，任意两点存在至少两条边不重复的路径的极大子图为边双连通分量。每一个点双连通分量中没有割点，每一个边双连通分量中没有桥。边双连通分量的求法比较简单，只需要去掉所有桥得到的就是边双连通分量。点双连通分量模板：12345678910111213141516171819void tarjan(int x, int fa) &#123; dfn[x] = low[x] = ++tot; st[++top] = x; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa)continue; if (!dfn[k]) &#123; tarjan(k, x); low[x] = min(low[x], low[k]); if (low[k] &gt;= dfn[x]) &#123; ++cnt; while (st[top + 1] != k) ltk[st[top--]] = cnt; ltk[x] = cnt; &#125; &#125; else low[x] = min(low[x], dfn[k]); &#125;&#125; 圆方树在点双连通分量的概念下引出了圆方树。树作为一种特殊的图，在处理时会比一般的图容易得多。如果我们能将一张无向图转化成树来进行处理将会更为方便，而圆方树就可以做到这一点。在圆方树中，原图中的每一个点对应圆方树中的圆点，对每一个点双连通分量建立一个方点，由每一个方点向其连通分量内的圆点连边，对不属于任何连通分量的边单独建立方点连接边的两端，这样就构成了一棵圆方树。如果原图是连通的，则最后建出来的圆方树就是一棵树。根据上面的描述，圆方树的建立可以在求点双的过程中完成。1234567891011121314151617181920void tarjan(int x, int fa) &#123; dfn[x] = low[x] = ++tot; st[++*st] = x; for (auto k : to[x]) &#123; if (k == fa)continue; if (!dfn[k]) &#123; tarjan(k, x); low[x] = min(low[x], low[k]); if (low[k] &gt;= dfn[x]) &#123; ++cnt;//创建方点 while (st[*st + 1] != k) &#123; add(cnt, st[*st]); --*st; &#125; add(x, cnt); &#125; &#125; else low[x] = min(low[x], dfn[k]); &#125;&#125;]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>tarjan</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构（三）]]></title>
    <url>%2F2020%2F10%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[平衡树Treap（单旋）咕咕咕 可持久化Treap咕咕咕 Splay（双旋）在理解splay的操作前，首先要搞清楚splay维护的是怎样的一棵树。这棵树是一棵二叉树，它最大的特点就是，对于每个节点k，k上的权值一定大于左子树的最大权值且小于右子树的最小权值。 首先来看splay的核心操作：旋转和双旋旋转操作，意在将节点x旋转到原本x父节点f所在的位置，那么会影响到的节点就有：x和f、x的孩子节点k1或k2、f的父亲节点gf。先看gf，gf原本的孩子节点f变成了x，只用将x放到原本f所在的位置就行；再看k1 k2，如果x是f的左孩子，那么f的权值就比x大，f应当到原本x的右孩子k2处，而k2的权值是小于f的，因此k2就到了f的左儿子处，也就是原本x所在的位置，如果x是f的右孩子则是同理；最后看x和f，颠倒父子关系即可。于是乎，我们的旋转操作就能总结出来了：1234567891011121314void _rotate(int x) &#123;//将x旋转到原本x父节点的位置 int f = fa[x], gf = fa[f]; c[gf][f == c[gf][1]] = x;//将x放到原本f的位置 fa[x] = gf; int w = x == c[f][1];//w表示x是f的哪个孩子 c[f][w] = c[x][w ^ 1];//原本x所在的位置变成了x相反方向的孩子 fa[c[x][w ^ 1]] = f; c[x][w ^ 1] = f;//父子关系颠倒 fa[f] = x; pushup(f); pushup(x);//这里对f和x做一些更新，因为这两个节点表示的子树发生了变化 //当然，如果仔细想一下你会发现，在不断旋转的过程中，这个x会在下一次旋转中pushup //因此这里可以不写pushup(x)，而是写在splay操作完以后&#125; 在旋转的基础上，我们进行双旋操作。其实我们旋转的意义在于，将某个节点旋转到根节点来方便进行操作的同时，使树尽量平衡，从而降低复杂度。如果仅仅只是为了把节点放到根处操作，直接不停的旋转就行了，根本用不着splay。而我们的splay这里只有一处与直接旋转不同：如果gf、f和x成了一条直线，也就是说gf到f和f到x是同一个方向，那么我们可以先将f旋转，再将x旋转。因为这种情况下，f旋转上去时，x会被f带着向上走而不是成为gf的一个子树。通过这样的双旋操作，最终可以使得树的高度不至于太高，而是均摊$\Theta(\log n)$的水平。123456789101112void splay(int x) &#123; while (fa[x]) &#123;//fa[x]==0说明x已经到根节点了 int f = fa[x], gf = fa[f]; if (gf) if ((f == c[gf][0]) ^ (x == c[f][0]))//gf f x不在一条线上就为1 _rotate(x); else _rotate(f);//在一条线上就先转f _rotate(x);//再转x，一次循环的效果是将x转到了原本gf所在的位置 &#125; //pushup(x); rt = x;//根变成了x&#125; 有了这些以后，我们就可以去维护一个数集，最基本的操作就是添加、删除、查排名、查第k大数、找前驱后继等如果这个数集是区间的下标，通过给节点附上别的权值以及标记，可以实现对区间的各种操作，尤其包括区间翻转 LCT（动态森林）如果我们要维护一个森林，这个森林可以连边、删边，且操作后依然是森林，那么我们就可以使用LCT。而LCT实际上是基于实链剖分，与树链剖分类似的，我们将森林里的某些路径划分为实链，每个节点属于且仅属于一条实链。考虑到我们要动态维护森林，在这里我们使用平衡树（本人常用splay）来维护实链。那么LCT维护的这条链是怎样的？事实上，LCT维护的链是深度严格递增的，而splay的权值也就是深度，即每个节点x左儿子的深度比x小，右儿子的深度比x大。明白这些以后，我们再想，如何去动态维护这些链呢？ access操作这个操作是LCT的核心操作，其意义在于将某个点x与整棵树的根节点之间的路径划分成一条实链。为了达到这个目的，我们需要将路径上所有连的其他边都变为虚边，再将路径上的边划分为实边即可。下面的图片来自FlashHu的博客 这是原始的树的图像，但显然在我们的splay里面不会是这个样子比如说，这棵树可能实际上长这样 现在我们想把A与N划分成一条实链，首先当然是将N splay到当前实链的根，这样的话，断掉N-O就将深度大的节点（此处是O）全部断开，也就是变为了虚边。 再跳到此时N的父节点I，将I与N连起来（当然是连右儿子），自然就断开了原来的右儿子，也就是“其他的边（点）”。 是不是找到了什么规律呢？没错，只要不断往上跳，连上右儿子并断掉左儿子，最终就能构建A-N的splay出来。 那么代码其实就很简单了1234567void access(int x) &#123; for (int son = 0; x; x = fa[son = x]) &#123; splay(x); c[x][1] = son;//连在右儿子上 pushup(x);//对x做更新 &#125;&#125; 要特别注意的是，这里的fa维护的是原树的形状，而c维护的是splay的形状，要注意区分。 changert操作将根节点设为x仅仅只有access操作当然不够，如果我们想得到(x, y)的路径，我们还需要将x放到整棵树的根上，再在y处access。其实有了access，这个操作非常简单，只需要access(x),splay(x)就行了但这样会有一个问题，我们定义根为树中深度最小的节点，而此时的x显然是splay中深度最大的节点，所以我们需要进行区间翻转操作，这样就保证了x的深度为最小，也就是将x变为了根。 123456789void pushr(int x) &#123; swap(c[x][0], c[x][1]); r[x] ^= 1;&#125;//记得在splay前将所有标记下传！void changert(int x) &#123; access(x); splay(x); pushr(x);//将x所在splay翻转&#125; findrt操作查找x所在树的根节点access(x)，然后splay(x)，接着去找深度最小的点就行了。12345678int findrt(int x) &#123; access(x); splay(x); while (c[x][0]) x = c[x][0]; splay(x);//此处不影响正确性 return x;&#125; split操作将x与y之间的路径划分到同一个splay中前面提到过，只需要changert(x),access(y)即可12345void split(int x, int y) &#123; changert(x); access(y); splay(y);&#125; link操作将两个不在同一棵树的点连起来显然只需要将一个点变为根，连到另一个点上即可123456void link(int x, int y) &#123; changert(x); if (findrt(y) != x) fa[x] = y; //x和y不能在同一棵树中&#125; cut操作删除x到y的边先把x到y划到一个splay中，如果x与y相连直接删除即可123456789void cut(int x, int y) &#123; changert(x); access(y); if (findrt(y) == x &amp;&amp; fa[y] == x &amp;&amp; !c[y][0]) &#123; fa[y] = c[x][1] = 0; pushup(x); &#125; //findrt(y)==x说明x与y在同一棵树中，fa[y]==x&amp;&amp;!c[y][0]说明x与y相连&#125;]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构（二）]]></title>
    <url>%2F2020%2F10%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[树状数组树状数组用于维护前缀和，支持单点修改。树状数组的原理并不复杂：对于1 &lt;= i &lt; j &lt;= n，经过若干次i+=lowbit(i),j-=lowbit(j)，所得的i’和j’中必然会有唯一一对相等，所以我们只需要在修改时不断将a[i]加到c[i’]上，查询时将所有的c[i’]加起来就行了。下面简略地说明一下，为什么这样做是对的：首先，lowbit(x)指的是x在二进制下最低位的1，比如lowbit(3)=1,lowbit(4)=4,lowbit(6)=2。那么为什么一定会有i’和j’相等呢？当j的二进制位大于i时，设i二进制有k位，显然i’中会包含所有k’&gt;k,2^k’，也就是说，只要j将除最高位外所有的位都减成0，就会与某个i’相等。当j的二进制位等于i时，从高位往低位看，必然会有某一位k使得比k位以上i和j都是1，在第k位i是0而j是1，此时又要分两种情况： k位以下i全是0，那么只要j把k位一下全减掉，j’就与i相等 k位以下i有1，那么i’必然会有k位为1，k位以下全为0的情况，此时i’与j’相等 如此，就说明i’与j’必然会相等(注意:i’包含i,j’包含j)，且不难看出，按上述策略找出的i’和j’是唯一的一对。再来张树状数组的大致图像，帮助理解c[i]。 12345678910111213141516171819#define lowbit(x) (x &amp; -x)//为什么x &amp; -x就是x的最低位1呢？因为-x实际上是(~x) + 1，会使得x的最低位1为1，而比x高的位与x都相反void update(int x, int data) &#123; //将x位置加上data while (x &lt;= len) &#123; //len为区间长度 c[x] += data;//前面解释过c[x]的作用 x += lowbit(x); &#125;&#125;int query(int x) &#123; //查询x的前缀和 int ans = 0; while (x) &#123; ans += c[x]; x -= lowbit(x); &#125; return ans;&#125; 另外，对a的差分数组用树状数组可以实现a数组的区间修改和单点查询，只用update(l, delta),update(r+1, -delta)就行了。 树状数组的区间修改、区间查询树状数组也可以实现区间修改、区间查询。考察差分数组表示前缀和，即 \sum\limits_{i=1}^{n}a_i=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{i}d_j=\sum\limits_{i=1}^{n}(n-i+1)\cdot d_i=(n+1)\sum\limits_{i=1}^{n}\cdot d_i-\sum\limits_{i=1}^{n}i\cdot d_i前面的部分非常好维护，直接维护差分数组，后面的部分需要再维护一个$x\cdot d_x$1234567891011121314151617void update(int x, ll data) &#123; int k = x; while (x &lt;= n) &#123; c[x] += data;//维护差分数组 c2[x] += data * k;//维护x*d[x] x += lowbit(x); &#125;&#125;ll query(int x) &#123; ll ans = 0; int k = x; while (x) &#123; ans += (k + 1) * c[x] - c2[x]; x -= lowbit(x); &#125; return ans;&#125; 线段树线段树是一种非常常用的数据结构，且变化极多，这里先说最基础的线段树。线段树，顾名思义，将区间分成一段一段，来达到区间操作的目的，那么如何分段呢？考虑将区间[l,r]分成两半[l,mid]、[mid+1,r]，这样相当于将区间对半分，那么很显然，对每个区间都这样分段，最终的段数为$O(n\log n)$。当我们进行区间操作时，从最大的区间开始，以此去找对应要操作的区间： [l,r]包含在当前区间的左区间内，就接着往左区间走 [l,r]包含在当前区间的右区间内，就接着往右区间走 [l,r]跨过中间的分界线，那么左边操作[l,mid]，右边操作[mid+1,r] 如此反复，直到找到的区间与当前操作的区间完全相同，就进行操作。大致图像如下 另外，如果我们的区间操作涉及对区间的修改，如加减、乘除、改值，我们可以在找到的区间上打上懒标记，这样我们不用每次往下遍历完整棵线段树，当然，在遍历过程中要注意标记的下传，如果有多个标记要注意多个标记之间的关系，如乘标记不仅改变区间上的值，还改变标记的值。 洛谷P3373 【模板】线段树 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct Node &#123; int l, r; ll sum, add, mul = 1;&#125;tree[N &lt;&lt; 2];void pushup(int x) &#123; tree[x].sum = (tree[x &lt;&lt; 1].sum + tree[x &lt;&lt; 1 | 1].sum) % p; &#125;void build(int x, int l, int r) &#123;//建树 tree[x].l = l, tree[x].r = r; if (l == r) &#123; tree[x].sum = fast_IO::read() % p; return; &#125; int mid = l + r &gt;&gt; 1; build(x &lt;&lt; 1, l, mid); build(x &lt;&lt; 1 | 1, mid + 1, r); pushup(x);&#125;void pushdown(int x) &#123;//标记下传 if (tree[x].mul != 1) &#123; (tree[x &lt;&lt; 1].mul *= tree[x].mul) %= p; (tree[x &lt;&lt; 1 | 1].mul *= tree[x].mul) %= p; (tree[x &lt;&lt; 1].add *= tree[x].mul) %= p; (tree[x &lt;&lt; 1 | 1].add *= tree[x].mul) %= p; (tree[x &lt;&lt; 1].sum *= tree[x].mul) %= p; (tree[x &lt;&lt; 1 | 1].sum *= tree[x].mul) %= p; tree[x].mul = 1; &#125; if (tree[x].add) &#123; (tree[x &lt;&lt; 1].add += tree[x].add) %= p; (tree[x &lt;&lt; 1 | 1].add += tree[x].add) %= p; (tree[x &lt;&lt; 1].sum += (tree[x &lt;&lt; 1].r - tree[x &lt;&lt; 1].l + 1) * tree[x].add % p) %= p; (tree[x &lt;&lt; 1 | 1].sum += (tree[x &lt;&lt; 1 | 1].r - tree[x &lt;&lt; 1 | 1].l + 1) * tree[x].add % p) %= p; tree[x].add = 0; &#125;&#125;void update(int x, int l, int r, ll data) &#123;//添加加标记 if(tree[x].l == l &amp;&amp; tree[x].r == r) &#123; (tree[x].sum += (r - l + 1) * data % p) %= p; (tree[x].add += data) %= p; return; &#125; pushdown(x); int mid = tree[x].l + tree[x].r &gt;&gt; 1; if (r &lt;= mid)update(x &lt;&lt; 1, l, r, data); else if (l &gt; mid)update(x &lt;&lt; 1 | 1, l, r, data); else update(x &lt;&lt; 1, l, mid, data), update(x &lt;&lt; 1 | 1, mid + 1, r, data); pushup(x);&#125;void update2(int x, int l, int r, ll data) &#123;//添加乘标记 if (tree[x].l == l &amp;&amp; tree[x].r == r) &#123; (tree[x].mul *= data) %= p; (tree[x].sum *= data) %= p; (tree[x].add *= data) %= p;//别忘了加标记也要更新 return; &#125; pushdown(x); int mid = tree[x].l + tree[x].r &gt;&gt; 1; if (r &lt;= mid)update2(x &lt;&lt; 1, l, r, data); else if (l &gt; mid)update2(x &lt;&lt; 1 | 1, l, r, data); else update2(x &lt;&lt; 1, l, mid, data), update2(x &lt;&lt; 1 | 1, mid + 1, r, data); pushup(x);&#125;ll query(int x, int l, int r) &#123; if (tree[x].l == l &amp;&amp; tree[x].r == r)return tree[x].sum; pushdown(x); int mid = tree[x].l + tree[x].r &gt;&gt; 1; if (r &lt;= mid)return query(x &lt;&lt; 1, l, r); if (l &gt; mid)return query(x &lt;&lt; 1 | 1, l, r); return (query(x &lt;&lt; 1, l, mid) + query(x &lt;&lt; 1 | 1, mid + 1, r)) % p;&#125; 主席树（可持久化线段树）典例：区间第K大给定一个长度为n的区间，给出m次查询，每次给出l,r,k,查询[l,r]中第k大的值发明者原话：“对于原序列的每一个前缀[1···i]建立出一棵线段树维护值域上每个数出现的次数，则其树是可减的”这话啥意思呢？就是对于序列中每一个位置i，都建立一棵线段树，这个线段树的范围是序列的值域范围，维护的是1~i中值域中的每个数出现的次数，这样的话两棵线段树的结构是完全相同的，因此对应的位置可以相减，所以用树r减去树l-1得到线段树就是区间[l,r]对应的线段树。但是对每个位置都建立一棵线段树，空间复杂度$O(n^2\log n)$，太高了，而我们又发现，其实相邻两颗线段树有大量相同的部分，如果我们将这些相同的部分合到一起，就可以大大降低空间的负担。 之后查询第k大就好说了，如果左区间的数字个数c&gt;=k就往左区间找，否则在右区间找第k-c大 12345678910111213141516171819202122232425//先建立空树void build(int &amp;x, int l, int r) &#123; x = ++tot; if (l == r)return; int mid = l + r &gt;&gt; 1; build(c[x][0], l, mid); build(c[x][1], mid + 1, r);&#125;//建新树，但新树与前一棵树部分重合int update(int pre, int l, int r, int x) &#123; int now = ++tot;//只在需要的地方开节点，节省空间 c[now][0] = c[pre][0], c[now][1] = c[pre][1];//有一部分重合 sum[now] = sum[pre] + 1;//类似于前缀和 if (l == r)return now; int mid = l + r &gt;&gt; 1; if (x &lt;= mid)c[now][0] = update(c[now][0], l, mid, x);//左区间开新节点 else c[now][1] = update(c[now][1], mid + 1, r, x);//右区间开新节点 return now;&#125;int query(int pre, int now, int l, int r, int k) &#123; int mid = l + r &gt;&gt; 1, tmp = sum[c[now][0]] - sum[c[pre][0]];//tmp表示的是查询的[L,R]区间在值域[l,r]真正的数字个数 if (l == r)return l; if (tmp &gt;= k)return query(c[pre][0], c[now][0], l, mid, k); return query(c[pre][1], c[now][1], mid + 1, r, k - tmp);&#125; 李超线段树咕咕咕 扫描线咕咕咕 树链剖分树链剖分主要用于解决树上路径、子树相关问题。树链剖分的思想很简单：在树上划出一些链，使得每个节点都属于且仅属于一条链，记录链的顶部，那么只需要O(1)的时间就能处理整条链的信息，从而达到缩短时间的目的。如何划分这些链？我们采用轻重链剖分，也就是说，找到以节点x的子节点中子树大小最大的节点y（称为重儿子），将x和y划分到同一条链中。 这样的话，基本就可以保证我们划分出的链尽量长，从而减少的时间更多。树链剖分的代码实现比较麻烦，我们分步看。首先，来看看我们需要用到什么变量和数组。12345int sz[N],//子树的大小，用于求重儿子dep[N],//节点的深度bel[N],//节点所在链的顶部son[N],//节点的重儿子fa[N];//节点的父节点 我们需要求出每个点的重儿子以及深度，使用dfs。1234567891011121314//dfs1从根节点开始void dfs1(int x) &#123; sz[x] = 1;//本身大小是1 for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x])continue; fa[k] = x;//k父节点是x dep[k] = dep[x] + 1;//记录深度 dfs1(k); if (sz[k] &gt; sz[son[x]])son[x] = k; //找到sz最大的子树，令其为重儿子 sz[x] += sz[k];//所有子树的大小加本身就是x子树的大小 &#125;&#125; 到目前为止做的都是准备工作，接下来才是链的划分。123456789101112void dfs2(int x, int chain_number) &#123; bel[x] = chain_number;//chain_number存的就是当前链的顶部，也代表着这条链 if (son[x])//如果有子节点，将重儿子划分到同一条链中 dfs2(son[x], chain_number); for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x] || k == son[x])continue; //son[x]已经划分了，要跳过 dfs2(k, k); //由于我们是自顶向下dfs的，k与x又不属于同一条链，k所在的链顶部就是k本身 &#125;&#125; 至此，我们就完成了树链剖分，那么如何使用呢？比如，求LCA：123456789101112int LCA(int x, int y) &#123; //求x和y的LCA //x和y反复往上跳，直到跳到同一条链 while (bel[x] != bel[y]) &#123; if (dep[bel[x]] &gt; dep[bel[y]])swap(x, y); //我们希望x和y都尽量往上跳，这样最节省时间，于是我们就跳链顶部的dep较小的那个 x = fa[bel[x]];//从bel[x]链跳到另一条链 &#125; //最终x和y在同一条链上，dep小的那一个显然就是LCA if (dep[x] &lt; dep[y])return x; else return y;&#125; 那如果，要引入路径及子树内的修改、查询怎么办？我们当然希望同一条链上的东西可以一起操作，这样与x和y向上跳的步骤就是一致的，那么具体怎么办呢？考虑引入dfs序，在dfs2中，因为我们优先dfs了重儿子的分支，因此同一条链上的dfs序是连续的，同时，一棵子树内的dfs序显然也是连续的，因此我们可以在dfs序上建立线段树。12345678910111213141516171819void dfs2(int x, int chain_number) &#123; bel[x] = chain_number;//chain_number存的就是当前链的顶部，也代表着这条链 dfn[x] = ++tot;//x的dfs序 ct[x] = dfn[x];//x子树内最大的dfs序 if (son[x]) &#123;//如果有子节点，将重儿子划分到同一条链中 dfs2(son[x], chain_number); ct[x] = max(ct[x], ct[son[x]]); &#125; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x] || k == son[x])continue; //son[x]已经划分了，要跳过 dfs2(k, k); //由于我们是自顶向下dfs的，k与x又不属于同一条链，k所在的链顶部就是k本身 ct[x] = max(ct[x], ct[k]); &#125; //显然，从dfn[x]到ct[x]的dfs序对应的节点与x子树内的节点一一对应&#125;//其他操作都是与LCA类似的过程，对dfn[bel[x]]到dfn[x]进行操作，最后对dfn[x]到dfn[y] (dfn[x]&lt;=dfn[y])操作]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>可持久化</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构（一）]]></title>
    <url>%2F2020%2F10%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基本数据结构栈栈是一种遵循先进后出原则的数据结构，数据在同一端入栈和出栈。 手动实现如下：123456789int stk[100005], top;//stk用于存放栈内的数据，top为栈顶，入栈和出栈都是在栈顶进行操作void ins(int x) &#123; stk[++top] = x; //新加入一个元素x&#125;int del() &#123; return stk[top--]; //返回并删除一个元素， 出栈&#125; 是不是很简单呢？ C++的STL提供了stack给我们直接使用，它支持如下基本操作：123456stack&lt;dataType&gt;name;//创建一个元素类型为dataType的栈namename.top();//返回顶部元素的引用name.push(x);//将x压入栈中name.pop();//弹出栈顶元素name.size();//返回栈中的元素个数name.empty();//栈为空时返回true 单调栈在栈的基础上，我们规定元素出栈的顺序必须是单调不降或单调不增的，对栈内元素的顺序没有要求。对于单调不降的单调栈，入栈前把比要入栈的元素小的元素全部出栈。对于单调不增的单调栈，入栈前把比要入栈的元素大的元素全部出栈。12345678void ins(int x) &#123; //此处以单调不降的单调栈为例 while (top &amp;&amp; stk[top] &lt; x) &#123; fun(stk[top--]);//出栈的元素可能要进行一些操作 //top--出栈 &#125; stk[++top] = x;&#125; 队列队列是一种遵循先进先出原则的数据结构，数据在一端入队，在另一端出队。 手动实现如下123456789int q[100005], head = 1, tail;void ins(int x) &#123; q[++tail] = x; //从尾部入队&#125;int del() &#123; return q[head++]; //从头部出队&#125; C++的STL中同样提供了queue供我们使用，它支持如下基本操作：1234567queue&lt;dataType&gt;name;//创建一个元素类型为dataType的队列namename.front();//返回队列中第一个元素的引用name.back();//返回队列中最后一个元素的引用name.push(x);//x从队列尾部入队name.pop();//删除队列的尾部name.size();//返回队列中元素的个数name.empty();//队列为空时返回true 单调队列与单调栈不同，单调队列要求队内的元素要是单调不降或单调不增的，且队首队尾都可以进行出队操作，只有队尾可以进行入队操作。一般来说，单调队列会有一个限制的大小m，即最多只能有m个元素。单调队列主要用于维护不同段区间内的最值，每次元素要入队时，与单调栈类似地，要让一些元素出队。123456void ins(int x) &#123; //以单调不降的单调队列为例 while (head &lt;= tail &amp;&amp; q[tail] &lt;= x)--tail;//删除比x小的元素 q[++tail] = x;//x入队 while (tail - head &gt;= m)++head;&#125; 链表先鸽着 简单数据结构ST表ST表用于求静态区间最值，构建复杂度$O(n\log n)$，查询复杂度只有$O(1)$!那么ST表是怎么实现的呢？显然区间[L,R]的最值可以拆成[L,L+x]与[R-x+1,R]的最值取最值，只要L+x&gt;=R-x+1即可。那么我们考虑求对于区间内每个位置i，从i开始往后$2^k$个元素中的最值ST[i][k]，于是构建ST表的算法就出来了。123456//以求最大值为例//注意，这里ST[i][0]为位置i上本来的这个数for (int j = 1; j &lt;= log2(n) + 1; ++j) for (int i = 1; i + (1 &lt;&lt; j - 1) &lt;= n; ++i) ST[i][j] = max(ST[i][j - 1], ST[i + (1 &lt;&lt; j - 1)][j - 1]);//显然是两段的最值中取最值 查询也好说：1234int query(int l, int r) &#123; int k = log2(r - l + 1); return max(ST[l][k], ST[r - (1 &lt;&lt; k) + 1][k]);&#125; 并查集并查集用于维护集合的关系。普通的并查集操作非常简单，直接上代码。123456789//用fa[x]表示x所在的集合//fa[x]初始化为x本身int findf(int x) &#123; if (x == fa[x])return x;//fa[x] == x说明当前的x已经表示了一个最大的集合 return fa[x] = findf(fa[x]);//如果fa[x] != x说明当前的集合被包含在另一个集合里&#125;//如此就能找到x所在的集合fa[findf(x)] = findf(y);//将x所在的集合合并到y所在的集合 不难看出，findf最多递归小常数次，因此并查集的复杂度是非常小的。 带权并查集（扩展并查集）带权并查集即结点有权值的并查集，如果我们要维护元素之间可量化的属性，而且这种属性关系可以合并时，可以采用带权并查集。带权并查集中每个元素的权值通常描述其与祖先的关系。 探究结点与祖先的关系我们可以利用向量偏移。 例题题面 首先我们确定属性，设sum[x]为从x到x的祖先的区间和祭出好图 显然当roota!=rootb时，我们想要将roota和rootb合并，那么roota-&gt;rootb即sum[roota]是要更新的，可如何更新呢？根据向量运算我们知道，(roota,rootb)=(b,rootb)-(b,roota)=(b,rootb)-(a,roota)+(a,b)由此可得sum[roota]=sum[b]-sum[a]+w(a,b) 而当roota=rootb时，说明此时的区间通过前面的答案已经可以推出，只需要验证是否为真即可。显然此时(a,b)=(a,root)-(b,root)即s(a,b)=sum[a]-sum[b] 在找祖先的过程中，我们也需要对sum进行更新。另外，我们推出的表达式是sum[r]-sum[l]的形式，因此左端点还要-1。 123456789101112131415161718192021222324252627282930int fa[N], sum[N];int findf(int x) &#123; if (x == fa[x])return x; int y = fa[x]; fa[x] = findf(fa[x]); sum[x] += sum[y]; return fa[x];&#125;int main() &#123; int n, m; while (~scanf("%d%d", &amp;n, &amp;m)) &#123; for (int i = 0; i &lt;= n; ++i)fa[i] = i, sum[i] = 0; int ans = 0; while (m--) &#123; int l = fast_IO::read() - 1, r = fast_IO::read(), s = fast_IO::read(); int rtl = findf(l), rtr = findf(r); if (rtl == rtr) &#123; if (sum[l] - sum[r] != s) ++ans; &#125; else &#123; fa[rtl] = rtr; sum[rtl] = -sum[l] + sum[r] + s; &#125; &#125; fast_IO::write(ans); putchar('\n'); &#125; return 0;&#125; 可持久化并查集咕咕咕 优先队列（二叉堆）首先，优先队列并不是用队列实现的，一般我们用二叉堆来实现优先队列。那么什么是优先队列？就是队列中的元素被赋予的优先级，当我们访问优先队列时优先访问优先级高的元素。二叉堆，其实就是一棵二叉树，它满足父节点的优先级一定大于子节点的性质，换句话说，在二叉堆中，以任意节点x为根的子树中，x的优先级是最高的，这样的话，只要构建一个二叉堆，它的根节点就是优先级最高的点。12345678910111213141516171819202122232425262728293031323334//这里我们用一种比较方便的方法表示节点的左右孩子//x * 2表示x的左孩子，x * 2 + 1表示x的右孩子，可以证明这种表示方法是不会重复的//这样的话x / 2就可以表示x的父节点//f[x]表示x的优先级void shift1(int now, int len) &#123; //删除了堆顶，将一个优先级小的元素放到堆顶后，通过该操作维护堆的结构 //从顶向下去更新 int father = now , child = father &lt;&lt; 1; while (child &lt;= len) &#123; if (child &lt; len &amp;&amp; f[pq[child]] &lt; f[pq[child + 1]])++child; if (f[pq[child]] &gt; f[pq[father]])swap(pq[child], pq[father]); father = child, child &lt;&lt;= 1; &#125;&#125;void shift2(int now) &#123; //加入一个元素后，从加入的元素起向上更新，维护堆的结构 int child = now, father = child &gt;&gt; 1; while (father) &#123; if (f[pq[farther]] &gt;= f[pq[child]])break;//此时说明已经满足了堆的性质 //因为加入元素前堆是成立的，只有加入的元素破坏了堆的结构 swap(pq[father], pq[child]); child = father, father &gt;&gt;= 1; &#125;&#125;void add(int x) &#123; pq[++tot] = x; shift2(tot);&#125;dataType del() &#123; dataType x = pq[1]; pq[1] = pq[tot--];//将优先级小的放到堆顶 shift1(1, tot); return x;&#125; 手动实现起来相当麻烦，当然，C++的STL提供了priority_queue供我们直接使用，它支持以下基本操作：123456priority&lt;dataType&gt;pq;pq.top();//访问堆顶元素pq.push(x);//将x入队pq.pop();//将堆顶出队pq.size();//返回优先队列的元素个数pq.empty();//优先队列为空返回true 左偏树（可并堆）有些时候，我们需要将堆进行合并，这时候就用到左偏树。左偏树，左偏是啥意思？意思就是对于堆内任意一棵子树，其左子树中深度最小的叶子节点的深度要大于右子树中深度最小的叶子节点的深度，这样的话从整体上看，整棵树明显左边比较重。 具体实现：我们用并查集来维护不同的节点是否在同一个堆中，下面给出合并操作123456789101112int merge(int x, int y) &#123;//将y堆合并到x堆上，返回合并后的根节点 if (!x || !y)return x | y;//0当然是没有这棵树啦 if (f(x) &lt; f(y))swap(x, y);//f(x)表示x的优先级 //这时候就保证了x节点的优先级比y大，即y只能往x的子树合并，合并后x为根节点 rson[x] = merge(rson[x], y);//左偏树嘛，右子树比较轻，把y往右子树合并 if (dep[lson[x]] &gt; dep[rson[x]]) swap(lson[x], rson[x]); //永远保证rson[x]的最小深度比lson[x]的最小深度小，保证“左偏” dep[x] = dep[rson[x]] + 1;//x的最小深度 fa[lson[x]] = fa[rson[x]] = x;//x为根节点 return x;&#125; 合并自然不用说，如果要删除根节点，只需要合并左右子树就行了。]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>单调栈</tag>
        <tag>单调队列</tag>
        <tag>优先队列</tag>
        <tag>链表</tag>
        <tag>ST表</tag>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 1166D Cute Sequences]]></title>
    <url>%2F2019%2F05%2F18%2FCodeForces-1166D-Cute-Sequences%2F</url>
    <content type="text"><![CDATA[写篇题解祭一下因为脑子短路而逝去的几个小时 Description给定一个正整数$m$，定义一个正整数序列$x_1,x_2,x_3,…,x_n$，满足对于$2\le i\le n$有$x_i=x_{i-1}+x_{i-2}+…+x_1+r_i$，其中$1\le r_i\le m$现在给出$q$个询问，每个询问给出$a,b,m$，强制要求$x_1=a$，$x_n=b$，要求构造出一个长度不超过$50$的$x$序列 Input第一行一个正整数$q(1\le q\le 10^3)$表示询问数接下来$q$行，每行三个正整数$a,b,m(1\le a,b,m\le 10^{14},a\le b)$，意义见题面 Output没有合法序列输出$-1$有合法序列则先输出序列长度$k(k\le 50)$，然后$k$个数$x_1,x_2,…,x_k(1\le x_i\le 10^{14})$，其中$x_1=a,x_k=b$ Sample Input12325 26 23 9 1 Sample Output124 5 6 13 26-1 Solution又被sb题整弱智了.jpg很容易推出$b=2^{k-2}\cdot a+2^{k-3}\cdot r_2+…+2^{k-i-1}\cdot r_i+…+r_{k-1}+r_k$首先特殊情况是$a=b$，这时候直接输出$1\;a$考虑到$k$很小，先枚举长度$k$这时候$a$是确定的，因此可以先把$a$的部分减掉，同时把每个$r_i$都减$1$，这样来保证求出的$r_i$都是$\ge0$的，那么此时$0\le r_i\le m-1$定义$cha=n-2^{k-2}\cdot a-2^{k-2}$从$r_2$到$r_{k-1}$贪心考虑，系数大的尽量大，同时要注意不能超过$m-1$这样构造出来，最后剩余的$r_k=cha$如果在$m$以内，就是合法的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x &amp; -x)#define jh(x, y) x ^= y ^= x ^= y#define loc(x, y) (x - 1) * m + y#define rg register#define inl inline#define PI 3.141592654typedef long long ll;const int N = 6e2 + 5, INF = 0x3f3f3f3f, mod = 998244353;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r' &amp;&amp; ~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;ll r[N];int main(void) &#123; rg int q = fast_IO::read(); while (q--) &#123; rg ll a = fast_IO::read(), b = fast_IO::read(), m = fast_IO::read(); if (a == b) &#123; printf("1 %I64d\n", a); continue; &#125; rg bool can = false; r[1] = a; rg int len; for (rg int k = 2; k &lt;= 50 &amp;&amp; !can; ++k) &#123; rg ll cha = b - a * (1ll &lt;&lt; k - 2) - (1ll &lt;&lt; k - 2); if (cha &lt; 0)break; for (rg int i = 2; i &lt; k; ++i) r[i] = fast_IO::min(m - 1, cha / (1ll &lt;&lt; k - i - 1)), cha -= r[i] * (1ll &lt;&lt; k - i - 1); if (cha &lt; m) &#123; can = true, len = k, r[len] = cha; break; &#125; &#125; if (!can)puts("-1"); else &#123; rg ll sum = a; for (rg int i = 2; i &lt;= len; ++i)++r[i], r[i] += sum, sum += r[i]; fast_IO::write(len); for (rg int i = 1; i &lt;= len; ++i)putchar(' '), fast_IO::write(r[i]); putchar('\n'); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>思路</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ5480:路径的条数]]></title>
    <url>%2F2019%2F04%2F13%2FBZOJ5480-%E8%B7%AF%E5%BE%84%E7%9A%84%E6%9D%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Description给一棵$n$个点的有标号无根树，你需要找到满足条件的路径$u−v$的条数。我们称路径$u-v$满足条件当且仅当$u\not=v$且路径$u-v$上不存在点对$(a,b)$,$a,b$满足$gcd(a,b)=a$。注意：路径$u−v$和$v−u$是同一条路径。 Input第一行一个整数$n\le10^5$接下来$n−1$行，每行两个用空格隔开的整数$a,b$，表示边$(a,b)$ Output一行一个整数，代表要求的答案。 Sample Input43 13 23 4 Sample Output2//只有路径$2 − 3$和$3 − 4$满足条件 Solution这个题的转换很有意思我们考虑用总路径数-不合法的路径数来得到合法的路径数那么现在问题就在于，如何求不合法的路径数首先根据题意，枚举起点$u$，可以通过枚举$u$的倍数来得到一些不合法的路径，我们可以称之为“限制”，很容易得出：每一个不合法的路径必定至少包含一个“限制”知道这个有什么用呢？重头戏来了：设$dfn[x]$为$x$点的dfs序，$cover[x]$为$x$子树中最大的dfs序考虑不合法路径$a-b$，假设$a-b$包含路径$u-v$且$dfn[u]&lt;dfn[v]$，$dfn[a]&lt;dfn[b]$分两种情况讨论： $u$是$v$的一个祖先 $u$不是$v$的祖先 对于第一种情况这时候$a,b$和$u,v$有怎样的关系呢？我们来看下面这张图 这时我们发现，$a$可以是$g$子树外的任意一点，$b$可以是$v$子树内的任意一点，他们对应的dfs序关系为$dfn[a]$ $&lt;$ $dfn[g]\;\;and\;\;dfn[v]\le dfn[b] \le cover[v]$当然你可能会问：那如果我们先遍历图中$g$的那棵子树，上面这个关系就不成立了！（注意我们的前提条件，$a$的dfs序小于$b$）没错，所以我们还要讨论把上图中把$a,b$交换的情况，此时关系为$dfn[v]\le dfn[a] \le cover[v]\;\;and\;\;dfn[b] &gt; cover[g]$ 对于第二种情况这种情况相对较简单，还是先上图此时$a$是$u$子树中的任意一点，$b$是$v$子树中的任意一点所以对应的关系就是$dfn[u]\le dfn[a] \le cover[u]\;\;and\;\;dfn[v]\le dfn[b]\le cover[v]$ 说了这么多，这有什么用啊？ 考虑这样一个坐标系这个坐标系的横轴是$dfn[a]$，纵轴是$dfn[b]$再看看上面我们列出的条件，$dfn[a]$对应一个横轴上的区间，$dfn[b]$对应一个纵轴上的区间这不是矩形嘛！大致乱画一下，其实一堆条件（关系）就成了下面这个东西这些矩形内的每一个整点$(dfn[a],dfn[b])$，都是满足我们要求的东西，也就是不合法而每一个dfs序对应唯一节点，这样我们计算这些矩形内的整点个数就能得到不合法的路径数如何计算？线段树维护扫描线即可，只不过把求面积改成求矩形内点的个数，如果具体不清楚可以直接看代码，代码还算是比较简明的最终统计答案，由于我们这样求出的路径是无向的，设求出的路径数为$ans$答案就是$\dfrac{n*(n-1)}{2}-ans$ 复杂度：枚举$u,v$是$O(n\ln n)$的，线段树还要再乘个$\log n$，所以总复杂度应该是$O(n\ln n\log n)$ 最后献上本人丑陋的代码，现在是2019年3月28日22:06:10，目前在BZOJ是最快的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/************************************************************** Problem: 5480 User: Zechariah Language: C++ Result: Accepted Time:13152 ms Memory:193400 kb****************************************************************/ #include &lt;bits/stdc++.h&gt;#define lowbit(x) (x &amp; -x)#define jh(x, y) x ^= y ^=x ^= y#define loc(x, y) (x - 1) * m + y#define rg register#define inl inline#define PI 3.141592654typedef long long ll;const int N = 8e5 + 5, mod = 998244353, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;int cover[N], dfn[N], nt[N], b[N], p[N], num, id, fa[N][18], deep[N], tot, n;struct Node &#123; int left, right, min; ll sum;&#125;tree[N &lt;&lt; 2];struct Line &#123; int l, r, v, y; Line(rg int l = 0, rg int r = 0, rg int y = 0, rg int v = 0) :l(l), r(r), y(y), v(v) &#123;&#125; bool operator &lt;(const rg Line &amp;s)const &#123; return y &lt; s.y; &#125;&#125;e[N &lt;&lt; 2];inl void add(rg int x, rg int y) &#123; b[++num] = y, nt[num] = p[x], p[x] = num; b[++num] = x, nt[num] = p[y], p[y] = num;&#125;inl bool is(rg int x, rg int y) &#123; return dfn[x] &lt;= dfn[y] &amp;&amp; cover[x] &gt;= cover[y]; &#125;void dfs(rg int x) &#123; dfn[x] = ++id; for (rg int e= p[x]; e; e = nt[e]) &#123; if (b[e] == fa[x][0])continue; fa[b[e]][0] = x; deep[b[e]] = deep[x] + 1; dfs(b[e]); &#125; cover[x] = id;&#125;void build(rg int x, rg int l, rg int r) &#123; tree[x].left = l, tree[x].right = r; if (l == r)return; rg int mid = l + r &gt;&gt; 1; build(x &lt;&lt; 1, l, mid); build(x &lt;&lt; 1 | 1, mid + 1, r);&#125;inl void pushup(rg int x) &#123; if (tree[x].min)tree[x].sum = tree[x].right - tree[x].left + 1; else tree[x].sum = tree[x &lt;&lt; 1].sum + tree[x &lt;&lt; 1 | 1].sum;&#125;void update(rg int x, rg int l, rg int r, rg ll data) &#123; if (tree[x].left == l &amp;&amp; tree[x].right == r) &#123; tree[x].min += data; pushup(x); return; &#125; rg int mid = tree[x].left + tree[x].right &gt;&gt; 1; if (r &lt;= mid)update(x &lt;&lt; 1, l, r, data); else if (l &gt; mid)update(x &lt;&lt; 1 | 1, l, r, data); else &#123; update(x &lt;&lt; 1, l, mid, data); update(x &lt;&lt; 1 | 1, mid + 1, r, data); &#125; pushup(x);&#125;inl ll query() &#123; sort(e + 1, e + tot + 1); rg ll ans = 0; for (rg int i = 1; i &lt; tot; ++i) &#123; update(1, e[i].l, e[i].r, e[i].v); ans += tree[1].sum * (e[i + 1].y - e[i].y); &#125; return ans;&#125;inl int getfa(rg int x, rg int d) &#123; for (rg int j = 17; ~j; --j) if (d &amp; (1 &lt;&lt; j)) x = fa[x][j]; return x;&#125;inl void addedge(rg int x1, rg int x2, rg int y1, rg int y2) &#123; if (1 &lt;= x1 &amp;&amp; x1 &lt;= x2 &amp;&amp; x2 &lt;= n &amp;&amp; 1 &lt;= y1 &amp;&amp; y1 &lt;= y2 &amp;&amp; y2 &lt;= n) e[++tot] = Line(x1, x2, y1, 1), e[++tot] = Line(x1, x2, y2 + 1, -1);&#125; int main(void) &#123; n = fast_IO::read(); for (rg int i = 1; i != n; ++i)add(fast_IO::read(), fast_IO::read()); dfs(1); build(1, 1, n); for (rg int j = 1; j != 18; ++j) for (rg int i = 1; i &lt;= n; ++i) fa[i][j] = fa[fa[i][j - 1]][j - 1]; for (rg int i = 1; i &lt;= n; ++i) &#123; for (rg int j = i &lt;&lt; 1; j &lt;= n; j += i) &#123; rg int x = i, y = j; if (dfn[x] &gt; dfn[y])jh(x, y); if (is(x, y)) &#123; rg int node = getfa(y, deep[y] - deep[x] - 1); addedge(1, dfn[node] - 1, dfn[y], cover[y]); addedge(dfn[y], cover[y], cover[node] + 1, n); &#125; else addedge(dfn[x], cover[x], dfn[y], cover[y]); &#125; &#125; fast_IO::write((ll)n * (n - 1) / 2 - query()); return 0;&#125;]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>扫描线</tag>
        <tag>思路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day6]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day6%2F</url>
    <content type="text"><![CDATA[Day 6——字符串一、哈希（哈希）把信息量大的东西压缩成信息量小的表达。 例题一、给出两个排列$a,b$，长度分别为$n,m$，你需要计算有多少个$x$，使得$a_1+x,a_2+x,a_3+x,…,a_n+x$是$b$的子序列。$n\le m\le2\times 10^5$ 思路枚举$b$中与$a$匹配的最大值$x$，把$x-n+1$ 例题二、你可以通过交换字母来修改字符串。如果两个字符串经过这样的变换之后可以相等，则称它们相似。给出一个文本串$T$与一个模式串$P$，询问$T$中有哪些子串与$P$一模一样或相似。$|T|,|P|\le10^6$ 思路考虑如何判断两个字符串相似。记录$last_i$表示上一次出现$p_i$的位置，我们发现两个字符串的$last$数组相同，他们就是相似的。然后直接KMP比较（或者哈希）。 二、KMP求出$next$数组，$next_i$表示当第$i$个位置失配的时候，应该从后面的什么位置开始匹配。求最长公共前后缀，这样就可以求出$next$数组。 模板1234567891011121314151617181920212223242526272829char s[N], t[N];int nt[N];inl void getnext()&#123;//模式串与自己匹配求出next数组 rg int len = strlen(t), i = 0, j = -1; while (i &lt; len) &#123; if (j == -1 || t[i] == t[j])nt[++i] = ++j; else j = nt[j]; &#125;&#125;inl void kmp()&#123; getnext(); rg int lens = strlen(s),lent=strlen(t), i = 0, j = 0; while (i &lt; lens) &#123; if (j == -1 || s[i] == t[j]) &#123; ++i, ++j; if (j == lent) &#123; j = nt[j]; //此时[i-lent+1,i-1]的子串是与t串匹配的 &#125; &#125; else j = nt[j]; &#125;&#125; 例题一、给出一个长度为$n$的串$S$，判断$S$的每个前缀是不是循环串，如果是输出最大循环次数。循环串的定义：由一个相同的串重复至少两次拼成。$n\le10^6$ 思路如果一个串是循环串，那么这个串就是$m$个小串的拼接，他的$next$就是$m-1$个小串。由于$s_{1…next}$与$S_{n-next…next}$是相同的两串，那么只要$i\mod(i-next)=0$，那么该串是一个以$i-next$为最小循环节的串。 例题二、给出一个长度为$n$的串$S$，你需要选取$S$的一个前缀$T$，使得$T$重复若干次可以拼出$S$（拼合可以有部分重复，但是重复部分必须相同）。最小化$T$的长度$n\le10^6$ 思路根据$next$建出$fail$树，贪心即可。 三、AC自动机（Aho-Corasick automation）例题一、给出含有$n$个单词的词典，你需要计算对于所有长度为$m$的字符串，有多少个至少包含一个单词。字符集为大写字母。$n\le60,m\le100,$每个单词长度$\le100$ 思路建出AC自动机，将每个单词结尾设为不可通行，计算从根节点开始走$m$步的总方案数，用总字符串数$-$总方案数即可。 例题二、给出$n$个字符串和$m$个询问，每次询问$i,j,k,l$，求第$i$个串的$j$长前缀和第$k$个串的$l$长前缀的最长公共后缀。$\sum S_i\le10^6$ 思路建出AC自动机，求所求两个前缀在$fail$树上的LCA即可。 例题、三给定$n$个字符串$s_i$，问最多能从中选择多少个串，使得其中不存在一个串是另一个串的子串。$n\le750,\sum|s_i|\le10^7,s_i\in\left\{a,b\right\}$ 思路四、后缀数组（SA）模板1234567891011121314151617181920212223242526272829303132333435363738int rk[N], sa[N], b[N], m, n, tong[N], height[N];char s[N];inl void radix_sort()&#123; memset(tong, 0, sizeof(tong)); for (rg int i = 1; i &lt;= n; ++i)++tong[rk[b[i]]]; for (rg int i = 1; i &lt;= m; +i)tong[i] += tong[i - 1]; for (rg int i = n; i &gt;= 1; --i)sa[tong[rk[b[i]]]--] = b[i];&#125;inl void getsa()&#123; for (rg int i = 1; i &lt;= n; ++i)rk[i] = s[i] - 'a' + 1, b[i] = i; radix_sort(); for (rg int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; rg int tot = 0; for (rg int i = n - k + 1; i &lt;= n; ++i)b[+tot] = i; for (rg int i = 1; i &lt;= n; ++i)if (sa[i] &gt; k)b[++tot] = sa[i] - k; radix_sort(); memcpy(b, rk, sizeof(b)); rk[sa[tot = 1]] = 1; for (rg int i = 2; i &lt;= n; ++i) if (b[sa[i]] == b[sa[i - 1]] &amp;&amp; b[sa[i] + k] == b[sa[i - 1] + k])rk[sa[i]] = tot; else rk[sa[i]] = ++tot; if (tot == n)break; m = tot; &#125;&#125;inl void getheight()&#123; rg int k = 0; for (rg int i = 1; i &lt;= n; ++i)rk[sa[i]] = i; for (rg int i = 1; i &lt;= n; ++i) &#123; if (rk[i] == 1)continue; rg int j = sa[rk[i] - 1]; while (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; s[j + k] == s[i + k])++k; height[rk[i]] = k; &#125;&#125; 例题一、给出$n$个串，找出一个最长的子串，至少在$\dfrac{n}{2}$个串中出现过。$\sum S_i\le10^5$ 思路将所有字符串拼起来，求$SA$和$Height$，做滑动窗口，求RMQ。 结论一个字符串的不同子串个数为$\dfrac{n(n-1)}{2}\sum\limits_{i=1}^{n}Height_i$ 例题二、给出一个小写字符串$S$以及$m$个询问，每个询问给出两个正整数$x,y$（$x\le y\le$字符串$S$本质不同的子串个数），表示询问$s$的所有本质不同的子串中，字典序排名为$x$到$y$之间的所有字符串的哈希值总和（包括$x$和$y$）。$|S|,m\le10^5$ 思路考虑转化为对前缀的查询，避免对两个子串的相同前缀重复计算，我们只用对不相同的部分二分求 例题三、给出一个字符串，将其划分为不超过$k$个连续子串。设第$i$个子串为$s_i$，对于每个$s_i$，找到其中字典序最大的连续子串$c_i$。你需要找到一种划分，使得字典序最大的$c_i$字典序最小。$|S|\le10^6$ 思路二分字典序，每次从后往前考虑，使得每个子串字典序不超过二分的答案，统计字典序的方法：二分一个后缀，再在后缀上二分。 例题四、给定一个字符串$S$，有$m$个询问，每组询问形如$(a,b,c,d)$，询问$S_{a…b}$的所有子串中与$S_{c…d}$的最长公共前缀的最大值是多少。$|S|\le10^5m\le10^5$ 思路二分答案$x$，找到$SA$中与后缀$c$LCP大于$x$的部分，查询是否含有$[a,b]$中的元素，二维数点问题，主席树求解。 例题五、给出一个长度为$n$的数组$a_i=i$，把它进行$m$次操作，每次操作可以是以下两种： 把某一段提到开头 区间翻转 现在问后缀数组为$a$的字符串$S$有多少种可能。限制$S$为字符串中出现的都是正整数，且最大元素等于不同元素的个数。$n\le10^9,m\le10^5$ 思路考虑后缀数组的定义$suf_{a_i}&lt;suf_{a_{i+1}}$于是推出$S_{a_i}\le S_{a_{i+1}}$可以发现确定每一个$\le$为$&lt;$或$=$，就能唯一确定整个数组。取$&lt;$一定合法，取$=$要求$suf_{a_{i+1}}&lt;suf_{a_{i+1}+1}$ 五、后缀自动机（SAM）字符串$S$的后缀自动机是一个能接受$S$的所有子串的有限状态自动机。 Right集所有该字符串的右端点组成的集合称为该串的$Right$集，$Right$集不同的串即为本质不同的串子串的$Right$集只有包含与并列关系由于这样的性质，我们可以建出一棵树，这棵树称为$fail$树。 建立SAM$last$:已经建立好的$SAM$因为新后缀而创建的最后一个节点。]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day5]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day5%2F</url>
    <content type="text"><![CDATA[Day5 上午——动态规划大纲DP的类型序列DP数位DP概率DP树形DP状态压缩DPDP套DP DP的优化形式优化决策单调性优化斜率优化凸单调性DP优化 例题、[HAOI2011]problem a题面见P2519 思路将问题转化一下，一个人说的话如果为真说明从第$a_i+1$到第$n-b_i$个人的分数是一样的.如果我们把这样一个模型看成一条线段，那么在这$n$条线段中，相交且互不重合的线段一定不能同时为真话，所以问题就转化为选出尽可能多的不相交或完全重合的线段，且对于某条线段完全重合的个数要小于等于线段长。所以做法就很明显了，先求出说最多的说真话的人数，用总人数去剪。具体做法为：将每个人对应的线段放在一起进行双关键字排序，合并完全包含的线段，每一个线段上存一个权值$V_i$，现在就是要从$m$个线段中取出不相交的线段使得权值和最大，这就可以DP了。将所有线段按右端点排序，设$f_i$为到第$i$个线段的最优解。转移的时候先二分$[1,i)$之间满足$R_k&lt;L_i$的$f_k$最大的$k$，转移方程为$f_i=\max(f_{i-1},f_k+V_i)$最终答案为$n-f_m$ 一、数位DP数位DP常用来统计或查找一个区间满足条件的数，然后按数位顺序DP，一般需要仔细分情况讨论，常见处理如将区间拆为$[1, R], [1, L)$，记忆化，预处理等。 例题一、[SDOI2013]淘金题面见P3303 思路考虑对于一个$i$，有多少$j$满足$f_j=i$，记为$v_i$不难发现，$[1,n]$内的任何数各位相乘的结果最多只有4个质因子$2 ,3 ,5 ,7$，也就是说$i$可以被分解为$2^a\times 3^b\times5^c\times7^d$，这样的$i$在$n\le10^{12}$范围内其实是很少的这个个数设为$m$。所以我们可以设计状态$f_{i,j,0/1}$表示从低位到高位的第$i$位，各位的乘积为$j$（离散化后），最后一维表示是否小于等于$N$转移的时候枚举第$k$位，如果$k|j$那么$dp_{i,j,0/1}$可以从$dp_{i-1,\dfrac{j}{k},0/1}$转移过来最终我们是要求位置$(x,y)$的价值$v_x\times v_y$的前$K$大之和。考虑将$v$从小到大排序，用大根堆维护$m$个指针$p_i$，分别表示的是$v_1$到$v_m$，维护堆的关键字为$v_{p_i}\times v_i$，贪心选择$K$个求和得到答案。 二、概率和期望DP概率DP是一类求事件概率或期望的DP的总称。对于求概率问题，有时利用补集转化，或者将其转化为计数问题；而对于求期望则大多利用期望的线性性来解决问题。 贝叶斯公式条件概率$P(y|x)$联合概率$P(y,x)$$P(x,y)=P(x,y)=P(y|x)P(x)=P(x)P(y)$$P(x,y)=P(x|y)P(y)$贝叶斯公式：$P(y|x)=\dfrac{P(x|y)P(y)}{P(x)}$ 例题一、亚瑟王给你$N$张牌，每张牌有一个发动概率 $P_i$ 以及伤害 $D_i$，共有$R$回合，每回合会按编号从小到大依次考虑本次游戏中还未发动的卡牌，依次尝试发动，如果发动成功，进入下一回合，求期望伤害之和，共 $T$组数据。$T\le444,N\le220,R\le132$ 思路$dp_{i,j}$表示前$i$张牌发动了$j$张的概率求出每张牌发动的概率$sump_i=\sum\limits_{j=0}^rdp_{i-1,j}(1-(1-p_i)^{r-j})$$dp$可以DP求得$dp_{i,j}=\sum\limits_{j=0}^r(dp_{i-1,j}(1-p_i)^{r-j}+dp_{i-1,j-1}(1-(1-p_i)^{r-j+1}))$ 例题二、Museum题面见CF113D 思路解法一、设$ f_{i, j} $为第一个人在$ i$, 第二个人在$ j$,此时开始,之后在$ t $点相遇的概率.枚举终点, 做$ n $次高斯消元即可,不过直接这样做是$ O(n^7)$的.注意到每次高斯消元时,$ Ax = B $只有$ B $发生了变化.于是把$ B $改成一个矩阵就可以$ O(n^6)$了.最后通过$f_{i,j}=\sum\limits_{1\le i\le n}A_if_{i,i}$,令$f_{i,i}=1$就可以求出所有解 解法二、设$f(i,j)$为第一个人在$i$，第二个人在$j$这种情况的期望出现次数，因为终止状态只会出现0/1，于是期望就是概率了。 三、树形DP树形DP是指基于树的结构的动态规划，基础的有： 树的直径：DP记录子树内最长路 树的重心：DP记录子树大小 树上最大权独立集：DP记录子树的根是否选择 树形依赖背包：在dfs序上DP(即每次选择是否跳过子树)，或通过父节点的DP值传入孩子DP 虚树：在原树上只保留需要的点与他们的LCA的树称为虚树，建树方法为：将点按dfs序排序，一次将点加入，用一个栈维护树上的已加入的点和他们LCA的右链，每次加入一个点，与栈顶比较，便可以建出虚树 … 例题一、大工程题面见P4103 解答有着询问的和小于的限制的题是虚树的一个显著的特征。建出虚树, 然后直接在上面树形DP。设$ f_i $为以$ i $为根的子树内路径的代价和,$ size_i $为$ i $的子树中询问点的个数,$ max_i $为$i$子树内的到$ i $的最长路,$ min_i $为最短路，则：$f_i=f_{son_i}+size_i\times k-size_{son_i}$$max_i = \max\left\{max_{son_i} + 1\right\}$路径和答案是$ f_{root}$, 对于每个点,用它的最大与次大的儿子更新答案.如果他是被询问的点,则还可以用它每个儿子更新答案. 四、状态压缩DP基于状态压缩的DP是由于状态用单个简单的变量直接存储存在空间的浪费，而采用压缩的状态的动态规划，例如： 插头DP：维护当前已决策和未决策的一条$Z$字形的轮廓线的插头状态，用括号序列配对插头，每次只需分情况讨论即可，但是这类DP的显著特点就是情况繁多，使用时须细心 例题、给一个$N$个点$M$条边的无向图，每个点有点权$A_i$，保证任意两点之间距离不超过$10$。现在要你选取一些点，使得每个点要么自己被选，要么相邻的点被选。一个方案的代价定义为选取的点的点权和，求最小代价。$N\le20000,M\le25000,0\le A_i\le10000$ 解法考虑如何利用 “距离不超过10” 这个限制.不妨把生成树搞出来,那么这个树的深度$ \le 10$. 一个很显然的想法是DP时,对每个点设状态$ dp_{u, S}$, 表示以$ u $为根的子树,当$ u $到根这条路径上的点的选取情况是$S $时的最小代价.由于,一个点可能会对通过非树边覆盖祖先,对于$S$中每个未选取的点,我们可以再记录一下它是否已经被覆盖.对于一个点状态数是$3^{10}$的.用$3$进制来表示$S$. 规定一下$S$中某一位的值的意义: 0: 这个点被选取了 1: 这个点未被选取, 但已经被覆盖 2: 这个点未被选取, 且仍未被覆盖 在DFS序上做即可.转移并不困难,注意的是当DFS序中前一个点不是当前点的父亲时,要把$dp$值维护一下.使用滚动数组,空间复杂度$ O(N + M + 3^{10})$,时间复杂度$O(M + 3^{10}N)$.对每个连通块都要做一遍. 例题一、对于任意一个正整数$N\le10^5$，求出${1,2,…,N}$的满足”若$x$在该子集中，则$2x,3x$不能在该子集”的子集个数。答案对$10^9+1$取模。$N\le10^5$ 思路将题目转化为“一个网格图，相邻点不能选”的计数问题，枚举左上角就行了。 五、DP套DP某些DP问题的子判定问题不能简单的解决,而必须用另一个DP解决,此时就只能使用DP套DP的方法,即：外面的DP的状态是存的里层DP各个状态的值,利用里层的状态来判断外层的DP是否合法,类似的问题有LCS为定值的序列的方案数等等。 例题一、给你一个只由$ACGT$组成的字符串$S$，对于每个$0\le k\le |S|$，问有多少个只由$ACGT$组成的长度为$M$字符串$T$，使得$LCS(S,T)=k$.$|S|\le15,M\le10^3$ 思路DP套DP，算LCS的DP为$dp_{i,j}=max(dp_{i-1,j-1}+[T_i=S_i],dp_{i-1,j},dp_{i,j-1})$这题的$ |S| $很小,不妨对于每个$ i$, 将$ j $不同时的DP值都记录下来,计个数即可.但是直接记DP值状态数会爆内存,但是注意到相邻的DP值只会差$1$,所以我们可以用$ 2^{|S|} $的状态数将这些值记录下来. 六、DP的形式优化有时在做一个DP问题时将会遇到时间或者空间复杂度过高的问题,而在DP的形式上优化便是有效的优化技巧, 典型的有预处理, 分阶段DP等: 预处理: 我们可能发现, 在DP的过程中, 出现了重复的运算, 浪费了时间, 所以我们可以通过DP前预处理, 或者DP过程总处理出最值, 而达到为后面的DP提供便捷的功能与作用, 达到优化的目的 分阶段DP: 在某些DP中将DP拆为一个个有特点阶段也许比将整个DP放在一起更加节省时间与空间, 所以对于彼此相对无关的转移, 可以分开考虑 例题一、给定长度为$N,M$的数组$A,B$，求最长公共上升子序列。$N,M\le5000$ 思路状态设计：$dp_{i,j}$表示$A$考虑到$i$，$B$考虑到$j$且必须选$j$的长度当$A_i=B_j$时，有转移$dp_{i,j}=\max\left\{dp_{i-1,k}|k&lt;j,B_k&lt;B_j\right\}+1$由于$A_i=B_j$，这个限制事实上就是$B_k&lt;A_i$，对于同一个$i$限制是相同的。我们可以从小到大枚举$j$，维护$\max\left\{dp_{i-1,k}|k&lt;j,B_k&lt;A_i\right\}$，直接转移即可。 例题二、现在有$n$个活动，每个活动需要占用$[l_i,r_i)$的时间，现在有两个会场，两个会场不能同时有活动，但是一个会场可以同时举办多个活动。要求安排每个活动在哪个会场举行，或者不举行，使得举行活动较少的会场举行活动最多。同时，对$i\in[1,n] $求出如果强制活动$i$必须举行，那么所求答案是多少。$n\le200$ 思路第一问，预处理出$[l,r)$表示$[l,r)$包含多少段区间，设$f_{i,j}$表示考虑了$[0,i)$区间，第一个会场举办$j$个活动的前提下，第二个会场最多举办多少活动。第二问，处理出DP数组的前后缀，对于每个询问合并答案令$g_{i,j}$表示考虑了$[i,size)$这个区间时的DP数组，不难想到：处理出$max_{l,r}$表示$[l,r)$区间一定选时的答案，然后合并前后缀。考虑优化合并过程，我们发现前缀和后缀都具有单调性，双指针即可。最终复杂度$O(n^3)$ 七、决策单调性优化DP问题的转移往往需要大量的时间, 如果我们能发现一些性质, 找到一些规律来优化 DP 决策转移的过程, 那么在时间上我们便能得到很大的优化, 常见的有四边形不等式优化, 以及一些1D/1D动态规划的优化。 四边形不等式优化对于形如以下DP:$f_{i,j}=f_{i,k-1}+f_{k,j}+w_{i,j}$如果$w$满足四边形不等式： 任意$i\le i’\le j\le j’$，有$w_{i,j}+w_{i’,j’}\le w_{i’,j}+w_{i,j’}$ 任意$i’\le i\le j\le j’$，有$w_{i,j}\le w_{i’,j’}$ 那么也可证明：$f_{i,j}+f_{i’,j’}\le f_{i’,j}+f_{i,j’}$而如果得到了这样的式子, 则就可以证明$ f_{i, j} $的决策一定在$f_{i, j − 1} $与$ f_{i − 1, j} $的决策之间:$s_{i,j-1}\le s_{i,j}\le s_{i-1,j}$四边形不等式的证明：http://wenku.baidu.com/link?url=344UHCQdTP9z2dFTCCGB3eBYHnlBeF0IAYdFeLmA_p0QU9nGv3L-6AyISk4zUKcTMBDrokvx_i-5BHh7H5ZFfjS3hf2j9jHdPCgUXwQjqS 1D/1D动态规划方程的优化$f_i=\min\left\{f_j+w_{j,i}|j\le i\right\}$若$w$满足四边形不等式，则可证明$f_i$的决策也一定单调。 例题一、NOI2009 诗人小G题面见P1912 思路首先推出DP方程:$f_i=\min\left\{f_j+|sum_i-sum_j-l|^p\right\}$令$w_{i,j}=|sum_i-sum_j-l|^p$，可以证明（不会证）$w$满足四边形不等式。由上述结论，对于任意的$i\le j$，$f_i$的决策一定$\le f_j$的决策，于是我们用一个栈来维护DP的决策。 八、斜率优化斜率优化DP是当DP转移式形如$f_i = \min\left\{f_j + k_ix_j + c_i + b_j\right\}$将与$ j $无关的常数提出$ \min$，我们就是要求$\min\left\{k_ix_j + f_j + b_j\right\}$令$ y_j = f_j + b_j$，每次我们实际上是在所有过 $(x_j , y_j )$ 且斜率为$-k_i $的直线$y_j =-k_ix_j+B$中找到一个直线具有最小的$ B$，即纵截距最小。显然最优的$(x_j , y_j ) $一定在凸壳上。于是我们便可以使用维护凸壳来将时间复杂度变得更优。根据$ x_j $和$ k_i $的单调性，我们可以： $x_j $与$ k_i $同时单调: 单调队列/单调栈 (hdu 3507) $x_j $单调,$ k_i $不单调: 单调队列/单调栈+二分斜率 (bzoj 2726) $x_j $不单调: Splay维护凸壳 (bzoj 1492) 九、凸单调性DP优化例题一、IOI2016 aliens题面见uoj240 思路将主对角线一边的点翻到另一边，去除一些无用点，首先可以推出一个显然的DP方程 $dp_{i,j}=\max\limits_{k&lt;j}\left\{dp_{i-1,k}+(x_j-y_{k+1}+1)^2-\max(0,x_k-y_{k+1}+1)^2\right\} $其中$dp_{i,j}$表示用$i$个正方形覆盖$j$个点所需要的最小并面积。这个转移方程可以很容易斜率优化，时间复杂度就变成$O(nk)$当然这并不能满足题目要求。如果$dp_{k,n}$是一个关于$k$的凸函数，那么不妨二分$dp_{k-1,n}$和$dp_{k,n}$这两个状态之间的差值（用一个一次函数取切，得一个切点）。将DP方程改为$dp_i=\max\limits_j&lt;i\left\{dp_j+(x_i-y_{j+1}+1)^2-\max(0,x_j-y_{j+1}+1)^2\right\}+x$转移一次有$x$的代价，记录一下$dp_n$转移达到最优值所需要的最少转移次数，就可以二分了。 十、容斥DP例题一、给定$n$个数$a_1,a_2,…,a_n$，将这些数分成两组，使得两组中的元素$or$和相同，求方案数，答案对1e9+7取模。$n\le50,0\le a_i\le2^{20}$ 解法按位考虑, 如果所有的数在某一位上都为$ 0$, 显然可以不用考虑.对于其它的位, 如果要满足题目的要求, 则必须满足所有这一位为$ 1$的数不能全部在同一组里. 虽然这个条件不好计数, 但是它的反面是很好计数的!所以, 枚举至少有哪些二进制位不满足条件, 然后用并查集维护一下就行了. 例题二、给定一个$N$维超立方体，第$i$个维度的长度为$r_i$，同时给你一个$N$维超平面$x_1+x_2+…+x_n=S$。这个超平面把超立方体切成至多两部分，求圆点所在那一部分的面积。$N\le500,A_i\le500,S\le10^9$ 思路有点超纲。。。学了微积分再补 例题三、[ZJOI2016]小星星题面见P3349 思路首先考虑一个错误的树形DP. 设$ dp_{u, p} $表示考虑了以$ u $为根的这个子树, 并且根映射到原图的$ p $点. 这个显然可以$ O(n^3) $转移, 但是有什么问题呢?不同的点可能映射到同一个点. 于是考虑容斥.求出$ dp_S $表示映射的点集至多为$ S $时的答案, 然后就可以$O(2^nn^3) $做了. 容斥何时起作用 $=$和$\not=$ $\min$和$\max$ gcd和lcm “恰好”和”至少” … 容斥的理解给定一些条件，问全部满足的对象的个数答案$=$所有对象$-$至少不满足其中一个的$+$至少不满足其中两个的$-$至少不满足其中三个的…另一种理解：在所有物品中, 问在某个条件$C_0$下所有物品的贡献之和.构造一些相对容易计算贡献的条件$C_1,…,C_n$再对于每个条件构造容斥系数 $f_1,…,f_n$ 满足对于每个物品$\sum\limits_{i=1}^{n}s_{C_i}f_i=s_{C_0}$其中$s_{C_i}$表示这个物品在条件$C_i$下所产生的贡献.对于常见的计数问题, 物品的贡献只会是$0/1$, 表示这个物品是否满足此条件. 凑系数一个经典的错排问题求长度为$n$的排列$a_1,…,a_n$的个数，满足$a_i\not=i$错排数：排列的不动点，即$a_i=i$的位置. 例题四、小学奥数（雾）给定$m$个数$a_1,a_2,…,a_n$，统计$[1,n]$的整数中，满足$a_1,a_2,…,a_n$中有奇数个数整除它的个数。$n\le10^9,m\le15$ 思路枚举$m$个数的一个子集，算出$lcm$，容斥一下。对于每个数，如果它被$k$个数整除，则有$\sum\limits_{i=0}^{k}C^i_kf_i=k\mod 2$可以求出所有的$f_i$ 例题五、异或图题面见bzoj4671 思路容斥。首先枚举子集划分，强制连通性“至少”是这个划分，也就是说，不同子集的两个点之间一定没有边，相同子集的两个点则任意.对于一个有$m$个联通块的图，容斥系数需要满足$\sum\limits_{i=1}^{m}$ 例题六、[NOI2009]管道取珠题面见P1758 技巧：平方处理思路统计平方的和, 转化成统计有序对.即统计有多少对$(wayA, wayB)$使得$wayA, wayB$均能得到相同的结果. 例题七、给定$S, T, K,$求每次$+1, −1,$用不超过$K$次操作从$S$变成$T$的方案数.每一时刻都不能为负$S,T,K\le10^5$ 技巧：反射法在平面直角坐标系中画出图像($x $轴代表时间,$ y $轴代表当前的数值), 发现所有不合法的路径都可以沿$ y = −1 $反射到一条从$(-(S + 2), 0) $到$ (T, 0) $的路径.直接组合数计算即可. 当然直接减一下转化为不能穿过对角线也是一样的.]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day4]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day4%2F</url>
    <content type="text"><![CDATA[Day4 上午——数学一、BSGS给定质数$p$，给定$a$和$b$，$(a,p)=1$。求最小的非负整数$x$，使得$a^x\equiv b(mod\;p)$。 解法首先根据欧拉定理$a^{\phi(p)}\equiv1(mod\;p)$，当$a^x\equiv b(mod\;p)$有解，最小非负整数解一定在$[0,\phi(p))$中。令$m=\sqrt{\phi(p)}$，任意$x\in [0,\phi(p))$都可以分解成$im+j$的形式，其中$0\le i \le m,0 \le j &lt;m$。枚举$i$的值，$a^x\equiv b(mod\;p)\Leftrightarrow a^j\equiv a^{-im}b(mod\;p)$。将$a^0,a^1,a^2…$放到$hash$表中查询就可以了。复杂度：$O(\sqrt{\phi(p)})$另外，如果要解决$p$不为素数的情况，需要用到$exBSGS$ 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x)#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e2 + 5, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;ll mod;inl ll ksm(rg ll a, rg ll b)&#123; rg ll ans = 1; for (; b; b &gt;&gt;= 1, (a *= a) %= mod) if (b &amp; 1)(ans *= a) %= mod; return ans;&#125;inl ll BSGS(rg ll a, rg ll b)&#123; rg ll p = mod; a %= p, b %= p; map&lt;ll, ll&gt;mp; rg ll m = ceil(sqrt(p)), t = 1; for (rg int i = 0; i &lt; m; ++i) &#123; if (!mp.count(t)) mp[t] = i; (t *= a) %= p; &#125; rg ll k = ksm(t, p - 2), w = b; for (rg int i = 0; i &lt; m; ++i) &#123; if (mp.count(w))return i * m + mp[w]; (w *= k) %= p; &#125; return -1;&#125;int main(void)&#123; rg ll a, b; while (~scanf("%lld%lld%lld",&amp;mod, &amp;a, &amp;b)) &#123; rg ll ans = BSGS(a, b); if (~ans)fast_IO::write(ans), putchar('\n'); else puts("no solution"); &#125; return 0;&#125; exBSGS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#pragma GCC optimize("fast-math,unroll-loops")#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")#include &lt;bits/stdc++.h&gt;#include &lt;unordered_map&gt;#define lowbit(x) (x&amp;-x)#define jh(x, y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e2 + 5, mod = 998244353, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;unordered_map&lt;ll, ll&gt;mp;ll a, b, p;inl ll GCD(rg ll a, rg ll b) &#123; while (b ^= a ^= b ^= a %= b); return a; &#125;inl ll exBSGS(rg ll a, rg ll b, rg ll p)&#123; if (b == 1)return 0; rg ll gcd, add = 0, mul = 1; while ((gcd = GCD(a, p)) ^ 1) &#123; if (b%gcd)return -1; b /= gcd, p /= gcd, ++add; (mul *= a / gcd) %= p; if (mul == b)return add; &#125; rg ll m = sqrt(p) + 1, kt = 1; mp.clear(); for (rg int i = 0; i != m; ++i) &#123; mp[kt*b%p] = i; (kt *= a) %= p; &#125; (mul *= kt) %= p; for (rg int i = 1; i &lt;= m; ++i) &#123; if (mp.find(mul) != mp.end())return i * m - mp[mul] + add; (mul *= kt) %= p; &#125; return -1;&#125;int main(void)&#123; while (a = fast_IO::read(), p = fast_IO::read(), b = fast_IO::read()) &#123; rg ll ans = exBSGS(a, b, p); if (~ans)fast_IO::write(ans), putchar('\n'); else puts("No Solution"); &#125; return 0;&#125; 二、Miller-Rabin给定$n$，判定$n$是否为素数。 解法首先筛去偶数，我们只考虑奇数的情况。显然$\forall x\in[1,p-1],x^p\equiv x(mod\;p)$，但是有些合数也满足这个性质，所以不能直接用这个性质来判断一个数是不是素数。考虑$x^2\equiv 1(mod\;n)$的根，若$n$是奇素数，则只有$1$和$n-1$(即$-1$两根)，因为原式可以改写成$(x+1)(x-1)\equiv 0(mod\;n)$。设$n-1\equiv 2^r\times d$，其中$d$是奇数。$n$是合数当且仅当存在$0\le k&lt; r,a^{2^k\times d}\not\equiv1,-1(mod\;n)$，且$a^{2^{k+1}\times d}\equiv1(mod\;n)$。选取多个$a$进行二次探查，减小错误率。 模板（int64）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x)#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e2 + 5, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;ll num[11] = &#123; 0,2,3,5,7,11,13,17,19,23,29 &#125;;inl ll ksm(rg ll a, rg ll b, rg ll mod)&#123; rg ll ans = 1; for (; b; b &gt;&gt;= 1, (a *= a) %= mod)if (b &amp; 1)(ans *= a) %= mod; return ans;&#125;inl bool detective(rg ll x, rg ll n)&#123; rg int r = 0; rg ll d = n - 1; while (!(d &amp; 1))d &gt;&gt;= 1, ++r; for (rg ll a = ksm(x, d, n), b; r; --r) &#123; b = a * a%n; if (b == 1)return a == 1 || a == n - 1; a = b; &#125; return false;&#125;inl int Miller_Rabin(rg ll x)&#123; for (rg int i = 1; i &lt;= 10; ++i) &#123; if (x == num[i])return 1; if (x%num[i] == 0)return 0; if (!detective(num[i], x))return 0; &#125; return 1;&#125;int main(void)&#123; rg int m = fast_IO::read(); while (m--)puts(Miller_Rabin(fast_IO::read()) ? "Yes" : "No"); return 0;&#125; 实践结论对于$int32$范围内的数，我们选取$2,7,61$探测即可。对于$int64$范围内的数，我们选取前十个素数探测即可。 三、Pollard-rho给定$n$，将$n$质因数分解。 解法如果用Miller-Rabin测试出来$n$是素数，直接停止算法。随机基底$a$和$c$，，生成序列$x_0=a,x^2_{i-1}+c(mod\;n)$，可以说序列${x_i}$是一个随机序列。如果出现$(x_i-x_{2i+1},n)\not=1$，停止算法。令$d=(x_i-x_{2i+1},n)$，若$d\not=n$，那么$d$就是$n$的一个非平凡因子，$n$可以被分为$\dfrac{n}{d}$和$d$相乘的结果，递归下去对$\dfrac{n}{d}$和$d$分别求解。复杂度$O(N^{\dfrac{1}{4}})$ 四、Linear-Shaker给定$n$，筛出$n$以内的所有素数。 解法见线性筛模板P3383。 五、Chinese Reminder Thereom$x\;mod\;n_1=x_1$$x\;mod\;n_2=x_2$$x\;mod\;n_3=x_3$…其中$n_1,n_2,…,n_k$两两互质，求$x$的一个合法解。 解法令$N=\prod\limits_{i=1}^{k}n_i$，$m_i=\dfrac{N}{n_i}$，$t_i=m_i^{-1}(mod\;n)$。$x=\sum\limits_i x_im_it_i(mod\;n)$我们容易发现，当$j=i$时，$m_it_i\equiv1(mod\;n_j)$，当$j\not=i$时，$m_it_i\equiv0(mod\;n_j)$，因此$x$一定是方程组的一组解。 模板（UVA756）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x)#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e2 + 5, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;ll mod[3]&#123; 23,28,33 &#125;, x[3];ll exgcd(rg ll a, rg ll b, rg ll &amp;x, rg ll &amp;y)&#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; rg ll yu = exgcd(b, a%b, x, y); rg ll tmp = x; x = y; y = tmp - a / b * y; return yu;&#125;inl ll CRT(rg int n)&#123; rg ll sum = 1, ans = 0, m; for (rg int i = 0; i != n; ++i)sum *= mod[i]; for (rg int i = 0; i != n; ++i) &#123; rg ll xx, y; m = sum / mod[i]; exgcd(m, mod[i], xx, y); ans += m * xx *x[i]; &#125; return ans % sum;&#125;int main(void)&#123; rg int d, step = 0; while (~(x[0] = fast_IO::read())) &#123; x[1] = fast_IO::read(), x[2] = fast_IO::read(); rg ll ans = CRT(3) - fast_IO::read(); ((ans %= 21252) += 21252) %= 21252; ans = (ans - 1 + 21252) % 21252 + 1; printf("Case %d: the next triple peak occurs in %d days.\n", ++step, ans); &#125; return 0;&#125; exCRT模板（POJ2891）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//#pragma GCC optimize("fast-math,unroll-loops")//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x)#define jh(x, y) x^=y^=x^=y#define rg register#define inl inlinetypedef __int128 ll;const int N = 1e5 + 5, mod = 1e9 + 7, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;ll mo[N], yu[N];ll exGCD(rg ll a, rg ll b, rg ll &amp;x, rg ll &amp;y)&#123; if (!b)return x = 1, y = 0, a; rg ll gcd = exGCD(b, a%b, x, y); rg ll tmpx = x; x = y; y = tmpx - a / b * y; return gcd;&#125;inl ll exCRT()&#123; rg int n = fast_IO::read(); for (rg int i = 1; i &lt;= n; ++i)mo[i] = fast_IO::read(), yu[i] = fast_IO::read(); rg ll ans = yu[1], lcm = mo[1]; for (rg int i = 2; i &lt;= n; ++i) &#123; rg ll x, y, c = (yu[i] - ans % mo[i] + mo[i]) % mo[i]; rg ll gcd = exGCD(lcm, mo[i], x, y), b = mo[i] / gcd; if (c%gcd)return -1; (x *= c / gcd) %= b; ans += lcm * x; lcm *= b; ans = (ans%lcm + lcm) % lcm; &#125; return (ans%lcm + lcm) % lcm;;&#125;int main(void)&#123; fast_IO::write(exCRT()); return 0;&#125; 六、Quadratic residue给定$y$和奇素数$p$，求$x$，使得$x^2\equiv y(mod\;p)$。 欧拉判别法若$y^{\dfrac{p-1}{2}}\equiv1(mod\;p)$，则$y$在模奇素数$p$下有二次剩余若$y^{\dfrac{p-1}{2}}\equiv-1(mod\;p)$，则$y$在模奇素数$p$下没有二次剩余勒让德符号$(\dfrac{a}{p})\equiv a^{\dfrac{p-1}{2}}$$1,…,p-1$中有$\dfrac{p-1}{2}$个数的勒让德符号为$1$，另外$\dfrac{p-1}{2}$个数的勒让德符号为$-1$。 解法不断随机$a$，使得$(\dfrac{a^2-y}{p})=-1$令$\omega=\sqrt{a^2-y},x=(a+\omega)^{\dfrac{(p+1)}{2}}$由于$x^2\equiv(a+\omega)^p\times(a+\omega)\equiv(a+\omega)\sum\limits_{j}C^j_p\omega^{p-j}$$\equiv(a^p+\omega^p)(a+\omega)\equiv(a-\omega)(a+\omega)\equiv a^2-\omega^2\equiv y(mod\;p)$所以最终答案就是$(a+\sqrt{a^2-y})^{\dfrac{p+1}{2}}$ 例题给定长度为$n$的整数$a$，判断$a$是否是完全平方数。$n\le1000$ 思路选多组素数进行判别，考虑$x^2\equiv a(mod\;p)$成立，随机一些素数$p$判别就行了。 七、Multiplicative function狄利克雷卷积$(fg)(n)=\sum_{d|n}f(d)g(n/d)$ 积性函数积性函数的性质： $\forall (a,b)=1,f(ab)=f(a)f(b)$ 积性函数的卷积仍然是积性函数 所以其实我们可以把$n$看成$n=p_1^{k_1}p_2^{k_2}…p_m^{k_m}$常见的积性函数： 普通函数:$I(n)=1,id(n)=n,e(n)=[n=1]$ 除数函数:$\sigma_k(n)=\sum\limits_{d|n}d^k$ 欧拉函数:$\phi(n)=n\times\dfrac{p_1-1}{p_1}\times…\times\dfrac{p_m-1}{p_m}$ 莫比乌斯函数:$\mu(n)=[k_1\le1][k_2\le1]…k_m\le1^m$ $\sum\limits_{d|n}\mu(d)=[n=1]\Rightarrow\mu\times1=e$$\sum\limits_{d|n}\phi(d)=n\Rightarrow\phi\times1=id$ $\phi$和$\mu$的前$n$项与前缀和前$n$项可以在做线性筛的过程中求出，前缀和用杜教筛或者min25等算法解决 Day4 下午八、Primitive root（原根）给定$n$，若$a$满足$(a,n)=1$且$1,a,a^2,a^3,…,a^{\phi(n)-1}$在$mod\;n$下都互不相同，则称$a$是$n$的一个原根。 原根的性质 $2,4,p^n,2p^n$有原根，$p$是奇素数。 若$n$有原根，则原根数量为$\phi(\phi(n))$个。 阶最小的非零$x$使得$a^x\equiv 1(mod\;p)$，记为$$ 有关阶的定理①若$p&gt;1$且$(a,p)=1$，又满足$a^n\equiv1(mod\;p)$，则$|n$②$|\phi(p)$ 求法将$\phi(p)$质因数分解，$\phi(p)=p_1^{w_1}p_2^{w_2}…p_k^{w_k}$枚举$g$，如果恒满足$g^{\dfrac{\phi(m)}{p_i}} \not =1$，其中$i=1,2,…,k$则$g$是$m$的一个原根 九、Combination（组合数）求法：杨辉三角预处理阶乘及逆元 十、Recurrence relation（递推关系）矩阵乘法：$C_{i,j}=\sum A_{i,k}\times B_{k,j}$。 例题给定一张$N$个点$M$条边的有向图，$Q$次询问图中从每个点出发的长度为$K$的路径各有多少条。$N\le100,Q\le10,K\le100$ 思路分块矩乘。 十一、Principle of inclusion-exclusion（容斥原理）容斥原理$F(A\bigcup B\bigcup C)=F(A)+F(B)+F(C)-F(A\bigcap B)-F(B\bigcap C)-F(A\bigcap C)+F(A\bigcap B\bigcap C)$ 十二、Binomial inversion(二项式反演)$f_n=\sum\limits_{i=0}^{n}(-1)^iC^i_ng_i\Leftrightarrow g_n=\sum\limits_{i=0}^{n}(-1)^iC^i_nf_i$$f_n=\sum\limits_{i=0}^{n}C^i_ng_i\Leftrightarrow g_n=\sum\limits_{i=0}^{n}(-1)^{n-i}C^i_nf_i$ 例题、集合计数$n$个元素有$2^n$种不同的子集，现从$2^n$个子集中选取若干子集，求有多少种方案，使得选出集合的交元素个数为$K$。$n,k\le 10^6$，对$10^9+7$取模 思路令$g_k$表示选出集合的集合交为$k$时的方案数，$f_k$表示选出集合的集合交至少为$k$时的方案数。$f_i=C^i_n(2^{2^{n-i}}-1)$$f_i=\sum\limits_{j=i}^{n}g_jC^i_j$ 推出$g_i=\sum\limits_{j=i}^{n}C^j_n(2^{2^{n-j}}-1)(-1)^{j-k}C^k_j$ 十三、Probability Thereom（概率论）期望：$E(x)=\sum\limits_{i=1}^{n}a_iP(x=a_i)$期望具有线性性 例题、求逆序对长度为$n$的序列，求逆序对的期望个数。令$a_{i,j}$表示$i,j$是否逆序，逆序则为1，否则为0。 例题、Clear the room给定一个$n\times m$的网格，$(i,j)$中有物品价值$w_{i,j}$。现取$K$次，每次取走一个矩形内所有物品，问$K$次操作后拿走物品价值和期望。$n,m\le500,K\le10^9$ 思路求出每一个点被选中的概率$p$，不难想到我们要想选中一个点$(x,y)$，必须要使得选中的矩形包含$(x,y)$，也就是$x_1\le x\le x_2,y_1\le y \le y_2$，那么推出结论：选中一点$(x,y)$的概率$p=\dfrac{x\times(n-x+1)\times y\times(m-y+1)}{n^2\times m^2}$，答案就等于$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}w_{i,j}p_{i,j}^k$ 十四、Gaussian（高斯消元）模板。]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day3]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day3%2F</url>
    <content type="text"><![CDATA[Day3上午——图论一、强联通分量强联通分量即是环极大强联通子图：将原图中任何点加入这个子图都不能构成强联通分量的强联通分量。极大不一定最大。强联通分量针对有向图。途中每个点都属于且仅属于一个极大强联通分量。强联通分量与点的关系具有传递性。求强联通分量可以使用Tarjan算法或者Kosaraju算法，我们主要使用Tarjan算法。 二、Tarjan算法考虑当前dfs到某个点now,其余点只有三种：①可以访问到的点②不能访问到的点③未访问的点dfs的过程中，如果从某一点出发可以回到这个点，那么一定会存在一个强联通分量，而这个强联通分量就在dfs的栈里，所以我们可以用一个栈记录一下经过的点，去找强联通分量。定义dfn[x]为搜索到x的时间，即编号，low[x]为从x出发可以走到的最小点。我们发现如果从某点出发搜完之后low[x]==dfn[x]，说明此时从x出发有一个强联通分量，此时我们把记录的栈弹出至遇到x就是一个强联通分量。 缩点缩点后，新图为一个DAG。 例题一、The Cow Prom题面见P2863。tarjan裸题。 例题二、受欢迎的牛题面见P2341。 思路首先缩点，发现如果某个点只有入度且只有这个点是只有入度的，那么这个点就是要求的点，否则不存在。 例题三、稳定婚姻题面见P1407。 思路夫妻男连女，情人女连男，跑一边tarjan，如果一对夫妻在同一个强联通分量中，这段婚姻就是不稳定的。 三、双联通分量割点和桥将点$x$删掉后，图中联通分量个数增加，称$x$为割点。将边$e$删掉后，图中联通分量个数增加，称$e$为桥。点双联通分量：两点间的所有路径不经过同一点的联通分量。边双联通分量：两点间的所有路径不经过同一边的联通分量。 割点求法类似于tarjan，如果x有一个出点low值$\ge dfn[x]$说明x是割点，注意要特殊处理第一个搜索的点。 边双联通分量求法和求强联通分量几乎一样，判断一下不走回头路就行了，不能走走过的边。扔个模板1234567891011121314151617181920212223242526272829303132333435363738394041424344...int nt[N], b[N], p[N], num = 1, st[N], dfn[N], low[N], ltk[N], id;bool flag[N];inl void add(rg int x, rg int y)&#123; b[++num] = y, nt[num] = p[x], p[x] = num; b[++num] = x, nt[num] = p[y], p[y] = num;&#125;void tarjan(rg int x)&#123; dfn[x] = low[x] = ++id; st[++*st] = x; for (rg int e = p[x]; e; e = nt[e]) if (!flag[e]) &#123; rg int k = b[e]; if (!dfn[k]) &#123; flag[e] = flag[e ^ 1] = true; tarjan(k); flag[e] = flag[e ^ 1] = false; low[x] = fast_IO::min(low[x], low[k]); &#125; else low[x] = fast_IO::min(low[x], dfn[k]); &#125; if (dfn[x] == low[x]) &#123; ++*ltk; while (st[*st + 1] != x) &#123; ltk[st[*st]] = *ltk; --*st; &#125; &#125;&#125;int main(void)&#123; ... for (rg int i = 1; i &lt;= m; ++i)add(fast_IO::read(), fast_IO::read()); for (rg int i = 1; i &lt;= n; ++i)if (!dfn[i])*ltk = 0, tarjan(i); ... return 0;&#125; 例题一、冗余路径Redundant Paths题面见P2860。 思路先求边双联通分量，缩点后成了一颗树，这棵树的度数为1的点的数量sum，答案就是⌈$sum/2$⌉，答案的正确性显然，因为每个度数为1的节点肯定需要连边出去，贪心的想就很容易证明了。 点双联通分量求法在求割点的过程中就能求出，稍微改动一下就行，我们考虑将经过的边入栈而不是经过的点，在找到割点的时候，把边一个个从栈中取出直到遇到边$(u,v)$，取出的边与其关联的点构成一个点双联通分量。由于点双联通分量求法不太一样，扔个模板吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct Node &#123; int u, v;&#125;e[N], st[N], tp;int nt[N], p[N], top, dfn[N], low[N], id, gedian[N], bcc_cnt, belong[N];vector&lt;int&gt;bcc[N];void tarjan(rg int x, rg int fa)&#123; rg int child = 0; dfn[x] = low[x] = ++id; for (rg int k = p[x]; k; k = nt[k]) &#123; rg int to = e[k].v; st[++top] = e[k]; if (!dfn[to]) &#123; ++child; tarjan(to, x); low[x] = fast_IO::min(low[x], low[to]); if (low[to] &gt;= dfn[x]) &#123; gedian[x] = true; bcc[++bcc_cnt].clear(); do &#123; tp = st[top--]; if (belong[tp.u] != bcc_cnt) &#123; bcc[bcc_cnt].push_back(tp.u); belong[tp.u] = bcc_cnt; &#125; if (belong[tp.v] != bcc_cnt) &#123; bcc[bcc_cnt].push_back(tp.v); belong[tp.v] = bcc_cnt; &#125; &#125; while (tp.u != e[k].u || tp.v != e[k].v); &#125; else if (e[k].v != fa)low[x] = fast_IO::min(low[x], dfn[to]); &#125; &#125; if (!fa) &#123; if (child &gt; 1)gedian[x] = true; else gedian[x] = false; &#125;&#125;...int main()&#123; ... for (rg int i = 1; i &lt;= n; ++i) if (!dfn[i])tarjan(i, 0); ... return 0;&#125; 四、二分图二分图的判定对二分图黑白染色，如果产生矛盾说明不是二分图。（二分图中无奇环）。 Hall定理设二分图中$G=$中$\left| V1 \right|=m\le\left| V2 \right|=n$,$G$中存在从$V1$到$V2$的完全匹配当且仅当$V1$中任意$k(k=1,2,…,m)$个顶点至少与$V2$中$k$个顶点是相邻的。 匈牙利算法贪心，过程比较简单，扔个模板12345678910111213141516171819202122232425262728vector&lt;int&gt;e[N];int mat[N];bool flag[N];bool dfs(rg int x)&#123; for (rg int i = 0; i != e[x].size(); ++i) &#123; rg int j = e[x][i]; if (flag[j])continue; flag[j] = false; if (!mat[j] || dfs(mat[j]))return mat[j] = x; &#125; return false;&#125;...int main()&#123; ... for (rg int i = 1; i &lt;= n; ++i) &#123; if (dfs(i))++ans; memset(flag, 0, sizeof(flag)); &#125; ... return 0;&#125; 几个定理二分图最小点覆盖==二分图最大匹配点覆盖：在图中选取一些点，保证每条边至少有一个点在选取点中，称这些点是一个点覆盖。二分图最大点独立集==总点数-二分图最大匹配独立集：在图中选取一些点，保证每个点不相邻，则称这些点是一个独立集。 例题一、Asteroids 小行星题面见POJ3041。 思路行列分开，对于小行星的坐标$(x,y)$，连边$(x,y)$，跑二分图匹配求最小点覆盖即是答案。 例题二、Muddy Fields 泥泞的牧场题面见POJ2226 思路和前面那道例题类似，贪心的考虑，每块板子肯定是延伸到最长最好，所以我们把一些板子分成两部分：$A$部分是所有横着的木板，$B$为所有竖着的木板，将横竖交叉的木板连边，构成一个二分图，这样选择一个点就代表选择一个板子，求最小点覆盖就是我们要求的答案。 五、2-SATSAT问题是给出一些条件（元素经过逻辑运算的结果，如and or xor），SAT问题已经被证明是一个NP完全问题。2-SAT问题中最多有两个条件。 求法对于每个变量$x$，建立两个点$x_t$和$x_f$，分别表示$x$取TRUE和$x$取FALSE。对于所有的“A取x则B取y”，连边$(A_x,B_y)$，该图中如果P能到达Q，表示“若P成立，则Q一定成立”所以如果从$a_f$出发能到达$a_t$或者$a_t$出发能到达$a_f$，则矛盾。这一步的检验我们考虑用tarjan求联通分量，$O(N)$解决。如果没有这种情况出现，则一定存在合法方案。现在我们考虑如何构造一组可行解我们构造这样一种方案：缩点之后按照“逆拓扑序”挑选一个未被染色的强联通分量将其染成黑色，然后把所有与这个强联通分量里的点矛盾的点所在的联通分量染成白色。最后所有染成黑色的强联通分量里的点就是选择的方案。 例题一、NOI2017 游戏题面见P3825 思路对于$a,b,c$，就直接裸的2-SAT。对于$x$，如果直接枚举选$A,B,C$中的哪个，复杂度要乘上$3^d$，但是如果我们考虑枚举x不适合哪辆车，复杂度就乘上$2^d$。 Day3下午一、网络流除了源点和汇点，所有点的输入与输出平衡。 求法Ford-Fulkerson算法DinicSAP等等。。。个人觉得用dinic就够了…… 二、Dinic反向边：用于反悔，保证所有操作可撤销。 优化当前弧优化 三、最小割最小割定理最小割==最大流 例题一、吃饭Dining题面见P2891。 思路把牛拆成两个点，这两个点之间连容量为1的边，原点连食物，食物连牛，牛连饮料，饮料连汇点，跑最大流。 经典最小割模型——最大闭合子图图中的点有点权，点权可正可负，在图中选一些点，如果有边$(u,v)$则选u必选v。 解法建图：对于权值为正$x$的点，从源点连一条容量为$x$的边，权值为负$y$的点，向汇点连一条容量为$y$的边，原图边容量为正无穷（较大值）。 例题二、NOI2006 最大获利题面见P4174。 思路将题目中的边都看成点边对应的点依赖于原图中的点将边转化为点，则该图转化为一个二分图求这个二分图的最大闭合子图就行了。 经典最小割模型——二分图最小点权覆盖给出一个二分图，每个点有非负点权选出一些点构成一个覆盖，求最小点权和 解法源点向左边的点连容量为点权的边，右边的点向汇点连容量为点权的边，求最小割即可。 例题三、游戏一张图，删除每个点的入边有费用$w_i+$，删除每个点的出边有费用$w_i-$，求删除所有边需要的最小费用。 思路将所有入边和出边看成点，同一条边之间连容量无穷大的边，构成一个二分图，求这个二分图的最小点权覆盖就行了。 经典最小割模型——二分图最大点权覆盖给出一个二分图，每个点有非负点权选出一些点构成一个覆盖，求最大点权和 解法点权和减去最大流。 例题四、方格取数问题题面见P2774 思路黑白染色成一个二分图，跑最小割，用全局和-最小割即可。 四、费用流图中的边不仅有容量，还有费用。最小费用最大流：流量最大的情况下费用最小最小费用流：跑最短路，如果途中发现跑某条路径会使费用变大，就停止，最大费用流同理。 例题一、晨跑题面见P2153 思路拆点限流，连边直接跑费用流出解。 经典费用流模型——连续$M$个元素最多选$K$个给定$n$个元素，每个元素有权值$a_i$（可正可负），要求从中选出一些，满足其中任意相邻$M$个元素中只有最多$K$个元素被选出。 解法把题目转换为选$K$次，每次要求选出的点距离大于$M$，建图的时候从每个点$i$向$i+M$连边，容量为1，费用为$a_i$，相邻点之间连边，费用为0容量为$INF$，源点向第一个点连边，容量为$K$费用为0，最后一个点向汇点连边，容量为$INF$费用为0，跑费用流即可。 例题二、数字配对题面见P4068。 思路设$cnt_i$表示第i个数字质因数分解后各质因数的指数和。按照cnt的奇偶性，将这些数字分为两个集合。从源点向所有$cnt_i$为奇数的点连容量为$b_i$，费用为0的边。从所有$cnt_i$为偶数的点向汇点连容量为$b_i$，费用为0的边。对于一对$a_i$和$a_j$，如果$a_i$和$a_j$能匹配且$cnt_i$为奇数，连边，容量为$INF$，费用为$c_i\times c_j$。考虑贪心，跑最大费用最大流，每次跑最长路，在价值总和不小于0的情况下尽量增加流量，如果找不到增广路或者增广下去会使费用小于0则说明找到了答案。 例题三、方格取数问题题面见P2045。 思路拆点，两点之间连两条边，第一条边费用是该点权值，流量是1，另一条边费用是0，流量是$INF$。从源点向左上角连费用为0，流量为$K$的边，右下角向汇点连边，费用为0，流量为$INF$，跑最大费用最大流。 例题四、修车题面见P2053。 思路一个工人拆成$n$个点，表示n个时间段的工人，将$n$辆车与这$m \times n$个点都连起来，容量为1，费用为工人的时间段$\times$输入的时间，源点到车费用为0，流量为1，工人到汇点费用为0，流量为1，跑最小费用最大流即可，最后答案用总时间除以车数。 例题五、费用流题面见P3305。 思路二分最大的容量，跑dinic。 例题六、小M的作物题面见P1361。 思路按题目建图，一个点拆成两个点 五、上下界网络流每条边除了流量上界，还有流量下界。 解法这里借用了这篇博客 感觉总结的非常好①无源汇有上下界可行流（循环流）模型:一个网络,求出一个流,使得每条边的流量必须$\ge L_i$且$\le H_i$,每个点必须满足总流入量$=$总流出量(流量守恒)(这个流的特点是循环往复,无始无终)。可行流算法的核心是将一个不满足流量守恒的初始流调整成满足流量守恒（所有点的流入量$=$流出量）的流。我们可以令每条边的流量为该边的下界得到一个初始流，然后建出这个流的残量网络（每条边的上界与下界之差）。考虑在残量网络上求出一个附加流，使得附加流与可行流合并之后达到流量守恒，即：1)如果某个点在所有边流量等于下界的初始流中满足流量守恒,那么这个点在附加流中也满足流量守恒,2)如果某个点在初始流中的流入量比流出量多$x$,那么这个点在附加流中的流出量比流入量多$x$.3)如果某个点在初始流中的流入量比流出量少$x$,那么这个点在附加流中的流出量比流入量少$x$.$x$可以通过枚举点$i$的所有连边求出，开一个数组$A[]$，统计$i$点的流入量-流出量大小，根据$A_i$的正负表示流入量与流出量的大小关系。我们在残量网络中加入一些点和边，首先是虚拟超级源$ss$和虚拟超级汇$tt$。如果$A_i&lt;0$，从$i$向$tt$连一条容量为$-A_i$的边，反之从$ss$向$i$连一条容量为$A_i$的边。最后在建出的图上跑最大流，如果$ss$和$tt$连接的边都是满流的说明存在可行流，每条边在可行流中的流量$=$容量下界$+$附加流中它的流量（即反向边的权值）。 ②有源汇有上下界可行流模型:现在的网络有一个源点$s$和汇点$t$,求出一个流使得源点的总流出量等于汇点的总流入量,其他的点满足流量守恒,而且每条边的流量满足上界和下界限制。从$t$向$s$连一条下界为0，上界为$INF$的边，改成无源汇上下界可行流，跑完之后拆掉这条边就得到有源汇上下界可行流。最终的流量为这条边的反向边流量。 ③有源汇有上下界最大流模型:现在的网络有一个源点$s$和汇点$t$,求出一个流使得源点的总流出量等于汇点的总流入量,其他的点满足流量守恒,而且每条边的流量满足上界和下界限制。在这些前提下要求总流量最大。先跑出可行流，再在残量网络上跑出$s-t$最大流，最终的最大流$=$可行流流量$+$新增广出的$s-t$流量。 ④有源汇有上下界最小流模型:现在的网络有一个源点$s$和汇点$t$,求出一个流使得源点的总流出量等于汇点的总流入量,其他的点满足流量守恒,而且每条边的流量满足上界和下界限制。在这些前提下要求总流量最小。还是先跑出可行流，然后再残量网络上跑出$t-s$最大流，最终的最小流$=$可行流-$t-s$的最大流。]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day2]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day2%2F</url>
    <content type="text"><![CDATA[Day2上午一、基本分治例题一、归并排序如题…基础排序之一。 二、树分治①点分治原则上要尽量减小递归层，而考虑删去当前某节点之后，剩余节点数量最多的联通块尽量少，此时递归层数一定是最小的。这个节点就是“重心”。重心可以$O(n)$DP求得 例题一、IOI2011 Race给定一颗$n$个点的带边权的树，求一条路径使得权值和为$K$且边数量最少。$1\le n \le10^5,K\le10^6$ 思路点分治，记录到根路径长为dist[i]的最小边数即可 ②边分治选择一条边删去，得到两颗不相交的子树，统计这条边的信息。选边方法与点分治的选点几乎一致。 一个优化我们发现菊花图可以轻松卡掉边分，于是我们考虑重构这颗树，使得度数最大的点度数最小，采用的策略是加虚点（个人喜欢左孩子右兄弟）关键是两点间路径经过的实边不能变。 例题二、bzoj2870题面见bzoj2870 思路采用边分治。考虑删去一条边以后这条边的两端$a,b$，考虑将a端子树和b端子树中的链按点权最小值排序，对a端来说，每条链选b端中点权最小值不小于这条链且最长的链，b端同理，如此就可以做出这道题。 ③链分治（树链剖分）略（太过于模板） 三、CDQ分治普通分治：将区间分成两部分递归求解后合并。CDQ分治：在普通分治基础上需要加上左半区间对右半区间对贡献得到答案 例题一、二维偏序（上一篇好像有一样的题） 思路首先进行双关键字排序根据CDQ分治，不断递归至区间长度为1关键在于计算贡献考虑到子区间贡已经求出，我们将两个区间按第二维进行排序，如果左区间的一个有序对$(u,v)$对右区间的一个有序对$(a,b)$产生贡献，那么就等价于$v&lt;b$，双指针扫一遍即可。又考虑到我们按b排序，显然用归并复杂度比较优秀。 四、整体二分整体二分需要满足五个性质：①询问的答案具有可二分性（单调性）②修改对询问是独立互不影响的。③不同的修改贡献可叠加，不用重复计算④贡献满足交换律、结合律，有可加性⑤题目允许离线实现起来就是将所有询问一起二分 例题一、Meteors题面见SP10264 二分答案，线段树模拟当前区间的修改 五、三分用于求解凸函数（单峰函数） 六、分块整块整体做，边角暴力做 七、莫队将询问离线排序，优化暴力过程。 八、树上莫队借助欧拉序（括号序）将树上问题转换成区间问题，其余与莫队大致相同。 九、块状链表略 Day2下午今天下午是考试，结果…T1文件名写错，T2感觉没问题莫名wa掉，T3空间开小——完美爆0（解决上述问题后拿到60分暴力分）然后发现T2逆序对求错。。。总之以后细心更重要。题目暂时就不贴了。。。打完再来发]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day1]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day1%2F</url>
    <content type="text"><![CDATA[Day1 上午——高级数据结构一、树状数组基本功能1.单点修改，前缀信息查询2.区间修改可减信息，单点查询 对lowbit的理解保留x中最后一位1（由位运算实现）1#define lowbit(x) (x&amp;-x) 例题一:矩形数点给定$n$个点坐标($x_i$,$y_i$)，q次询问，每次询问给出一个矩形的右上角坐标和左下角坐标，求矩形内包含给定点的个数n, q $\leq$ $10^5$，0 $\leq$ $x_i$, $y_i$ $\leq$ $10^9$ 思路首先用容斥原理把矩形拆型四个二维偏序区域（形如$\sum$[$x_i$ $\leq$ $x$, $y_i$ $\leq$ $y$]）将数据离散化，排序，此时$x$自然满足偏序结构，用树状数组根据$y$值维护前缀和即可 复杂度O((n+q)logn) 例题二:逆序对给定一个长度为$n$的序列，可以将其中任意个数字取相反数，求可以得到的最少逆序对数$n$ $\le$ $10^5$，$\left|A_i \right|$ $\le$ $10^9$ 思路对于每个数字，我们发现$A_i$的正负只影响绝对值比$A_i$小的数，所以求出每个数$A_i$前后分别有多少数绝对值大于$A_i$，取较少的那一个就行了 二、线段树例题一、序列操作给定长度为$n$的序列$A$，执行$q$次操作，支持区间加、区间赋值、查询区间和、查询区间最大值 思路线段树模板 例题二、环上连续最大和给定一个长度为$n$的环形序列$A$，其中$A_1$与$A_n$是相邻的。$q$次操作，每次操作更改$A_x=v$。对于每次修改输出最大连续和$n,q\le10^5,1\le x\le n,\left|A_i\right|,\left|v\right|\le10^9$ 思路线段树维护一下最小前缀和，最小后缀和与最小连续和，考虑到题目中的序列为环形，最大环形序列可能是两段互不相交的前缀与后缀，用总和减去最小子序列就行了。 例题三、SDOI2016 游戏题面见P4069 思路树链剖分+李超线段树 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;bits/stdc++.h&gt;#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 2e5 + 5;const ll INF = 123456789123456789;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg ll num = 0; rg char ch; rg bool flag = false; while ((ch = getchar()) == ' ' || ch == '\n' || ch == '\r'); if (ch == EOF)return ch; if (ch == '-')flag = true; else num = ch ^ 48; while ((ch = getchar()) != ' '&amp;&amp;ch != '\n'&amp;&amp;ch != '\r'&amp;&amp;~ch) num = (num &lt;&lt; 1) + (num &lt;&lt; 3) + (ch ^ 48); if (flag)return -num; return num; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;ll pos[N], id, ssize[N], fa[N], p[N], w[N], b[N], h[N], nt[N], num, son[N], deep[N], belong[N], dist[N];inl void add(rg ll z, rg int y, rg int x)&#123; b[++num] = y, w[num] = z; nt[num] = p[x], p[x] = num; b[++num] = x, w[num] = z; nt[num] = p[y], p[y] = num;&#125;void dfs1(rg int x)&#123; ssize[x] = 1; for (rg int e = p[x]; e; e = nt[e]) &#123; rg int k = b[e]; if (k == fa[x])continue; fa[k] = x, deep[k] = deep[x] + 1; dist[k] = dist[x] + w[e]; dfs1(k); if (ssize[son[x]] &lt; ssize[k])son[x] = k; ssize[x] += ssize[k]; &#125;&#125;void dfs2(rg int x, rg int chain_number)&#123; belong[x] = chain_number; pos[x] = ++id; h[id] = x; if (son[x])dfs2(son[x], chain_number); for (rg int e = p[x]; e; e = nt[e]) &#123; rg int k = b[e]; if (k == fa[x] || k == son[x])continue; dfs2(k, k); &#125;&#125;struct Line &#123; ll k, b; Line() &#123; k = 0, b = INF; &#125; Line(rg ll k, rg ll b) :k(k), b(b) &#123;&#125;&#125;;struct Node &#123; int left, right; ll min, l, r; Line delta; Node() &#123; min = INF; delta.b = INF; &#125;&#125;tree[N &lt;&lt; 2];void build(rg int x, rg int l, rg int r)&#123; tree[x].left = l, tree[x].right = r; if (l == r) &#123; tree[x].l = tree[x].r = dist[h[l]]; return; &#125; rg int mid = l + r &gt;&gt; 1; build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r); tree[x].l = tree[x &lt;&lt; 1].l; tree[x].r = tree[x &lt;&lt; 1 | 1].r;&#125;inl ll f(rg ll x, rg ll k, rg ll b) &#123; return k * x + b; &#125;inl void apply(rg int x, rg ll k, rg ll b)&#123; rg ll nl = f(tree[x].l, k, b), nr = f(tree[x].r, k, b), l = f(tree[x].l, tree[x].delta.k, tree[x].delta.b), r = f(tree[x].r, tree[x].delta.k, tree[x].delta.b); if (nl &lt;= l &amp;&amp; nr &lt;= r) &#123; tree[x].delta = Line(k, b); tree[x].min = fast_IO::min(tree[x].min, fast_IO::min(nl, nr)); return; &#125; if (nl &gt; l&amp;&amp;nr &gt; r)return; rg ll tmp = (b - tree[x].delta.b) / (tree[x].delta.k - k); rg ll mid = tree[x &lt;&lt; 1].r; if (nl &lt;= l || tmp &lt;= mid)apply(x &lt;&lt; 1, k, b); if (nr &lt;= r || tmp &gt; mid)apply(x &lt;&lt; 1 | 1, k, b); tree[x].min = fast_IO::min(tree[x].min, fast_IO::min(tree[x &lt;&lt; 1].min, tree[x &lt;&lt; 1 | 1].min));&#125;void addline(rg int x, rg int l, rg int r, rg ll k, rg ll b)&#123; if (tree[x].left &gt;= l &amp;&amp; tree[x].right &lt;= r) &#123; apply(x, k, b); return; &#125; rg int mid = tree[x].left + tree[x].right &gt;&gt; 1; if (l &lt;= mid)addline(x &lt;&lt; 1, l, r, k, b); if (r &gt; mid)addline(x &lt;&lt; 1 | 1, l, r, k, b); tree[x].min = fast_IO::min(tree[x].min, fast_IO::min(tree[x &lt;&lt; 1].min, tree[x &lt;&lt; 1 | 1].min));&#125;inl void addLine(rg int x, rg int y, rg ll k, rg ll b)&#123; while (belong[x] != belong[y]) &#123; if (deep[belong[x]] &lt; deep[belong[y]])jh(x, y); addline(1, pos[belong[x]], pos[x], k, b); x = fa[belong[x]]; &#125; if (pos[x] &gt; pos[y])jh(x, y); addline(1, pos[x], pos[y], k, b);&#125;inl int LCA(rg int x, rg int y)&#123; while (belong[x] != belong[y]) &#123; if (deep[belong[x]] &lt; deep[belong[y]])jh(x, y); x = fa[belong[x]]; &#125; if (deep[x] &lt; deep[y])return x; return y;&#125;inl void tian()&#123; rg int s = fast_IO::read(), t = fast_IO::read(); rg ll k = fast_IO::read(), b = fast_IO::read(); rg int lca = LCA(s, t); addLine(s, lca, -k, k*dist[s] + b); addLine(lca, t, k, k*dist[s] - 2 * k*dist[lca] + b);&#125;ll querymin(rg int x, rg int l, rg int r)&#123; rg ll ans = INF, mid = tree[x].left + tree[x].right &gt;&gt; 1; if (l &lt;= tree[x].left&amp;&amp;r &gt;= tree[x].right)return tree[x].min; if (l &lt;= mid)ans = fast_IO::min(ans, querymin(x &lt;&lt; 1, l, r)); if (r &gt; mid)ans = fast_IO::min(ans, querymin(x &lt;&lt; 1 | 1, l, r)); l = fast_IO::max(l, tree[x].left), r = fast_IO::min(r, tree[x].right); ans = fast_IO::min(ans, f(dist[h[l]], tree[x].delta.k, tree[x].delta.b)); ans = fast_IO::min(ans, f(dist[h[r]], tree[x].delta.k, tree[x].delta.b)); return ans;&#125;inl ll queryMin(rg int x, rg int y)&#123; rg ll ans = INF; while (belong[x] != belong[y]) &#123; if (deep[belong[x]] &lt; deep[belong[y]])jh(x, y); ans = fast_IO::min(ans, querymin(1, pos[belong[x]], pos[x])); x = fa[belong[x]]; &#125; if (pos[x] &gt; pos[y])jh(x, y); return fast_IO::min(ans, querymin(1, pos[x], pos[y]));&#125;inl ll query()&#123; rg int s = fast_IO::read(), t = fast_IO::read(); return queryMin(s, t);&#125;int main(void)&#123; rg int n = fast_IO::read(), m = fast_IO::read(); for (rg int i = 1; i != n; ++i)add(fast_IO::read(), fast_IO::read(), fast_IO::read()); dfs1(1), dfs2(1, 1), build(1, 1, n); while (m--) switch (fast_IO::read()) &#123; case 1:tian(); break; case 2:printf("%lld\n", query()); break; &#125; return 0;&#125; 三、可并堆（左偏树）左偏树呈二叉树结构，除维护权值信息外，还需要维护子树内最近叶结点的距离$d_x$。 例题一、Dispatching题面见P1552。 思路考虑到如果某个忍者当管理员时不选$x$忍者，那么这个忍者的直接上级一定不会选$x$。使用左偏树维护以$x$为根子树内派遣忍者名单，它需要满足大根堆的性质，不断删除堆顶直到总和$\le m$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e5 + 5;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg ll num = 0; rg char ch; rg bool flag = false; while ((ch = getchar()) == ' ' || ch == '\n' || ch == '\r'); if (ch == EOF)return ch; if (ch == '-')flag = true; else num = ch ^ 48; while ((ch = getchar()) != ' '&amp;&amp;ch != '\n'&amp;&amp;ch != '\r'&amp;&amp;~ch) num = (num &lt;&lt; 1) + (num &lt;&lt; 3) + (ch ^ 48); if (flag)return -num; return num; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;int fa[N], n, lson[N], rson[N], d[N], root[N], ssize[N];ll c[N], m, l[N], sum[N], ans;int merge(rg int x, rg int y)&#123; if (!x || !y)return x | y; if (c[x] &lt; c[y])jh(x, y); rson[x] = merge(rson[x], y); if (d[lson[x]] &lt; d[rson[x]])jh(lson[x], rson[x]); d[x] = d[rson[x]] + 1; return x;&#125;int main(void)&#123; n = fast_IO::read(), m = fast_IO::read(); for (rg int i = 1; i &lt;= n; ++i) fa[i] = fast_IO::read(), sum[i] = c[i] = fast_IO::read(), l[i] = fast_IO::read(), root[i] = i, ssize[i] = 1, ans = fast_IO::max(ans, l[i]); for (rg int i = n; i != 1; --i) &#123; root[fa[i]] = merge(root[i], root[fa[i]]); sum[fa[i]] += sum[i]; ssize[fa[i]] += ssize[i]; while (sum[fa[i]] &gt; m) &#123; sum[fa[i]] -= c[root[fa[i]]]; root[fa[i]] = merge(lson[root[fa[i]]], rson[root[fa[i]]]); --ssize[fa[i]]; &#125; ans = fast_IO::max(ans, l[fa[i]] * ssize[fa[i]]); &#125; fast_IO::write(ans); return 0;&#125; 线段树的合并线段树要合并，必须要有相同的结构，均摊复杂度$O(log n)$。 四、平衡树Treap——Treep=Tree+HeapTreap通过单旋保持堆性质。树高期望$O(logn)$ 启发式合并合并两棵$Treap$的时候，只需要暴力遍历较小的 Treap 提取所有结点，然后依次插入到较大的$Treap$之中就好了。很多数据结构都可以用启发式合并 例题一、Peaks题面见P4197 思路将道路和询问混在一起排序，进行$Kruskal$算法的同时用$Treap $维护连通分量内所有山峰的高度。 SplaySplay借助双旋操作（zig_zag）。 例题二、序列终结者题面见P4146。 思路Splay维护翻转、子树最值、addv标记。 例题三、三维偏序思路线段树套平衡树 Day1 下午五、嵌套数据结构嵌套数据结构的思想是将普通的数据结构维护的信息拓展成另一种数据结构（可能与第一维数据结构相同） 树套树常见的有树状数组套平衡树，线段树套权值线段树等。注意，第一维的数据结构应该尽量简单，可以节约空间减小时间复杂度。 例题一、Mokia题面见P4390。 思路树状数组套Splay 六、可持久化线段树（主席树）可持久化数据结构可持久化数据结构就是利用函数式编程的思想使其支持询问历史版本，同时充分利用它们之间的共同数据来减少时间和空间消耗 大致的思想就是只新建不修改，保存历史版本 例题一、静态区间第k小题面见P3834。 思路主席树模板题 七、动态树（Link-Cut-Tree）不是很懂。。。弄明白以后再补 总结数据结构是很重要的基础。讲课好快…今天的例题只敲出来两个，其他的还得以后慢慢做]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2019%2F04%2F11%2Fhello%2F</url>
    <content type="text"><![CDATA[我的第一篇blogLaTeX测试$\sum\limits_{i=1}^{n}a_b^c$ 理综答题卡模板 答题卡物理选择题 题号 14 15 16 17 18 19 20 21 答案 非选择题22.23.24.25.33.化学选择题 题号 7 8 9 10 11 12 13 答案 非选择题26.27.28.36.生物选择题 题号 1 2 3 4 5 6 答案 非选择题29.30.31.32.37.数学答题卡模板选择题 题号 1 2 3 4 5 6 7 8 9 10 11 12 答案 填空题13.14.15.16. 解答题17.18.19.20.21.22.]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
