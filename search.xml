<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[动态规划（二）]]></title>
    <url>%2F2020%2F11%2F05%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[DP的优化形式优化决策单调性优化斜率优化凸单调性DP优化容斥DP]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划（一）]]></title>
    <url>%2F2020%2F10%2F28%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[DP类型DP的一般形式是表示出能代表出与后续或答案有关的当前的状态，并在这些状态中进行转移DP的难点在于状态的设计和转移的优化。由于DP属于一种思想，不同的情况下状态设计和转移都不一样，下面对于每种DP都会给出问题来讲解。 序列DP将问题放在序列上，在序列上设计状态和转移，是一种非常常见的DP。题目：洛谷P2519 [HAOI2011]problem a 模型建立求最少有多少人没说真话，可以先求最多有多少人说真话。我们考虑将所有人的成绩排序后的一个序列A。第i个人说的是真话，当且仅当$A_{a_i+1}=…=A_{n-b_i}$，将这个区间看成一条线段，这样的话n个人就是n条线段。不难发现，如果两条线段相交但不重合，说明两个人中至少一人说了谎，而且对某一线段重合的线段个数不能超过线段的长度（包含的点数）。这样的话，我们的问题就转化成，对于n个线段，选出最多的线段个数，使得这些线段要么不相交，要么完全重合且对于同一个线段重合的线段个数不超过该线段的长度。 状态设计及转移优化重合的线段我们都放到一起，记一个总数并与长度取较小值，这样的话任意两条线段都是不重合的，那么就只用考虑不相交了如何我们以右端点为第一关键字，以左端点为第二关键字进行排序，显然我们遍历所有线段，那么如何设计状态呢？设dp[i]为前i个线段中能选的线段的最多个数，那么转移方程显然为$dp[i]=dp[last]+cnt$，其中last为右端点小于i左端点的最后一个线段，cnt为前面提到的总数。对每个i枚举j，复杂度为$O(n^2)$，所以我们要对这部分进行优化。考虑到我们的线段是以r为右端点为第一关键字排序的，也就是说线段的右端点是有序的，那么我们就可以二分找到右端点比i的左端点小的最靠后的线段，将dp记录成前缀最大值，就可以$O(\log n)$查找线段，$O(1)$转移了。 Solution(Accepted)1234567891011121314151617181920212223242526272829303132333435363738struct Segment &#123; int l, r, cnt; Segment() &#123;&#125; Segment(int l, int r): l(l), r(r) &#123; cnt = 1; &#125; bool operator &lt;(const Segment s)const &#123; return r &lt; s.r || (r == s.r &amp;&amp; l &lt; s.l); &#125;&#125;s[N], S[N];int dp[N];//二分查找，找到需要的线段int bin(int l, int r, int x) &#123; while (l &lt;= r) &#123; int mid = l + r &gt;&gt; 1; if (S[mid].r &lt;= x)l = mid + 1; else r = mid - 1; &#125; return r;&#125;int main(void) &#123; int n = fast_IO::read(), tot = 0; for (int i = 1; i &lt;= n; ++i) s[i] = Segment(fast_IO::read() + 1, n - fast_IO::read()); sort(s + 1, s + n + 1); for (int i = 1; i &lt;= n; ++i) &#123; if (s[i].l &gt; s[i].r)continue; if (s[i].l == s[i - 1].l &amp;&amp; s[i].r == s[i - 1].r) &#123; if (S[tot].cnt &lt; S[tot].r - S[tot].l + 1) ++S[tot].cnt; &#125; else S[++tot] = s[i]; &#125; dp[1] = S[1].cnt; for (int i = 2; i &lt;= tot; ++i) &#123; int pre = bin(1, i - 1, S[i].l - 1); dp[i] = max(dp[i - 1], dp[pre] + S[i].cnt);//转移 &#125; fast_IO::write(n - dp[tot]); return 0;&#125; 区间DP数位DP数位DP常用于统计或查找一个区间满足条件的数，然后按数位顺序DP，一般需要仔细分情况讨论。常见处理方式有：拆成[1,R]和[1,L)，记忆化，预处理等。洛谷P2657 [SCOI2009] windy 数 状态建立及转移一道相当常规的数位DP，我们可以将[L,R]的答案拆成[1,R]-[1,L-1]的答案，这样的话我们只要能计算1到x的windy数就可以了。我们设dp[i][j]表示i位数最高位为j时的windy数，显然的转移是$dp[i][j]=sum(dp[i-1][k])$，其中k满足$abs(k-j)\ge 2$接下来我们就用dp来求解[1,x]的所有windy数12345678910111213141516171819202122232425262728293031323334353637383940414243444546int dp[N][N], num[N];void presolve() &#123; for (int i = 0; i &lt;= 9; ++i)dp[1][i] = 1; //这里要包括0的原因是我们dp的过程中，类似于20 30这些数依然是windy数，所以0虽然不是windy数，但却能产生贡献 for (int i = 2; i &lt;= 10; ++i) &#123; for (int j = 0; j &lt;= 9; ++j) &#123; for (int k = 0; k &lt;= 9; ++k) &#123; if (abs(j - k) &lt;= 1)continue; dp[i][j] += dp[i - 1][k]; //为什么这里j k要从0开始呢？这是考虑到我们会求在高位都一定时，从某位开始的所有windy数 //此时这些位就可能是0了 &#125; &#125; &#125;&#125;int solve(int x) &#123; if (!x)return 0; int ans = 0; for (*num = 0; x; x /= 10) num[++*num] = x % 10; for (int i = *num - 1; i &gt;= 1; --i) for (int j = 1; j &lt;= 9; ++j)//这里j不从0开始的原因很简单，j为0的话实际上数字就不是i位了，会重复计算 ans += dp[i][j]; //唯独*num位数最麻烦 for (int i = 1; i &lt; num[*num]; ++i) ans += dp[*num][i]; //接下来专注于最高位为num[*num]时的*num位数 for (int i = *num - 1; i &gt;= 1; --i) &#123; //从次高位开始一直到最低位，每一步计算当前位比num[i]小的数的所有贡献（因为后面的所有数都能取到， //只用考虑当前位与高一位是否冲突），之后只剩这一位为num[i]的情况，我们就再去求下一位的所有贡献 for (int j = 0; j &lt; num[i]; ++j) &#123; if (abs(j - num[i + 1]) &gt;= 2) ans += dp[i][j]; &#125; if (abs(num[i + 1] - num[i]) &lt; 2)return ans; //这时已经不可能再有多的贡献，因为在接下来的计算中我们的前提就是前面的所有位都是确定的，所以此处必然使剩下的所有数不成立 &#125; return ans + 1;//上面的计算并没有包括自身，此处要加上自身&#125;int main(void) &#123; presolve(); int l = fast_IO::read(), r = fast_IO::read(); fast_IO::write(solve(r) - solve(l - 1)); return 0;&#125; 概率DP概率DP是求事件概率或期望的DP的总称。对于求概率问题，有时利用补集转化，或者将其转化为计数问题；对于求期望问题，大多时候利用期望的线性性来解决问题。 贝叶斯公式条件概率$P(y|x)$联合概率$P(y,x)$$P(x,y)=P(y|x)P(x)=P(x)P(y)$$P(x,y)=P(x|y)P(y)$贝叶斯公式：$P(y|x)=\dfrac{P(x|y)P(y)}{P(x)}$ 例题：期望的线性性洛谷P3239 [HNOI2015]亚瑟王题目概述：给你$N$张牌，每张牌有一个发动概率$P_i$以及伤害$D_i$。共有$R$回合，每回合会按编号从小到大依次考虑本次游戏中还未发动的卡牌，依次尝试发动；如果发动成功，进入下一回合。求期望伤害之和。共$T$组数据。$T\le 444,N\le 220,R\le 132$ 这个题如果直接去算每一局的期望，非常难设状态（需要状压），而根据期望的线性性，我们考虑每张牌被发动的概率，那么总伤害就为每张牌造成的期望伤害之和。我们设dp[i][j]表示前i张牌中一共出了j张的概率，sump[x]表示x这张牌在整局游戏中被打出来的概率。对于转移，首先我们来看sump的转移，我们枚举前i-1张牌中出牌数j，由题意可知i之前打出的j张牌都不会考虑到第i张牌（因为打出去以后本轮就结束了），同时也说明有r-j轮可能会考虑到第i张牌，于是我们的转移方程就出来了，$sump[i]=\sum\limits_{j=0}^rdp[i-1][j]\cdot(1-(1-p[i])^{r-j})$，此处要注意，我们将“中间某处选第i张牌”采用了补集转换的思想，因为求出“中间没有任何一处选第i张牌”显然是更方便的。再来看看dp[i][j]的转移，这里显然要分两种情况讨论：是否选择了当前的第i张牌： 没有选择，那么$dp[i][j]=dp[i-1][j]\cdot (1-p[i])^{r-j}$，与上面类似，这里是后面r-j轮都不选i 若选择了，那么$dp[i][j]=dp[i-1][j-1]\cdot(1-(1-p[i])^{r-j+1})$，也是类似，前j-1张不可能选到i 最后答案即为$\sum\limits_{i=1}^nsump[i]\times d[i]$ 1234567891011121314151617181920212223242526272829303132double p[N], dp[N][N], sump[N], sum[N][N];int d[N];int main() &#123; int T = fast_IO::read(); while (T--) &#123; memset(dp, 0, sizeof(dp)); memset(sump, 0 , sizeof(sump)); int n = fast_IO::read(), r = fast_IO::read(); for (int i = 1; i &lt;= n; ++i) scanf("%lf%d", p + i, d + i); for (int i = 1; i &lt;= n; ++i) &#123; sum[i][0] = 1; for (int j = 1; j &lt;= r; ++j) sum[i][j] = sum[i][j - 1] * (1 - p[i]); //注意到我们后面总是用到1-p[i]的幂，先预处理 &#125; dp[1][0] = sum[1][r]; dp[1][1] = sump[1] = 1 - sum[1][r]; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= r; ++j) &#123; sump[i] += dp[i - 1][j] * (1 - sum[i][r - j]); dp[i][j] += dp[i - 1][j] * sum[i][r - j]; if (j)dp[i][j] += dp[i - 1][j - 1] * (1 - sum[i][r - j + 1]); &#125; &#125; double ans = 0; for (int i = 1; i &lt;= n; ++i)ans += sump[i] * d[i]; printf("%.10f\n", ans); &#125; return 0;&#125; 树形DP树形DP是指基于树形结构的动态规划，一般有： 树的直径：DP记录子树内的最长路 树的重心：DP记录子树大小 树上点权独立集：DP记录子树的根是否选择 树形依赖背包：在dfs序上DP，或通过将父节点的DP值传入孩子DP 虚树：后面会重点讲 … 虚树在原树上保留需要的点和它们的LCA的树成为虚树，换句话说，我们尽可能合并了中间的点。 状压DPDP套DP背包专题背包是线性DP中的重要模型 0/1背包所谓0/1背包，就是一堆物品分别有价值w[i]和占用空间v[i]，每种物品都是一个，现在要用空间大小为m的背包装物品，求出所装物品的价值和最大值是多少。而最基础的想法，就是直接设状态$dp[i][j]$表示前i个物品中用大小为j的背包能得到的最大价值，转移也很明显$dp[i][j]=max\{dp[i-1][j-v[i]]+w[i]|v[i]\le j\le m\}$。我们发现每次转移只和上一行有关，于是可以用滚动数组优化空间。更仔细地观察发现，我们都是用前面的值去更新后面的值，于是我们改变j的枚举顺序，从大到小枚举，就可以只用一维数组来达到目的。这样的话空间复杂度$O(m)$，时间复杂度$O(nm)$ 123for (i = 1; i &lt;= n; ++i) for (j = m; j &gt;= v[i]; --j) dp[j] = max(dp[j], dp[j - v[i]] + w[i]); 完全背包完全背包就是在0/1背包的基础上对物品的个数没有限制，求相同的问题。其实只要我们把上面优化过的0/1背包改变枚举顺序，就是完全背包了，因为我们允许对同一个物品重复选择。123for (i = 1; i &lt;= n; ++i) for (j = v[i]; j &lt;= m; ++j) dp[j] = max(dp[j], dp[j - v[i]] + w[i]); 多重背包上面两种背包都是非常特殊的情况，更一般的，我们考虑每个物品i分别有$C[i]$个，那么问题就变成了多重背包。一种非常暴力的做法就是将$C[i]$个物品全部拆开，将问题变成0/1背包，这样的话时间复杂度是$O(\sum\limits_{i=1}^nC[i]m)$。这个复杂度是比较高的，那么有没有什么更好的办法呢？ 二进制拆分我们还是考虑将$C[i]$拆分，但我们采用更优秀的拆分方法，使得拆出来的物品尽量少，而且这些物品的组合可以表示$1\sim C[i]$中的任何一个数。我们考虑将其拆分成$C[i]=2^0+2^1+2^2+…+2^k+rest,rest&lt;2^{k+1}$，这样的话对于$x&lt;2^{k+1}$都可以很容易凑出，而对于$2^{k+1}\le x\le C[i]$，我们发现$x-rest&lt; 2^{k+1}$，也就是说$x-rest$是可以通过前面的部分组合出来的，因此我们可以组合出任意一个x。 123456//C进行拆分for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; (1 &lt;&lt; j) &lt;= C[i]; ++j) vt[++tot] = (1 &lt;&lt; j) * v[i], wt[tot] = (1 &lt;&lt; j) * w[i]; if (C[i])vt[++tot] = C[i] * v[i], wt[tot] = C[i] * w[i];&#125; 这样同样将问题转化成了0/1背包，但是时间复杂度更优秀，为$O(nm\log\max(C_i))$。 单调队列优化我们仔细观察转移的过程，寻找规律，来看看转移方程$dp[i][j]=\max\{dp[i-1][j],dp[i-1][j-k\cdot v[i]]+k\cdot w[i]|k\in [1,\min(\dfrac{m}{C[i]},C[i])]\}$我们发现，j mod v[i]相同时的j之间才会产生转移，于是我们可以按这个进行分组。而考虑到能转移到j的是区间$[j-C[i]*v[i],j]$的最大值，因此我们用复杂度优秀的单调队列来完成维护最大值的工作。那么总复杂度是多少呢？我们枚举了n类物品，对每类物品i分成C=v[i]类，枚举k的范围是$\dfrac{m}{v[i]}$，因此总复杂度为$O(nm)$ 1234567891011for (int i = 1; i &lt;= n; ++i) &#123; for (int ret = 0; ret &lt; v[i]; ++ret) &#123; head = 1, tail = 0; for (int k = 0; k * v[i] + ret &lt;= m; ++k) &#123; while (tail &gt;= head &amp;&amp; k - q[head] + 1 &gt; C[i])++head; dp[i][k * v[i] + ret] = dp[i - 1][q[tail] * v[i] + ret] + k * w[i]; while (tail &gt;= head &amp;&amp; dp[i - 1][q[tail] * v[i] + ret] &lt; dp[i][k * v[i] + ret])--tail; q[++tail] = k; &#125; &#125;&#125; 分组背包给定N组物品，规定每组物品中最多选一个，求大小为m的背包能装的最大价值。事实上我们只需要先枚举组，再枚举背包的容量，再枚举组内物品就行了。倒序枚举背包容量，空间复杂度降到一维。1234for (int i = 1; i &lt;= n; ++i) for (int j = m; j &gt;= 0; --j) for (int k = 1; k &lt;= C[i]; ++k) dp[j] = max(dp[j], dp[j - v[i][k]] + w[i][k]); 树上背包咕咕咕]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学（一）]]></title>
    <url>%2F2020%2F10%2F28%2F%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[字符串（一）]]></title>
    <url>%2F2020%2F10%2F28%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[不讲道理算法]]></title>
    <url>%2F2020%2F10%2F28%2F%E4%B8%8D%E8%AE%B2%E9%81%93%E7%90%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[个人觉得分块和莫队都是相当暴力不讲道理的算法 分块首先来说说分块。顾名思义，把一段区间分成一块一块的。分成一块块的有什么好处呢？如果我们要进行区间修改区间查询，当这个区间中包含了整个块时，如果我们知道了这个块的一些信息，就没必要对块内的元素一个个进行修改或查询，如此就达到了降低复杂度的目的。于是分块的策略就很清楚了，对于当前操作的区间[L,R]，对于其中的整块我们整体修改或查询，而两边可能有的非整块元素则暴力修改，再将两端所属的块更新，这些元素个数显然不会超过两个块的大小，所以时间复杂度就有了保证。那么块的大小应该怎么确定呢？理论上，如果区间长度为$n$，则当块大小为$\sqrt{n}$时时间复杂度是最优的，每次操作复杂度为$O(\sqrt{n})$。123456789101112131415161718192021222324252627282930313233//以区间加和区间求和为例void update(int l, int r, ll data) &#123; if (bel[l] == bel[r]) &#123; for (int i = l; i &lt;= r; ++i) a[i] += data; block[bel[l]].sum += (r - l + 1) * data; return; &#125;//同一块直接改 for (int i = l; i &lt;= bel[l] * nbl; ++i) a[i] += data;//左边角 block[bel[l]].sum += (bel[l] * nbl - l + 1) * data; for (int i = bel[l] + 1; i &lt; bel[r]; ++i) block[i].sum += nbl * data, block[i].del += data;//中间整块 for (int i = (bel[r] - 1) * nbl + 1; i &lt;= r; ++i) a[i] += data;//右边角 block[bel[r]].sum += (r - (bel[r] - 1) * nbl) * data;&#125;//查询也类同ll query(int l, int r) &#123; ll ans = 0; if (bel[l] == bel[r]) &#123; for (int i = l; i &lt;= r; ++i) ans += a[i] + block[bel[i]].del; return ans; &#125; for (int i = l; i &lt;= bel[l] * nbl; ++i) ans += a[i] + block[bel[i]].del; for (int i = bel[l] + 1; i &lt; bel[r]; ++i) ans += block[i].sum; for (int i = (bel[r] - 1) * nbl + 1; i &lt;= r; ++i) ans += a[i] + block[bel[i]].del; return ans;&#125; 莫队莫队是在分块的基础上，更暴力的一种算法。对于只有查询的题目，我们可以通过移动l r指针，计算相应的添加或者删除某个元素得到的贡献来得到所有查询的答案，但是这样的话复杂度可能达到$n^2$。由于只有查询，我们可以将这些要查询的区间改变顺序，使得两个指针移动的距离尽量减少，从而达到降低复杂度的目的。考虑将整个区间分块，然后将所有查询进行双关键字排序，第一关键字为左端点所在的块，第二关键字为右端点本身。这样的话，对于左端点，在同一块内的转移每次不会超过$\sqrt{n}$，不同块之间的转移不会超过$\sqrt{n}$；对于右端点，在左端点在同一块时，右端点是单调不降的，即最多$n$，而在左端点不同块之间的转移不会超过$\sqrt{n}$因此总时间复杂度为$O(n\sqrt{n})$。1234567891011121314151617181920212223242526272829303132struct Query &#123; int l, r, id; Query() &#123;&#125; Query(int r, int l, int id): l(l), r(r), id(id) &#123;&#125; bool operator &lt;(const Query s)const &#123; return bel[l] &lt; bel[s.l] || (bel[l] == bel[s.l] &amp;&amp; r &lt; s.r); &#125;&#125;q[N];//双关键字排序void ins(int x) &#123; ... //此处对新加进来的元素计算贡献&#125;void del(int x) &#123; ... //此处删去某个元素的贡献&#125;int main() &#123; ... for (int i = 1; i &lt;= n; ++i)bel[i] = (i - 1) / *bel + 1; ... sort(q + 1, q + m + 1); int l = 1, r = 0; for (int i = 1; i &lt;= m; ++i) &#123; while (r &lt; q[i].r)ins(++r); while (l &gt; q[i].l)ins(--l); while (r &gt; q[i].r)del(r--); while (l &lt; q[i].l)del(l++); //直接移动l r指针计算贡献 ANS[q[i].id] = ans;//记录答案 &#125; for (int i = 1; i &lt;= m; ++i) printf("%lld\n", ANS[i]); return 0;&#125; 带修莫队带修莫队实际上就是在普通莫队的基础上增加一个时间轴，来表示修改的时间点。分块策略与普通莫队类似，还是先l r分块，然后还要对同一块内的修改排序(假设为单点修改)在移动完l r指针后，再去移动时间轴指针t，类似地进行相应修改，基本思想其实是一致的。123456789101112131415161718192021222324struct Node &#123; int l, r, pre, bh; inline bool operator &lt;(register Node s)const &#123; if (blo[s.l] ^ blo[l])return s.l &lt; l; if (blo[s.r] ^ blo[r]) return s.r &lt; r; return s.pre &lt; pre; &#125; //此处pre记录时间戳，即当前查询在第几次修改后&#125;q[N];...int main() &#123; ... for (int i = 1; i &lt;= m; ++i) &#123; while (r &lt; q[i].r)ins(++r); while (l &gt; q[i].l)ins(--l); while (r &gt; q[i].r)del(r--); while (l &lt; q[i].l)del(l++); while (now &lt; q[i].pre)change(++now); while (now &gt; q[i].pre)change(now--); //除了l r指针外还有now指针 ans[q[i].bh] = sum; &#125; ...&#125; 树上莫队树上莫队用于解决树上问题，我们将树上问题转化为序列问题，从而使用莫队求解。如何将一个树上的问题转化成一个序列问题呢？我们借助dfs序（括号序列）达到这一点。首先指定根，对于每个点x，我们记录其在dfs过程中第一次遇到时dfs序为st[x]，第二次遇到时dfs序为ed[x]，并记录这两个dfs序对应的点euler[st[x]]=euler[ed[x]]=x。不难发现，在dfs序组成的长度为2n的序列中，如果在某一段区间[l,r]内st[x]和ed[x]同时存在，那么x必然不在原树上euler[l]和euler[r]的最短路径中，且为其中某个节点的后代。由此我们就能联想到，记录当前区间x是否出现过，进行相应的加或减操作，就可以统计出路径上的真实情况，形象地理解的话考虑从一个点到另一个点的过程中，先走到了中间某个点的其他分支，再走回来，走过去的过程中我们将中间的点都计入贡献，而回来时再将其删掉，这样就保证了正确性。当然，上面给出的是一个相当模糊的概述，如果我们模拟一下就会发现，要分两种情况(设查询的点对为(x, y)，其中st[x] &lt; st[y])： LCA(x, y)为x，这时候只需要从ed[x]走到st[y]就可以了，从st[x]开始没有意义 LCA(x, y)不为x，这时候要注意，我们的区间[st[x], st[y]]中显然是不包括LCA的(为什么)，所以对于这个查询，我们还要记录下其LCA，在计算答案时将LCA计入答案，但是要记住，计入答案后要立刻删掉，不能影响到后面的答案计算，因为区间内实际上是没有LCA这个点的dfs序的。 下面给出树上数颜色的模板洛谷SP10707 COT2 - Count on a tree II1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283struct Query &#123; int l, r, lca, id; Query() &#123;&#125; Query(int l, int r, int lca, int id): l(l), r(r), lca(lca), id(id) &#123;&#125; bool operator &lt;(const Query s)const &#123; return block[l] &lt; block[s.l] || (block[l] == block[s.l] &amp;&amp; r &lt; s.r); &#125;&#125;q[N];void add(int x, int y) &#123; b[++num] = y, nt[num] = p[x], p[x] = num; b[++num] = x, nt[num] = p[y], p[y] = num;&#125;void dfs1(int x) &#123; sz[x] = 1; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x])continue; fa[k] = x; dep[k] = dep[x] + 1; dfs1(k); if (sz[son[x]] &lt; sz[k])son[x] = k; sz[x] += sz[k]; &#125;&#125;void dfs2(int x, int chain_number) &#123; st[x] = ++tot; euler[tot] = x; bel[x] = chain_number; if (son[x])dfs2(son[x], chain_number); for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x] || k == son[x])continue; dfs2(k, k); &#125; ed[x] = ++tot; euler[tot] = x;&#125;int LCA(int x, int y) &#123; while (bel[x] != bel[y]) &#123; if (dep[bel[x]] &lt; dep[bel[y]])jh(x, y); x = fa[bel[x]]; &#125; if (dep[x] &lt; dep[y])return x; return y;&#125;void del(int x) &#123; if (!--cnt[c[x]])--ans; &#125;void opt(int x) &#123; if (use[x])del(x); else if (!(cnt[c[x]]++))++ans; use[x] ^= 1;&#125;int main(void) &#123; int n = fast_IO::read(), m = fast_IO::read(); *block = sqrt(n &lt;&lt; 1); for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i)block[i] = (i - 1) / *block + 1; for (int i = 1; i &lt;= n; ++i)c[i] = Hash[i] = fast_IO::read(); for (int i = 1; i &lt; n; ++i)add(fast_IO::read(), fast_IO::read()); sort(Hash + 1, Hash + n + 1); *Hash = unique(Hash + 1, Hash + n + 1) - Hash - 1; for (int i = 1; i &lt;= n; ++i) c[i] = lower_bound(Hash + 1, Hash + *Hash + 1, c[i]) - Hash; dfs1(1); dfs2(1, 1); for (int i = 1; i &lt;= m; ++i) &#123; int x = fast_IO::read(), y = fast_IO::read(), lca = LCA(x, y); if (st[x] &gt; st[y])jh(x, y); if (lca == x)q[i] = Query(st[x], st[y], 0, i); else q[i] = Query(ed[x], st[y], lca, i); &#125; sort(q + 1, q + m + 1); int l = 1, r = 0; for (int i = 1; i &lt;= m; ++i) &#123; while (r &lt; q[i].r)opt(euler[++r]); while (l &gt; q[i].l)opt(euler[--l]); while (r &gt; q[i].r)opt(euler[r--]); while (l &lt; q[i].l)opt(euler[l++]); if (q[i].lca)opt(q[i].lca); ANS[q[i].id] = ans; if (q[i].lca)opt(q[i].lca); &#125; for (int i = 1; i &lt;= m; ++i) printf("%d\n", ANS[i]); return 0;&#125; 回滚莫队咕咕咕]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治（二）]]></title>
    <url>%2F2020%2F10%2F28%2F%E5%88%86%E6%B2%BB%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CDQ分治和整体二分都属于离线算法 CDQ分治CDQ分治的流程与普通分治的流程区别在于，当我们递归解决[L,M]和[M+1,R]区间后，除了将两个子区间的答案合并还要再加上右区间对左区间的贡献。CDQ分治主要用于求解偏序问题。 下面用一个简单的示例说明CDQ的基本思想。 CDQ分治求逆序数求逆序数实质是一个二维偏序问题，相当于一个由有序点对$(x,y)$组成的集合，求对于每个$(x_i,y_i)$有多少对$(x_j,y_j)$使得$x_i&gt;x_j且y_i&lt;y_j$的和。首先一个区间其下标必然是有序的，于是我们只用考虑用$y$如何进行统计。那么参照上面所说的CDQ分治的思想，我们分别计算左右区间的逆序对个数并求和，然后算出右区间对左区间的贡献，总和即为整个当前区间的逆序对数。 1234567891011121314151617181920ll CDQ(int *p, int len) &#123; //p开始的len个元素为当前区间，区间长度为len if (len == 1)return 0;//只有一个数显然逆序数为0 int mid = len &gt;&gt; 1; ll ans = CDQ(p, mid) + CDQ (p + mid, len - mid);//分治，左右区间分别求解 //此处应该将整个区间排序用双指针算出右区间对左区间的贡献，考虑到我们分治的过程 //我们可以直接在分治过程中通过归并排序来减少复杂度 int i = 0, j = mid, k = 0; while (i &lt; mid &amp;&amp; j &lt; len) &#123; if (p[i] &lt;= p[j])tmp[k++] = p[i++];//不构成逆序对 else &#123; ans += mid - i;//p[i]后面的数都比p[i]大，因此也比p[j]大，将这部分计入右区间对左区间的贡献 tmp[k++] = p[j++]; &#125; &#125; while (i &lt; mid)tmp[k++] = p[i++]; while (j &lt; len)tmp[k++] = p[j++]; for (int i = 0; i &lt; k; ++i)p[i] = tmp[i];//tmp存储的是归并后有序的区间，用其更新p return ans;&#125; 其他问题值得一提的是，通常在进行CDQ分治之前我们会将数组排序，来确保可以通过计算右区间中每个点对左区间的贡献来得到正确答案。对于多维偏序问题，我们依然可以使用CDQ分治，例如三维偏序，我们可以对第一维排序、第二维CDQ、第三维用数据结构或CDQ统计答案。来看一个三维偏序的问题。洛谷P3810 【模板】三维偏序（陌上花开）我们很容易就想到，先以a为第一关键字、b为第二关键字、c为第三关键字排序，每次将区间分成两半，这样左区间的a都是小于等于右区间的a的，这样我们只需要计算对右边每对(b,c)左边有多少对满足条件的(b,c)即可显然，b如果在两个区间内分别有序，我们的计算将会非常方便，用双指针扫一遍，若右区间的b大于等于左区间的b，则此时左区间的c就有可能对右区间的c产生贡献，因此我们用一个c值域上的树状数组维护当前有多少产生贡献的c，在右区间的b小于左区间的b时查询此时的贡献。但是这里存在一个问题，此处我们用CDQ分治，要求只能是左区间对右区间产生贡献，但如果有a b c相同的元素分别属于左右区间，这时候右区间对左区间也能产生贡献。而我们的解决方法就是在开始的时候就对整个数组进行去重操作，记录下每个元素的个数有多少，然后对不同元素间进行上述分治+树状数组求解，每个元素的答案再加上相同元素个数-1（其他所有元素都对他产生贡献）就是该元素真正的答案。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;#define jh(x, y) x ^= y ^= x ^= y#define lowbit(x) (x &amp; -x)const double pi = 3.141593;typedef long long ll;const int N = 2e5 + 5, INF = 0x3f3f3f3f, mod = 1e9 + 7;using namespace std;namespace fast_IO &#123; ll read() &#123; char c; ll x = 0; bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r' &amp;&amp; ~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; void write(ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;struct Node &#123; int a, b, c, tot = 0, cnt; Node() &#123;&#125; Node(int c, int b, int a): a(a), b(b), c(c) &#123;&#125; bool operator &lt;(const Node s)const &#123; return a &lt; s.a || (a == s.a &amp;&amp; (b &lt; s.b || (b == s.b &amp;&amp; c &lt; s.c))); &#125; bool operator !=(const Node s)const &#123; return a != s.a || b != s.b || c != s.c; &#125;&#125;a[N], tmp[N], b[N];int ans[N], n, k, c[N];void update(int x, int data) &#123; while (x &lt;= k) &#123; c[x] += data; x += lowbit(x); &#125;&#125;int query(int x) &#123; int ans = 0; while (x) &#123; ans += c[x]; x -= lowbit(x); &#125; return ans;&#125;void CDQ(Node *p, int len) &#123; if (len == 1)return; int mid = len &gt;&gt; 1; CDQ(p, mid); CDQ(p + mid, len - mid); int i = 0, j = mid, k = 0; while (i &lt; mid &amp;&amp; j &lt; len) &#123; if (p[i].b &lt;= p[j].b) &#123; update(p[i].c, p[i].cnt); tmp[k++] = p[i++]; &#125; else &#123; p[j].tot += query(p[j].c); tmp[k++] = p[j++]; &#125; &#125; while (j &lt; len) &#123; p[j].tot += query(p[j].c); tmp[k++] = p[j++]; &#125; for (int t = i - 1; ~t; --t)update(p[t].c, -p[t].cnt); while (i &lt; mid)tmp[k++] = p[i++]; for (int i = 0; i &lt; len; ++i)p[i] = tmp[i];&#125;int main(void) &#123; //freopen("1.in", "r", stdin); int cnt = 0; n = fast_IO::read(), k = fast_IO::read(); for (int i = 1; i &lt;= n; ++i) a[i] = Node(fast_IO::read(), fast_IO::read(), fast_IO::read()); sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] != a[i - 1])b[++cnt] = a[i], b[cnt].cnt = 1; else ++b[cnt].cnt; &#125; CDQ(b + 1, cnt); for (int i = 1; i &lt;= n; ++i)ans[b[i].tot + b[i].cnt - 1] += b[i].cnt; for (int i = 0; i &lt; n; ++i) printf("%d\n", ans[i]); return 0;&#125; 事实上，CDQ是可以不断套娃的，三维偏序问题还可以通过CDQ套CDQ来解决。第一层CDQ与上面的过程类似，只不过我们不需要进行树状数组的操作，只是在原来的update和query处打上tag标记，表示这个位置是计入答案或者统计答案。在排序完成后我们在CDQ内对同一区间进行第二层CDQ，此时的区间是以b为第一关键字，c为第二关键字排序后的结果，因此跟一层CDQ就非常类似的，唯独是在第二层CDQ中计入和统计答案时要注意第一层CDQ中打的标记，比如如果当前左区间的c小于等于右区间的c，但是第一层中并没有给他打标记，就说明当前右区间的元素实际上在第一层时是在左区间，于是就不能进行贡献统计。 123456789101112131415161718192021222324252627282930313233343536void CDQ2(Node *p, int len) &#123; if (len == 1)return; int mid = len &gt;&gt; 1; CDQ2(p, mid); CDQ2(p + mid, len - mid); int i = 0, j = mid, k = 0, sum = 0; while (i &lt; mid &amp;&amp; j &lt; len) &#123; if (p[i].c &lt;= p[j].c) &#123; sum += p[i].tag; tmp[k++] = p[i++]; &#125; else &#123; if (!p[j].tag)tt[p[j].tot] += sum; tmp[k++] = p[j++]; &#125; &#125; while (j &lt; len) &#123; if (!p[j].tag)tt[p[j].tot] += sum; tmp[k++] = p[j++]; &#125; while (i &lt; mid)tmp[k++] = p[i++]; for (int i = 0; i &lt; len; ++i)p[i] = tmp[i];&#125;void CDQ(Node *p, int len) &#123; if (len == 1)return; int mid = len &gt;&gt; 1; CDQ(p, mid); CDQ(p + mid, len - mid); int i = 0, j = mid, k = 0; while (i &lt; mid &amp;&amp; j &lt; len) &#123; if (p[i].b &lt;= p[j].b)tmp[k] = p[i], tmp[k++].tag = p[i++].cnt; else tmp[k] = p[j++], tmp[k++].tag = 0; &#125; while (j &lt; len)tmp[k] = p[j++], tmp[k++].tag = 0; while (i &lt; mid)tmp[k] = p[i], tmp[k++].tag = p[i++].cnt; for (int i = 0; i &lt; len; ++i)a[i] = p[i] = tmp[i]; CDQ2(a, len);&#125; 以此类推，其实无论多少维的偏序问题我们都可以通过CDQ套娃来解决。 整体二分咕咕咕]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>CDQ分治</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治（一）]]></title>
    <url>%2F2020%2F10%2F28%2F%E5%88%86%E6%B2%BB%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基本分治分治的基本思想是：将一个问题分成若干个子问题，对每个子问题进行求解，再将所有子问题的解合并得到问题的解。我们通过一个简单实用的例子来说明该类算法的思想。 归并排序尽管我们几乎不会手写归并排序，但其思想对分治的理解是很有帮助的。考虑我们需要排序的序列[1,n]，如果其子序列[1,mid]和[mid+1,r]都是有序的，我们怎么做才能将其合并成一个有序序列呢？我们用两个指针分别遍历两个子序列，每次将两个指针指向的元素中较小的那个元素加入新的序列，最终得到的序列就是有序的。于是我们的分治策略就出来了，对于序列[l,r]，先将其分成两半分别进行排序，再进行合并。显然合并操作每一层总时间是O(n)的，而每次将序列分半，最多分$\log n$次，所以总复杂度为$O(n\log n)$。这里我们就将合并一个序列的问题变成合并两个子序列的子问题，再将两个排好序的子序列进行合并，就得到了最终的有序序列。123456789101112131415void merge(int l, int r) &#123; if (l == r)return;//只有一个元素当然是有序的 int mid = l + r &gt;&gt; 1; merge(l, mid); merge(mid + 1, r);//分成两个序列，进行排序 int i = l, r = mid + 1, tot = l - 1; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (a[i] &lt; a[j]) b&#123;++tot] = a[i++]; else b[++tot] = a[j++]; &#125; while (i &lt;= mid)b[++tot] = a[i++]; while (j &lt;= r)b[++tot] = a[j++];//将其余元素放入当前序列 for (int i = l; i &lt;= r; ++i)a[i] = b[i];&#125; 树分治点分治现在，我们要对一棵树进行基于点的分治，首先选择一点作为当前无根树的根，将无根树化为有根树，再去递归地处理每一个与根连接的子树。那么问题来了，如何选点呢？显然，我们希望递归的层数尽量少，自然不能胡乱选点。在点分治中我们选择一棵树的重心作为根。何为重心？即将某个点删去后，剩余节点数量最多的树点的数量最少，则该点称为重心。重心可以DP求解，复杂度$O(n)$：dfs求得每个子树大小，选取一个根x删掉后，剩余树中节点最大值为$\max\{sz[y_1],sz[y_2],…,sz[y_n],sum-sz[x]\}$，从所有x中选择该最大值最小的节点作为根。 123456789101112void getrt(int x, int fa) &#123; sz[x] = 1; maxn[x] = 0; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa || vis[k])continue; getrt(k, x); sz[x] += sz[k]; maxn[x] = max(maxn[x], sz[k]); &#125; maxn[x] = maxn(maxn[x], sum - sz[x]); if (maxn[rt] &gt; maxn[x])rt = x;&#125; 那么，知道了如何找根，分治的过程怎么写呢？参考下面的模板 1234567891011121314void solve(int x) &#123; vis[x] = true;//我们用vis来标记已经搜过的根，以此来确定子树的边界 ... calc(x);//处理x处，也就是当前子树的答案 for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (vis[k])continue; sum = sz[k]; maxn[0] = INF; rt = 0; getrt(k, 0);//找到k子树中合适的根 solve(rt);//分治 &#125;&#125; 至于其中的calc怎么写，根据题目会有变化。 边分治]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论（二）]]></title>
    <url>%2F2020%2F10%2F28%2F%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[网络流Dinic最小割费用流上下界网络流]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论（一）]]></title>
    <url>%2F2020%2F10%2F27%2F%E5%9B%BE%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最短路最短路是非常常见的问题，求解方法和各种应用也很多，首先来看一些常用的、基本的最短路求法。 FloydFloyd是一种用DP求解最短路的方法，基本思想就是；对于每个起点和终点，枚举中间点，进行状态转移。转移方程为$d_{x,y}=\min\{d_{x,k}+d_{k,y}|1\le k\le n\}$其时间复杂度为$O(n^3)$，主要用来求任意两点间的最短路。12345for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) if (d[i][j] &lt; d[i][k] + d[k][j]) d[i][j] = d[i][k] = d[k][j]; Bellman-Ford（dijkstra）咕咕咕 spfa咕咕咕 tarjantarjan是非常实用的图论算法，使用tarjan可以解决很多图论问题。 强连通分量首先我们来看tarjan的一个经典应用：求有向图强连通分量（联通块）。强连通分量，即图的一个子集，其中每个点都可以到达其他任意一个点。要想搞清楚tarjan算法，主要是要弄明白这两个数组有何作用、如何实现：dfn和low其中dfn[x]较为简单，其含义为x的搜索序，你也可以理解为dfs过程中x的时间戳。重点需要理解的是low[x]的含义，一般来说我们描述为“他表示从x处开始搜索，能走到的最小的搜索序是多少。”但实际上这个说法是比较含糊的，与x连接的某个点为k，则从x处开始搜索时不能搜回fa处，且若k在此前其在x后已经搜索过，则不再继续搜索，并用dfn[k]更新low[x]的值， 而对于其他连接的节点，需要取其low最小值。对于k，我们用其dfn值更新x的low值的原因是，从x处能搜到曾经搜过的k，那么从k开始就有可能存在一个强联通块包含了x，因此我们将x的low值更新，再通过回溯时对low值的更新，一步步更新回k点，若low[k]与dfn[k]相等，就说明从k开始绕了一圈又找到了k，也就是说找到了强连通分量。那么如何对应地找到其中所有的节点呢？我们通过栈来实现，在dfs过程中，若遇到没搜过的点，则将其入栈，最后在low[x]=dfn[x]处，因为从x处最终能走回x，回溯到x时，途中的所有节点都在栈中，而中途可能遇到的分支都会在相同的过程中全部出栈（不在环中的自成一个强连通分量），因此从栈顶到栈中x的位置，中间的节点正好在一个强连通分量中，所以我们只需要不断弹栈，直到将x弹出栈，所有弹出的元素都归为一个强联通块中，可以证明，这样求得的强联通块是最大强联通块，将强联通块抽象成点，这便是缩点。 12345678910111213141516171819202122232425void tarjan(int x) &#123; dfn[x] = low[x] = ++tot; st[++top] = x; flag[x] = true;//在栈中 for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (!dfn[k]) &#123; tarjan(k); low[x] = min&#123;low[x], low[k]);&#125; &#125; else if (flag[k])low[x] = min(low[x], dfn[k]); //从某点出发的路径中有k（因为k还在栈中），则可能会成环。 &#125; if (dfn[x] == low[x]) &#123; //相等则成环 ++totltk;//联通块数量+1，也表示了当前联通块数量 while (st[top + 1] != x) &#123; ltk[st[top]] = totltk; f(totltk, x);//可能通过x对联通块内进行一些信息的统计 flag[st[top]] = false;//标记出栈 --top; &#125; //将栈中元素弹出至x也被弹出 &#125;&#125; 割点（割顶）理解了如何计算并使用dfn及low后，我们来看如何求无向图的割点。割点指的是若将联通无向图中的某点及其连接的边删去后，图中连通分量个数增加，则称这个点为割点。其中求dfn与low的过程与求强连通分量的过程基本相同，但我们不需要使用栈，对于任何一个走过的点我们都用其dfn值更新x的low值，至于具体原因，首先我们需要知道怎么求出割点。对于x，假设其从fa搜索过来，连接着某点k，则若low[k]==dfn[x]，说明x为割点。为什么呢？因为如果将x删掉，k与fa必然不属于同一个联通块，若删掉x后k与fa属于同一个联通块，那么low[k]必然会小于dfn[x]，这也就是为什么我们对每个走过的点都用其dfn值更新x的low值，就是为了保证求出的割点一定能保证k与fa不在任何同一个联通块中。然后我们就会考虑到一个特殊的点：第一个搜索的点，这个点是没有fa的。那么如何确定第一个点是不是割点呢？我们记录第一个点被包含在多少个最大的除去x后的联通块中，其实也就是在第一个点进行连接点的遍历时，若该点没有访问过则算入记录，这个应该比较显然，那么只要这个记录比1大，就说明将x删去后会产生多个联通块，即x为割点。于是我们的算法就出来了123456789101112131415void tarjan(int x, int fa) &#123; dfn[x] = low[x] = ++tot; int child = 0 ; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (!dfn[k]) &#123; tarjan(k, x); if (low[k] == dfn[x] &amp;&amp; x != fa)gd[x] = true;//是割点 low[x] = min(low[x], low[k]); if (x == fa)child++;//统计我们要的东西 &#125; else low[x] = min(low[x], dfn[k]);//全部更新 &#125; if (child &gt;= 2)flag[x] = true;//是割点&#125; 另外，根据上述求法，我们还可以统计出断开点x后联通块增加的个数：对于第一个搜索的点，显然联通块增加的个数就是child - 1；对于其他的点，联通块增加的个数应当是x被判为割点的次数。1234567if (low[k] == dfn[x] &amp;&amp; x != fa)gd[x] = true;改为if (low[k] == dfn[x] &amp;&amp; x != fa)++delta[x];if (child &gt;= 2)flag[x] = true;改为if (child &gt;= 2)delta[x] = child - 1; 边双连通分量咕咕咕 点双连通分量咕咕咕]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>tarjan</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构（三）]]></title>
    <url>%2F2020%2F10%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[平衡树Treap（单旋）咕咕咕 可持久化Treap咕咕咕 Splay（双旋）在理解splay的操作前，首先要搞清楚splay维护的是怎样的一棵树。这棵树是一棵二叉树，它最大的特点就是，对于每个节点k，k上的权值一定大于左子树的最大权值且小于右子树的最小权值。 首先来看splay的核心操作：旋转和双旋旋转操作，意在将节点x旋转到原本x父节点f所在的位置，那么会影响到的节点就有：x和f、x的孩子节点k1或k2、f的父亲节点gf。先看gf，gf原本的孩子节点f变成了x，只用将x放到原本f所在的位置就行；再看k1 k2，如果x是f的左孩子，那么f的权值就比x大，f应当到原本x的右孩子k2处，而k2的权值是小于f的，因此k2就到了f的左儿子处，也就是原本x所在的位置，如果x是f的右孩子则是同理；最后看x和f，颠倒父子关系即可。于是乎，我们的旋转操作就能总结出来了：1234567891011121314void _rotate(int x) &#123;//将x旋转到原本x父节点的位置 int f = fa[x], gf = fa[f]; c[x][f == c[gf][1]]] = x;//将x放到原本f的位置 fa[x] = gf; int w = x == c[f][1];//w表示x是f的哪个孩子 c[f][w] = c[x][w ^ 1];//原本x所在的位置变成了x相反方向的孩子 fa[c[x][w ^ 1]] = f; c[x][w ^ 1] = f;//父子关系颠倒 fa[f] = x; pushup(f); pushup(x);//这里对f和x做一些更新，因为这两个节点表示的子树发生了变化 //当然，如果仔细想一下你会发现，在不断旋转的过程中，这个x会在下一次旋转中pushup //因此这里可以不写pushup(x)，而是写在splay操作完以后&#125; 在旋转的基础上，我们进行双旋操作。其实我们旋转的意义在于，将某个节点旋转到根节点来方便进行操作的同时，使树尽量平衡，从而降低复杂度。如果仅仅只是为了把节点放到根处操作，直接不停的旋转就行了，根本用不着splay。而我们的splay这里只有一处与直接旋转不同：如果gf、f和x成了一条直线，也就是说gf到f和f到x是同一个方向，那么我们可以先将f旋转，再将x旋转。因为这种情况下，f旋转上去时，x会被f带着向上走而不是成为gf的一个子树。通过这样的双旋操作，最终可以使得树的高度不至于太高，而是均摊$\Theta(\log n)$的水平。123456789101112void splay(int x) &#123; while (fa[x]) &#123;//fa[x]==0说明x已经到根节点了 int f = fa[x], gf = fa[f]; if (gf) if ((f == c[gf][0]) ^ (x == c[f][0]))//gf f x不在一条线上就为1 _rotate(x); else _rotate(f);//在一条线上就先转f _rotate(x);//再转x，一次循环的效果是将x转到了原本gf所在的位置 &#125; //pushup(x); rt = x;//根变成了x&#125; 有了这些以后，我们就可以去维护一个数集，最基本的操作就是添加、删除、查排名、查第k大数、找前驱后继等如果这个数集是区间的下标，通过给节点附上别的权值以及标记，可以实现对区间的各种操作，尤其包括区间翻转 LCT（动态森林）如果我们要维护一个森林，这个森林可以连边、删边，且操作后依然是森林，那么我们就可以使用LCT。而LCT实际上是基于实链剖分，与树链剖分类似的，我们将森林里的某些路径划分为实链，每个节点属于且仅属于一条实链。考虑到我们要动态维护森林，在这里我们使用平衡树（本人常用splay）来维护实链。那么LCT维护的这条链是怎样的？事实上，LCT维护的链是深度严格递增的，而splay的权值也就是深度，即每个节点x左儿子的深度比x小，右儿子的深度比x大。明白这些以后，我们再想，如何去动态维护这些链呢？ access操作这个操作是LCT的核心操作，其意义在于将某个点x与整棵树的根节点之间的路径划分成一条实链。为了达到这个目的，我们需要将路径上所有连的其他边都变为虚边，再将路径上的边划分为实边即可。下面的图片来自FlashHu的博客 这是原始的树的图像，但显然在我们的splay里面不会是这个样子比如说，这棵树可能实际上长这样 现在我们想把A与N划分成一条实链，首先当然是将N splay到当前实链的根，这样的话，断掉N-O就将深度大的节点（此处是O）全部断开，也就是变为了虚边。 再跳到此时N的父节点I，将I与N连起来（当然是连右儿子），自然就断开了原来的右儿子，也就是“其他的边（点）”。 是不是找到了什么规律呢？没错，只要不断往上跳，连上右儿子并断掉左儿子，最终就能构建A-N的splay出来。 那么代码其实就很简单了1234567void access(int x) &#123; for (int son = 0; x; x = fa[son = x]) &#123; splay(x); c[x][1] = son;//连在右儿子上 pushup(x);//对x做更新 &#125;&#125; 要特别注意的是，这里的fa维护的是原树的形状，而c维护的是splay的形状，要注意区分。 changert操作将根节点设为x仅仅只有access操作当然不够，如果我们想得到(x, y)的路径，我们还需要将x放到整棵树的根上，再在y处access。其实有了access，这个操作非常简单，只需要access(x),splay(x)就行了但这样会有一个问题，我们定义根为树中深度最小的节点，而此时的x显然是splay中深度最大的节点，所以我们需要进行区间翻转操作，这样就保证了x的深度为最小，也就是将x变为了根。 123456789void pushr(int x) &#123; swap(c[x][0], c[x][1]); r[x] ^= 1;&#125;//记得在splay前将所有标记下传！void changert(int x) &#123; access(x); splay(x); pushr(x);//将x所在splay翻转&#125; findrt操作查找x所在树的根节点access(x)，然后splay(x)，接着去找深度最小的点就行了。12345678int findrt(int x) &#123; access(x); splay(x); while (c[x][0]) x = c[x][0]; splay(x);//此处不影响正确性 return x;&#125; split操作将x与y之间的路径划分到同一个splay中前面提到过，只需要changert(x),access(y)即可12345void split(int x, int y) &#123; changert(x); access(y); splay(y);&#125; link操作将两个不在同一棵树的点连起来显然只需要将一个点变为根，连到另一个点上即可123456void link(int x, int y) &#123; changert(x); if (findrt(y) != x) fa[x] = y; //x和y不能在同一棵树中&#125; cut操作删除x到y的边先把x到y划到一个splay中，如果x与y相连直接删除即可123456789void cut(int x, int y) &#123; changert(x); access(y); if (findrt(y) == x &amp;&amp; fa[y] == x &amp;&amp; !c[y][0]) &#123; fa[y] = c[x][1] = 0; pushup(x); &#125; //findrt(y)==x说明x与y在同一棵树中，fa[y]==x&amp;&amp;!c[y][0]说明x与y相连&#125;]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构（二）]]></title>
    <url>%2F2020%2F10%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[树状数组树状数组用于维护前缀和，支持单点修改。树状数组的原理并不复杂：对于1 &lt;= i &lt; j &lt;= n，经过若干次i+=lowbit(i),j-=lowbit(j)，所得的i’和j’中必然会有唯一一对相等，所以我们只需要在修改时不断将a[i]加到c[i’]上，查询时将所有的c[i’]加起来就行了。下面简略地说明一下，为什么这样做是对的：首先，lowbit(x)指的是x在二进制下最低位的1，比如lowbit(3)=1,lowbit(4)=4,lowbit(6)=2。那么为什么一定会有i’和j’相等呢？当j的二进制位大于i时，设i二进制有k位，显然i’中会包含所有k’&gt;k,2^k’，也就是说，只要j将除最高位外所有的位都减成0，就会与某个i’相等。当j的二进制位等于i时，从高位往低位看，必然会有某一位k使得比k位以上i和j都是1，在第k位i是0而j是1，此时又要分两种情况： k位以下i全是0，那么只要j把k位一下全减掉，j’就与i相等 k位以下i有1，那么i’必然会有k位为1，k位以下全为0的情况，此时i’与j’相等 如此，就说明i’与j’必然会相等(注意:i’包含i,j’包含j)，且不难看出，按上述策略找出的i’和j’是唯一的一对。再来张树状数组的大致图像，帮助理解c[i]。 12345678910111213141516171819#define lowbit(x) (x &amp; -x)//为什么x &amp; -x就是x的最低位1呢？因为-x实际上是(~x) + 1，会使得x的最低位1为1，而比x高的位与x都相反void update(int x, int data) &#123; //将x位置加上data while (x &lt;= len) &#123; //len为区间长度 c[x] += data;//前面解释过c[x]的作用 x += lowbit(x); &#125;&#125;int query(int x) &#123; //查询x的前缀和 int ans = 0; while (x) &#123; ans += c[x]; x -= lowbit(x); &#125; return ans;&#125; 另外，对a的差分数组用树状数组可以实现a数组的区间修改和单点查询，只用update(l, delta),update(r+1, -delta)就行了。 线段树线段树是一种非常常用的数据结构，且变化极多，这里先说最基础的线段树。线段树，顾名思义，将区间分成一段一段，来达到区间操作的目的，那么如何分段呢？考虑将区间[l,r]分成两半[l,mid]、[mid+1,r]，这样相当于将区间对半分，那么很显然，对每个区间都这样分段，最终的段数为$O(n\log n)$。当我们进行区间操作时，从最大的区间开始，以此去找对应要操作的区间： [l,r]包含在当前区间的左区间内，就接着往左区间走 [l,r]包含在当前区间的右区间内，就接着往右区间走 [l,r]跨过中间的分界线，那么左边操作[l,mid]，右边操作[mid+1,r] 如此反复，直到找到的区间与当前操作的区间完全相同，就进行操作。大致图像如下 另外，如果我们的区间操作涉及对区间的修改，如加减、乘除、改值，我们可以在找到的区间上打上懒标记，这样我们不用每次往下遍历完整棵线段树，当然，在遍历过程中要注意标记的下传，如果有多个标记要注意多个标记之间的关系，如乘标记不仅改变区间上的值，还改变标记的值。 洛谷P3373 【模板】线段树 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct Node &#123; int l, r; ll sum, add, mul = 1;&#125;tree[N &lt;&lt; 2];void pushup(int x) &#123; tree[x].sum = (tree[x &lt;&lt; 1].sum + tree[x &lt;&lt; 1 | 1].sum) % p; &#125;void build(int x, int l, int r) &#123;//建树 tree[x].l = l, tree[x].r = r; if (l == r) &#123; tree[x].sum = fast_IO::read() % p; return; &#125; int mid = l + r &gt;&gt; 1; build(x &lt;&lt; 1, l, mid); build(x &lt;&lt; 1 | 1, mid + 1, r); pushup(x);&#125;void pushdown(int x) &#123;//标记下传 if (tree[x].mul != 1) &#123; (tree[x &lt;&lt; 1].mul *= tree[x].mul) %= p; (tree[x &lt;&lt; 1 | 1].mul *= tree[x].mul) %= p; (tree[x &lt;&lt; 1].add *= tree[x].mul) %= p; (tree[x &lt;&lt; 1 | 1].add *= tree[x].mul) %= p; (tree[x &lt;&lt; 1].sum *= tree[x].mul) %= p; (tree[x &lt;&lt; 1 | 1].sum *= tree[x].mul) %= p; tree[x].mul = 1; &#125; if (tree[x].add) &#123; (tree[x &lt;&lt; 1].add += tree[x].add) %= p; (tree[x &lt;&lt; 1 | 1].add += tree[x].add) %= p; (tree[x &lt;&lt; 1].sum += (tree[x &lt;&lt; 1].r - tree[x &lt;&lt; 1].l + 1) * tree[x].add % p) %= p; (tree[x &lt;&lt; 1 | 1].sum += (tree[x &lt;&lt; 1 | 1].r - tree[x &lt;&lt; 1 | 1].l + 1) * tree[x].add % p) %= p; tree[x].add = 0; &#125;&#125;void update(int x, int l, int r, ll data) &#123;//添加加标记 if(tree[x].l == l &amp;&amp; tree[x].r == r) &#123; (tree[x].sum += (r - l + 1) * data % p) %= p; (tree[x].add += data) %= p; return; &#125; pushdown(x); int mid = tree[x].l + tree[x].r &gt;&gt; 1; if (r &lt;= mid)update(x &lt;&lt; 1, l, r, data); else if (l &gt; mid)update(x &lt;&lt; 1 | 1, l, r, data); else update(x &lt;&lt; 1, l, mid, data), update(x &lt;&lt; 1 | 1, mid + 1, r, data); pushup(x);&#125;void update2(int x, int l, int r, ll data) &#123;//添加乘标记 if (tree[x].l == l &amp;&amp; tree[x].r == r) &#123; (tree[x].mul *= data) %= p; (tree[x].sum *= data) %= p; (tree[x].add *= data) %= p;//别忘了加标记也要更新 return; &#125; pushdown(x); int mid = tree[x].l + tree[x].r &gt;&gt; 1; if (r &lt;= mid)update2(x &lt;&lt; 1, l, r, data); else if (l &gt; mid)update2(x &lt;&lt; 1 | 1, l, r, data); else update2(x &lt;&lt; 1, l, mid, data), update2(x &lt;&lt; 1 | 1, mid + 1, r, data); pushup(x);&#125;ll query(int x, int l, int r) &#123; if (tree[x].l == l &amp;&amp; tree[x].r == r)return tree[x].sum; pushdown(x); int mid = tree[x].l + tree[x].r &gt;&gt; 1; if (r &lt;= mid)return query(x &lt;&lt; 1, l, r); if (l &gt; mid)return query(x &lt;&lt; 1 | 1, l, r); return (query(x &lt;&lt; 1, l, mid) + query(x &lt;&lt; 1 | 1, mid + 1, r)) % p;&#125; 主席树（可持久化线段树）典例：区间第K大给定一个长度为n的区间，给出m次查询，每次给出l,r,k,查询[l,r]中第k大的值发明者原话：“对于原序列的每一个前缀[1···i]建立出一棵线段树维护值域上每个数出现的次数，则其树是可减的”这话啥意思呢？就是对于序列中每一个位置i，都建立一棵线段树，这个线段树的范围是序列的值域范围，维护的是1~i中值域中的每个数出现的次数，这样的话两棵线段树的结构是完全相同的，因此对应的位置可以相减，所以用树r减去树l-1得到线段树就是区间[l,r]对应的线段树。但是对每个位置都建立一棵线段树，空间复杂度$O(n^2\log n)$，太高了，而我们又发现，其实相邻两颗线段树有大量相同的部分，如果我们将这些相同的部分合到一起，就可以大大降低空间的负担。 之后查询第k大就好说了，如果左区间的数字个数c&gt;=k就往左区间找，否则在右区间找第k-c大 12345678910111213141516171819202122232425//先建立空树void build(int &amp;x, int l, int r) &#123; x = ++tot; if (l == r)return; int mid = l + r &gt;&gt; 1; build(c[x][0], l, mid); build(c[x][1], mid + 1, r);&#125;//建新树，但新树与前一棵树部分重合int update(int pre, int l, int r, int x) &#123; int now = ++tot;//只在需要的地方开节点，节省空间 c[now][0] = c[pre][0], c[now][1] = c[pre][1];//有一部分重合 sum[now] = sum[pre] + 1;//类似于前缀和 if (l == r)return now; int mid = l + r &gt;&gt; 1; if (x &lt;= mid)c[now][0] = update(c[now][0], l, mid, x);//左区间开新节点 else c[now][1] = update(c[now][1], mid + 1, r, x);//右区间开新节点 return now;&#125;int query(int pre, int now, int l, int r, int k) &#123; int mid = l + r &gt;&gt; 1, tmp = sum[c[now][0]] - sum[c[pre][0]];//tmp表示的是查询的[L,R]区间在值域[l,r]真正的数字个数 if (l == r)return l; if (tmp &gt;= k)return query(c[pre][0], c[now][0], l, mid, k); return query(c[pre][1], c[now][1], mid + 1, r, k - tmp);&#125; 李超线段树咕咕咕 扫描线咕咕咕 树链剖分树链剖分主要用于解决树上路径、子树相关问题。树链剖分的思想很简单：在树上划出一些链，使得每个节点都属于且仅属于一条链，记录链的顶部，那么只需要O(1)的时间就能处理整条链的信息，从而达到缩短时间的目的。如何划分这些链？我们采用轻重链剖分，也就是说，找到以节点x的子节点中子树大小最大的节点y（称为重儿子），将x和y划分到同一条链中。 这样的话，基本就可以保证我们划分出的链尽量长，从而减少的时间更多。树链剖分的代码实现比较麻烦，我们分步看。首先，来看看我们需要用到什么变量和数组。12345int sz[N],//子树的大小，用于求重儿子dep[N],//节点的深度bel[N],//节点所在链的顶部son[N],//节点的重儿子fa[N];//节点的父节点 我们需要求出每个点的重儿子以及深度，使用dfs。1234567891011121314//dfs1从根节点开始void dfs1(int x) &#123; sz[x] = 1;//本身大小是1 for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x])continue; fa[k] = x;//k父节点是x dep[k] = dep[x] + 1;//记录深度 dfs1(k); if (sz[k] &gt; sz[son[x]])son[x] = k; //找到sz最大的子树，令其为重儿子 sz[x] += sz[k];//所有子树的大小加本身就是x子树的大小 &#125;&#125; 到目前为止做的都是准备工作，接下来才是链的划分。123456789101112void dfs2(int x, int chain_number) &#123; bel[x] = chain_number;//chain_number存的就是当前链的顶部，也代表着这条链 if (son[x])//如果有子节点，将重儿子划分到同一条链中 dfs2(son[x], chain_number); for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x] || k == son[x])continue; //son[x]已经划分了，要跳过 dfs2(k, k); //由于我们是自顶向下dfs的，k与x又不属于同一条链，k所在的链顶部就是k本身 &#125;&#125; 至此，我们就完成了树链剖分，那么如何使用呢？比如，求LCA：123456789101112int LCA(int x, int y) &#123; //求x和y的LCA //x和y反复往上跳，直到跳到同一条链 while (bel[x] != bel[y]) &#123; if (dep[bel[x]] &gt; dep[bel[y]])swap(x, y); //我们希望x和y都尽量往上跳，这样最节省时间，于是我们就跳链顶部的dep较小的那个 x = fa[bel[x]];//从bel[x]链跳到另一条链 &#125; //最终x和y在同一条链上，dep小的那一个显然就是LCA if (dep[x] &lt; dep[y])return x; else return y;&#125; 那如果，要引入路径及子树内的修改、查询怎么办？我们当然希望同一条链上的东西可以一起操作，这样与x和y向上跳的步骤就是一致的，那么具体怎么办呢？考虑引入dfs序，在dfs2中，因为我们优先dfs了重儿子的分支，因此同一条链上的dfs序是连续的，同时，一棵子树内的dfs序显然也是连续的，因此我们可以在dfs序上建立线段树。12345678910111213141516171819void dfs2(int x, int chain_number) &#123; bel[x] = chain_number;//chain_number存的就是当前链的顶部，也代表着这条链 dfn[x] = ++tot;//x的dfs序 ct[x] = dfn[x];//x子树内最大的dfs序 if (son[x]) &#123;//如果有子节点，将重儿子划分到同一条链中 dfs2(son[x], chain_number); ct[x] = max(ct[x], ct[son[x]]); &#125; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x] || k == son[x])continue; //son[x]已经划分了，要跳过 dfs2(k, k); //由于我们是自顶向下dfs的，k与x又不属于同一条链，k所在的链顶部就是k本身 ct[x] = max(ct[x], ct[k]); &#125; //显然，从dfn[x]到ct[x]的dfs序对应的节点与x子树内的节点一一对应&#125;//其他操作都是与LCA类似的过程，对dfn[bel[x]]到dfn[x]进行操作，最后对dfn[x]到dfn[y] (dfn[x]&lt;=dfn[y])操作]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>可持久化</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构（一）]]></title>
    <url>%2F2020%2F10%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基本数据结构栈栈是一种遵循先进后出原则的数据结构，数据在同一端入栈和出栈。 手动实现如下：123456789int stk[100005], top;//stk用于存放栈内的数据，top为栈顶，入栈和出栈都是在栈顶进行操作void ins(int x) &#123; stk[++top] = x; //新加入一个元素x&#125;int del() &#123; return stk[top--]; //返回并删除一个元素， 出栈&#125; 是不是很简单呢？ C++的STL提供了stack给我们直接使用，它支持如下基本操作：123456stack&lt;dataType&gt;name;//创建一个元素类型为dataType的栈namename.top();//返回顶部元素的引用name.push(x);//将x压入栈中name.pop();//弹出栈顶元素name.size();//返回栈中的元素个数name.empty();//栈为空时返回true 单调栈在栈的基础上，我们规定元素出栈的顺序必须是单调不降或单调不增的，对栈内元素的顺序没有要求。对于单调不降的单调栈，入栈前把比要入栈的元素小的元素全部出栈。对于单调不增的单调栈，入栈前把比要入栈的元素大的元素全部出栈。12345678void ins(int x) &#123; //此处以单调不降的单调栈为例 while (top &amp;&amp; stk[top] &lt; x) &#123; fun(stk[top--]);//出栈的元素可能要进行一些操作 //top--出栈 &#125; stk[++top] = x;&#125; 队列队列是一种遵循先进先出原则的数据结构，数据在一段入队，在另一端出队。 手动实现如下123456789int q[100005], head = 1, tail;void ins(int x) &#123; q[++tail] = x; //从尾部入队&#125;int del() &#123; return q[head++]; //从头部出队&#125; C++的STL中同样提供了queue供我们使用，它支持如下基本操作：1234567queue&lt;dataType&gt;name;//创建一个元素类型为dataType的队列namename.front();//返回队列中第一个元素的引用name.back();//返回队列中最后一个元素的引用name.push(x);//x从队列尾部入队name.pop();//删除队列的尾部name.size();//返回队列中元素的个数name.empty();//队列为空时返回true 单调队列与单调栈不同，单调队列要求队内的元素要是单调不降或单调不增的，且队首队尾都可以进行出队操作，只有队尾可以进行入队操作。一般来说，单调队列会有一个限制的大小m，即最多只能有m个元素。单调队列主要用于维护不同段区间内的最值，每次元素要入队时，与单调栈类似地，要让一些元素出队。123456void ins(int x) &#123; //以单调不降的单调队列为例 while (head &lt;= tail &amp;&amp; q[tail] &lt;= x)--tail;//删除比x小的元素 q[++tail] = x;//x入队 while (tail - head &gt;= m)++head;&#125; 链表先鸽着 简单数据结构ST表ST表用于求静态区间最值，构建复杂度$O(n\log n)$，查询复杂度只有$O(1)$!那么ST表是怎么实现的呢？显然区间[L,R]的最值可以拆成[L,L+x]与[R-x+1,R]的最值取最值，只要L+x&gt;=R-x+1即可。那么我们考虑求对于区间内每个位置i，从i开始往后$2^k$个元素中的最值ST[i][k]，于是构建ST表的算法就出来了。123456//以求最大值为例//注意，这里ST[i][0]为位置i上本来的这个数for (int j = 1; j &lt;= log2(n) + 1; ++j) for (int i = 1; i + (1 &lt;&lt; j - 1) &lt;= n; ++i) ST[i][j] = max(ST[i][j - 1], ST[i + (1 &lt;&lt; j - 1)][j - 1]);//显然是两段的最值中取最值 查询也好说：1234int query(int l, int r) &#123; int k = log2(r - l + 1); return max(ST[l][k], ST[r - (1 &lt;&lt; k) + 1][k]);&#125; 并查集并查集用于维护集合的关系。普通的并查集操作非常简单，直接上代码。123456789//用fa[x]表示x所在的集合//fa[x]初始化为x本身int findf(int x) &#123; if (x == fa[x])return x;//fa[x] == x说明当前的x已经表示了一个最大的集合 return fa[x] = findf(fa[x]);//如果fa[x] != x说明当前的集合被包含在另一个集合里&#125;//如此就能找到x所在的集合fa[findf(x)] = findf(y);//将x所在的集合合并到y所在的集合 不难看出，findf最多递归小常数次，因此并查集的复杂度是非常小的。 带权并查集咕咕咕 可持久化并查集咕咕咕 优先队列（二叉堆）首先，优先队列并不是用队列实现的，一般我们用二叉堆来实现优先队列。那么什么是优先队列？就是队列中的元素被赋予的优先级，当我们访问优先队列时优先访问优先级高的元素。二叉堆，其实就是一棵二叉树，它满足父节点的优先级一定大于子节点的性质，换句话说，在二叉堆中，以任意节点x为根的子树中，x的优先级是最高的，这样的话，只要构建一个二叉堆，它的根节点就是优先级最高的点。12345678910111213141516171819202122232425262728293031323334//这里我们用一种比较方便的方法表示节点的左右孩子//x * 2表示x的左孩子，x * 2 + 1表示x的右孩子，可以证明这种表示方法是不会重复的//这样的话x / 2就可以表示x的父节点//f[x]表示x的优先级void shift1(int now, int len) &#123; //删除了堆顶，将一个优先级小的元素放到堆顶后，通过该操作维护堆的结构 //从顶向下去更新 int father = now , child = father &lt;&lt; 1; while (child &lt;= len) &#123; if (child &lt; len &amp;&amp; f[pq[child]] &lt; f[pq[child + 1]])++child; if (f[pq[child]] &gt; f[pq[father]])swap(pq[child], pq[father]); father = child, child &lt;&lt;= 1; &#125;&#125;void shift2(int now) &#123; //加入一个元素后，从加入的元素起向上更新，维护堆的结构 int child = now, father = child &gt;&gt; 1; while (father) &#123; if (f[pq[farther]] &gt;= f[pq[child]])break;//此时说明已经满足了堆的性质 //因为加入元素前堆是成立的，只有加入的元素破坏了堆的结构 swap(pq[father], pq[child]); child = father, father &gt;&gt;= 1; &#125;&#125;void add(int x) &#123; pq[++tot] = x; shift2(tot);&#125;dataType del() &#123; dataType x = pq[1]; pq[1] = pq[tot--];//将优先级小的放到堆顶 shift1(1, tot); return x;&#125; 手动实现起来相当麻烦，当然，C++的STL提供了priority_queue供我们直接使用，它支持以下基本操作：123456priority&lt;dataType&gt;pq;pq.top();//访问堆顶元素pq.push(x);//将x入队pq.pop();//将堆顶出队pq.size();//返回优先队列的元素个数pq.empty();//优先队列为空返回true 左偏树（可并堆）有些时候，我们需要将堆进行合并，这时候就用到左偏树。左偏树，左偏是啥意思？意思就是对于堆内任意一棵子树，其左子树中深度最小的叶子节点的深度要大于右子树中深度最小的叶子节点的深度，这样的话从整体上看，整棵树明显左边比较重。 具体实现：我们用并查集来维护不同的节点是否在同一个堆中，下面给出合并操作123456789101112int merge(int x, int y) &#123;//将y堆合并到x堆上，返回合并后的根节点 if (!x || !y)return x | y;//0当然是没有这棵树啦 if (f(x) &lt; f(y))swap(x, y);//f(x)表示x的优先级 //这时候就保证了x节点的优先级比y大，即y只能往x的子树合并，合并后x为根节点 rson[x] = merge(rson[x], y);//左偏树嘛，右子树比较轻，把y往右子树合并 if (dep[lson[x]] &gt; dep[rson[x]]) swap(lson[x], rson[x]); //永远保证rson[x]的最小深度比lson[x]的最小深度小，保证“左偏” dep[x] = dep[rson[x]] + 1;//x的最小深度 fa[lson[x]] = fa[rson[x]] = x;//x为根节点 return x;&#125; 合并自然不用说，如果要删除根节点，只需要合并左右子树就行了。]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>单调栈</tag>
        <tag>单调队列</tag>
        <tag>优先队列</tag>
        <tag>链表</tag>
        <tag>ST表</tag>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 1166D Cute Sequences]]></title>
    <url>%2F2019%2F05%2F18%2FCodeForces-1166D-Cute-Sequences%2F</url>
    <content type="text"><![CDATA[写篇题解祭一下因为脑子短路而逝去的几个小时 Description给定一个正整数$m$，定义一个正整数序列$x_1,x_2,x_3,…,x_n$，满足对于$2\le i\le n$有$x_i=x_{i-1}+x_{i-2}+…+x_1+r_i$，其中$1\le r_i\le m$现在给出$q$个询问，每个询问给出$a,b,m$，强制要求$x_1=a$，$x_n=b$，要求构造出一个长度不超过$50$的$x$序列 Input第一行一个正整数$q(1\le q\le 10^3)$表示询问数接下来$q$行，每行三个正整数$a,b,m(1\le a,b,m\le 10^{14},a\le b)$，意义见题面 Output没有合法序列输出$-1$有合法序列则先输出序列长度$k(k\le 50)$，然后$k$个数$x_1,x_2,…,x_k(1\le x_i\le 10^{14})$，其中$x_1=a,x_k=b$ Sample Input12325 26 23 9 1 Sample Output124 5 6 13 26-1 Solution又被sb题整弱智了.jpg很容易推出$b=2^{k-2}\cdot a+2^{k-3}\cdot r_2+…+2^{k-i-1}\cdot r_i+…+r_{k-1}+r_k$首先特殊情况是$a=b$，这时候直接输出$1\;a$考虑到$k$很小，先枚举长度$k$这时候$a$是确定的，因此可以先把$a$的部分减掉，同时把每个$r_i$都减$1$，这样来保证求出的$r_i$都是$\ge0$的，那么此时$0\le r_i\le m-1$定义$cha=n-2^{k-2}\cdot a-2^{k-2}$从$r_2$到$r_{k-1}$贪心考虑，系数大的尽量大，同时要注意不能超过$m-1$这样构造出来，最后剩余的$r_k=cha$如果在$m$以内，就是合法的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x &amp; -x)#define jh(x, y) x ^= y ^= x ^= y#define loc(x, y) (x - 1) * m + y#define rg register#define inl inline#define PI 3.141592654typedef long long ll;const int N = 6e2 + 5, INF = 0x3f3f3f3f, mod = 998244353;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r' &amp;&amp; ~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;ll r[N];int main(void) &#123; rg int q = fast_IO::read(); while (q--) &#123; rg ll a = fast_IO::read(), b = fast_IO::read(), m = fast_IO::read(); if (a == b) &#123; printf("1 %I64d\n", a); continue; &#125; rg bool can = false; r[1] = a; rg int len; for (rg int k = 2; k &lt;= 50 &amp;&amp; !can; ++k) &#123; rg ll cha = b - a * (1ll &lt;&lt; k - 2) - (1ll &lt;&lt; k - 2); if (cha &lt; 0)break; for (rg int i = 2; i &lt; k; ++i) r[i] = fast_IO::min(m - 1, cha / (1ll &lt;&lt; k - i - 1)), cha -= r[i] * (1ll &lt;&lt; k - i - 1); if (cha &lt; m) &#123; can = true, len = k, r[len] = cha; break; &#125; &#125; if (!can)puts("-1"); else &#123; rg ll sum = a; for (rg int i = 2; i &lt;= len; ++i)++r[i], r[i] += sum, sum += r[i]; fast_IO::write(len); for (rg int i = 1; i &lt;= len; ++i)putchar(' '), fast_IO::write(r[i]); putchar('\n'); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>思路</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ5480:路径的条数]]></title>
    <url>%2F2019%2F04%2F13%2FBZOJ5480-%E8%B7%AF%E5%BE%84%E7%9A%84%E6%9D%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Description给一棵$n$个点的有标号无根树，你需要找到满足条件的路径$u−v$的条数。我们称路径$u-v$满足条件当且仅当$u\not=v$且路径$u-v$上不存在点对$(a,b)$,$a,b$满足$gcd(a,b)=a$。注意：路径$u−v$和$v−u$是同一条路径。 Input第一行一个整数$n\le10^5$接下来$n−1$行，每行两个用空格隔开的整数$a,b$，表示边$(a,b)$ Output一行一个整数，代表要求的答案。 Sample Input43 13 23 4 Sample Output2//只有路径$2 − 3$和$3 − 4$满足条件 Solution这个题的转换很有意思我们考虑用总路径数-不合法的路径数来得到合法的路径数那么现在问题就在于，如何求不合法的路径数首先根据题意，枚举起点$u$，可以通过枚举$u$的倍数来得到一些不合法的路径，我们可以称之为“限制”，很容易得出：每一个不合法的路径必定至少包含一个“限制”知道这个有什么用呢？重头戏来了：设$dfn[x]$为$x$点的dfs序，$cover[x]$为$x$子树中最大的dfs序考虑不合法路径$a-b$，假设$a-b$包含路径$u-v$且$dfn[u]&lt;dfn[v]$，$dfn[a]&lt;dfn[b]$分两种情况讨论： $u$是$v$的一个祖先 $u$不是$v$的祖先 对于第一种情况这时候$a,b$和$u,v$有怎样的关系呢？我们来看下面这张图 这时我们发现，$a$可以是$g$子树外的任意一点，$b$可以是$v$子树内的任意一点，他们对应的dfs序关系为$dfn[a]$ $&lt;$ $dfn[g]\;\;and\;\;dfn[v]\le dfn[b] \le cover[v]$当然你可能会问：那如果我们先遍历图中$g$的那棵子树，上面这个关系就不成立了！（注意我们的前提条件，$a$的dfs序小于$b$）没错，所以我们还要讨论把上图中把$a,b$交换的情况，此时关系为$dfn[v]\le dfn[a] \le cover[v]\;\;and\;\;dfn[b] &gt; cover[g]$ 对于第二种情况这种情况相对较简单，还是先上图此时$a$是$u$子树中的任意一点，$b$是$v$子树中的任意一点所以对应的关系就是$dfn[u]\le dfn[a] \le cover[u]\;\;and\;\;dfn[v]\le dfn[b]\le cover[v]$ 说了这么多，这有什么用啊？ 考虑这样一个坐标系这个坐标系的横轴是$dfn[a]$，纵轴是$dfn[b]$再看看上面我们列出的条件，$dfn[a]$对应一个横轴上的区间，$dfn[b]$对应一个纵轴上的区间这不是矩形嘛！大致乱画一下，其实一堆条件（关系）就成了下面这个东西这些矩形内的每一个整点$(dfn[a],dfn[b])$，都是满足我们要求的东西，也就是不合法而每一个dfs序对应唯一节点，这样我们计算这些矩形内的整点个数就能得到不合法的路径数如何计算？线段树维护扫描线即可，只不过把求面积改成求矩形内点的个数，如果具体不清楚可以直接看代码，代码还算是比较简明的最终统计答案，由于我们这样求出的路径是无向的，设求出的路径数为$ans$答案就是$\dfrac{n*(n-1)}{2}-ans$ 复杂度：枚举$u,v$是$O(n\ln n)$的，线段树还要再乘个$\log n$，所以总复杂度应该是$O(n\ln n\log n)$ 最后献上本人丑陋的代码，现在是2019年3月28日22:06:10，目前在BZOJ是最快的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/************************************************************** Problem: 5480 User: Zechariah Language: C++ Result: Accepted Time:13152 ms Memory:193400 kb****************************************************************/ #include &lt;bits/stdc++.h&gt;#define lowbit(x) (x &amp; -x)#define jh(x, y) x ^= y ^=x ^= y#define loc(x, y) (x - 1) * m + y#define rg register#define inl inline#define PI 3.141592654typedef long long ll;const int N = 8e5 + 5, mod = 998244353, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;int cover[N], dfn[N], nt[N], b[N], p[N], num, id, fa[N][18], deep[N], tot, n;struct Node &#123; int left, right, min; ll sum;&#125;tree[N &lt;&lt; 2];struct Line &#123; int l, r, v, y; Line(rg int l = 0, rg int r = 0, rg int y = 0, rg int v = 0) :l(l), r(r), y(y), v(v) &#123;&#125; bool operator &lt;(const rg Line &amp;s)const &#123; return y &lt; s.y; &#125;&#125;e[N &lt;&lt; 2];inl void add(rg int x, rg int y) &#123; b[++num] = y, nt[num] = p[x], p[x] = num; b[++num] = x, nt[num] = p[y], p[y] = num;&#125;inl bool is(rg int x, rg int y) &#123; return dfn[x] &lt;= dfn[y] &amp;&amp; cover[x] &gt;= cover[y]; &#125;void dfs(rg int x) &#123; dfn[x] = ++id; for (rg int e= p[x]; e; e = nt[e]) &#123; if (b[e] == fa[x][0])continue; fa[b[e]][0] = x; deep[b[e]] = deep[x] + 1; dfs(b[e]); &#125; cover[x] = id;&#125;void build(rg int x, rg int l, rg int r) &#123; tree[x].left = l, tree[x].right = r; if (l == r)return; rg int mid = l + r &gt;&gt; 1; build(x &lt;&lt; 1, l, mid); build(x &lt;&lt; 1 | 1, mid + 1, r);&#125;inl void pushup(rg int x) &#123; if (tree[x].min)tree[x].sum = tree[x].right - tree[x].left + 1; else tree[x].sum = tree[x &lt;&lt; 1].sum + tree[x &lt;&lt; 1 | 1].sum;&#125;void update(rg int x, rg int l, rg int r, rg ll data) &#123; if (tree[x].left == l &amp;&amp; tree[x].right == r) &#123; tree[x].min += data; pushup(x); return; &#125; rg int mid = tree[x].left + tree[x].right &gt;&gt; 1; if (r &lt;= mid)update(x &lt;&lt; 1, l, r, data); else if (l &gt; mid)update(x &lt;&lt; 1 | 1, l, r, data); else &#123; update(x &lt;&lt; 1, l, mid, data); update(x &lt;&lt; 1 | 1, mid + 1, r, data); &#125; pushup(x);&#125;inl ll query() &#123; sort(e + 1, e + tot + 1); rg ll ans = 0; for (rg int i = 1; i &lt; tot; ++i) &#123; update(1, e[i].l, e[i].r, e[i].v); ans += tree[1].sum * (e[i + 1].y - e[i].y); &#125; return ans;&#125;inl int getfa(rg int x, rg int d) &#123; for (rg int j = 17; ~j; --j) if (d &amp; (1 &lt;&lt; j)) x = fa[x][j]; return x;&#125;inl void addedge(rg int x1, rg int x2, rg int y1, rg int y2) &#123; if (1 &lt;= x1 &amp;&amp; x1 &lt;= x2 &amp;&amp; x2 &lt;= n &amp;&amp; 1 &lt;= y1 &amp;&amp; y1 &lt;= y2 &amp;&amp; y2 &lt;= n) e[++tot] = Line(x1, x2, y1, 1), e[++tot] = Line(x1, x2, y2 + 1, -1);&#125; int main(void) &#123; n = fast_IO::read(); for (rg int i = 1; i != n; ++i)add(fast_IO::read(), fast_IO::read()); dfs(1); build(1, 1, n); for (rg int j = 1; j != 18; ++j) for (rg int i = 1; i &lt;= n; ++i) fa[i][j] = fa[fa[i][j - 1]][j - 1]; for (rg int i = 1; i &lt;= n; ++i) &#123; for (rg int j = i &lt;&lt; 1; j &lt;= n; j += i) &#123; rg int x = i, y = j; if (dfn[x] &gt; dfn[y])jh(x, y); if (is(x, y)) &#123; rg int node = getfa(y, deep[y] - deep[x] - 1); addedge(1, dfn[node] - 1, dfn[y], cover[y]); addedge(dfn[y], cover[y], cover[node] + 1, n); &#125; else addedge(dfn[x], cover[x], dfn[y], cover[y]); &#125; &#125; fast_IO::write((ll)n * (n - 1) / 2 - query()); return 0;&#125;]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>扫描线</tag>
        <tag>思路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day6]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day6%2F</url>
    <content type="text"><![CDATA[Day 6——字符串一、哈希（哈希）把信息量大的东西压缩成信息量小的表达。 例题一、给出两个排列$a,b$，长度分别为$n,m$，你需要计算有多少个$x$，使得$a_1+x,a_2+x,a_3+x,…,a_n+x$是$b$的子序列。$n\le m\le2\times 10^5$ 思路枚举$b$中与$a$匹配的最大值$x$，把$x-n+1$ 例题二、你可以通过交换字母来修改字符串。如果两个字符串经过这样的变换之后可以相等，则称它们相似。给出一个文本串$T$与一个模式串$P$，询问$T$中有哪些子串与$P$一模一样或相似。$|T|,|P|\le10^6$ 思路考虑如何判断两个字符串相似。记录$last_i$表示上一次出现$p_i$的位置，我们发现两个字符串的$last$数组相同，他们就是相似的。然后直接KMP比较（或者哈希）。 二、KMP求出$next$数组，$next_i$表示当第$i$个位置失配的时候，应该从后面的什么位置开始匹配。求最长公共前后缀，这样就可以求出$next$数组。 模板1234567891011121314151617181920212223242526272829char s[N], t[N];int nt[N];inl void getnext()&#123;//模式串与自己匹配求出next数组 rg int len = strlen(t), i = 0, j = -1; while (i &lt; len) &#123; if (j == -1 || t[i] == t[j])nt[++i] = ++j; else j = nt[j]; &#125;&#125;inl void kmp()&#123; getnext(); rg int lens = strlen(s),lent=strlen(t), i = 0, j = 0; while (i &lt; lens) &#123; if (j == -1 || s[i] == t[j]) &#123; ++i, ++j; if (j == lent) &#123; j = nt[j]; //此时[i-lent+1,i-1]的子串是与t串匹配的 &#125; &#125; else j = nt[j]; &#125;&#125; 例题一、给出一个长度为$n$的串$S$，判断$S$的每个前缀是不是循环串，如果是输出最大循环次数。循环串的定义：由一个相同的串重复至少两次拼成。$n\le10^6$ 思路如果一个串是循环串，那么这个串就是$m$个小串的拼接，他的$next$就是$m-1$个小串。由于$s_{1…next}$与$S_{n-next…next}$是相同的两串，那么只要$i\mod(i-next)=0$，那么该串是一个以$i-next$为最小循环节的串。 例题二、给出一个长度为$n$的串$S$，你需要选取$S$的一个前缀$T$，使得$T$重复若干次可以拼出$S$（拼合可以有部分重复，但是重复部分必须相同）。最小化$T$的长度$n\le10^6$ 思路根据$next$建出$fail$树，贪心即可。 三、AC自动机（Aho-Corasick automation）例题一、给出含有$n$个单词的词典，你需要计算对于所有长度为$m$的字符串，有多少个至少包含一个单词。字符集为大写字母。$n\le60,m\le100,$每个单词长度$\le100$ 思路建出AC自动机，将每个单词结尾设为不可通行，计算从根节点开始走$m$步的总方案数，用总字符串数$-$总方案数即可。 例题二、给出$n$个字符串和$m$个询问，每次询问$i,j,k,l$，求第$i$个串的$j$长前缀和第$k$个串的$l$长前缀的最长公共后缀。$\sum S_i\le10^6$ 思路建出AC自动机，求所求两个前缀在$fail$树上的LCA即可。 例题、三给定$n$个字符串$s_i$，问最多能从中选择多少个串，使得其中不存在一个串是另一个串的子串。$n\le750,\sum|s_i|\le10^7,s_i\in\left\{a,b\right\}$ 思路四、后缀数组（SA）模板1234567891011121314151617181920212223242526272829303132333435363738int rk[N], sa[N], b[N], m, n, tong[N], height[N];char s[N];inl void radix_sort()&#123; memset(tong, 0, sizeof(tong)); for (rg int i = 1; i &lt;= n; ++i)++tong[rk[b[i]]]; for (rg int i = 1; i &lt;= m; +i)tong[i] += tong[i - 1]; for (rg int i = n; i &gt;= 1; --i)sa[tong[rk[b[i]]]--] = b[i];&#125;inl void getsa()&#123; for (rg int i = 1; i &lt;= n; ++i)rk[i] = s[i] - 'a' + 1, b[i] = i; radix_sort(); for (rg int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; rg int tot = 0; for (rg int i = n - k + 1; i &lt;= n; ++i)b[+tot] = i; for (rg int i = 1; i &lt;= n; ++i)if (sa[i] &gt; k)b[++tot] = sa[i] - k; radix_sort(); memcpy(b, rk, sizeof(b)); rk[sa[tot = 1]] = 1; for (rg int i = 2; i &lt;= n; ++i) if (b[sa[i]] == b[sa[i - 1]] &amp;&amp; b[sa[i] + k] == b[sa[i - 1] + k])rk[sa[i]] = tot; else rk[sa[i]] = ++tot; if (tot == n)break; m = tot; &#125;&#125;inl void getheight()&#123; rg int k = 0; for (rg int i = 1; i &lt;= n; ++i)rk[sa[i]] = i; for (rg int i = 1; i &lt;= n; ++i) &#123; if (rk[i] == 1)continue; rg int j = sa[rk[i] - 1]; while (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; s[j + k] == s[i + k])++k; height[rk[i]] = k; &#125;&#125; 例题一、给出$n$个串，找出一个最长的子串，至少在$\dfrac{n}{2}$个串中出现过。$\sum S_i\le10^5$ 思路将所有字符串拼起来，求$SA$和$Height$，做滑动窗口，求RMQ。 结论一个字符串的不同子串个数为$\dfrac{n(n-1)}{2}\sum\limits_{i=1}^{n}Height_i$ 例题二、给出一个小写字符串$S$以及$m$个询问，每个询问给出两个正整数$x,y$（$x\le y\le$字符串$S$本质不同的子串个数），表示询问$s$的所有本质不同的子串中，字典序排名为$x$到$y$之间的所有字符串的哈希值总和（包括$x$和$y$）。$|S|,m\le10^5$ 思路考虑转化为对前缀的查询，避免对两个子串的相同前缀重复计算，我们只用对不相同的部分二分求 例题三、给出一个字符串，将其划分为不超过$k$个连续子串。设第$i$个子串为$s_i$，对于每个$s_i$，找到其中字典序最大的连续子串$c_i$。你需要找到一种划分，使得字典序最大的$c_i$字典序最小。$|S|\le10^6$ 思路二分字典序，每次从后往前考虑，使得每个子串字典序不超过二分的答案，统计字典序的方法：二分一个后缀，再在后缀上二分。 例题四、给定一个字符串$S$，有$m$个询问，每组询问形如$(a,b,c,d)$，询问$S_{a…b}$的所有子串中与$S_{c…d}$的最长公共前缀的最大值是多少。$|S|\le10^5m\le10^5$ 思路二分答案$x$，找到$SA$中与后缀$c$LCP大于$x$的部分，查询是否含有$[a,b]$中的元素，二维数点问题，主席树求解。 例题五、给出一个长度为$n$的数组$a_i=i$，把它进行$m$次操作，每次操作可以是以下两种： 把某一段提到开头 区间翻转 现在问后缀数组为$a$的字符串$S$有多少种可能。限制$S$为字符串中出现的都是正整数，且最大元素等于不同元素的个数。$n\le10^9,m\le10^5$ 思路考虑后缀数组的定义$suf_{a_i}&lt;suf_{a_{i+1}}$于是推出$S_{a_i}\le S_{a_{i+1}}$可以发现确定每一个$\le$为$&lt;$或$=$，就能唯一确定整个数组。取$&lt;$一定合法，取$=$要求$suf_{a_{i+1}}&lt;suf_{a_{i+1}+1}$ 五、后缀自动机（SAM）字符串$S$的后缀自动机是一个能接受$S$的所有子串的有限状态自动机。 Right集所有该字符串的右端点组成的集合称为该串的$Right$集，$Right$集不同的串即为本质不同的串子串的$Right$集只有包含与并列关系由于这样的性质，我们可以建出一棵树，这棵树称为$fail$树。 建立SAM$last$:已经建立好的$SAM$因为新后缀而创建的最后一个节点。]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day5]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day5%2F</url>
    <content type="text"><![CDATA[Day5 上午——动态规划大纲DP的类型序列DP数位DP概率DP树形DP状态压缩DPDP套DP DP的优化形式优化决策单调性优化斜率优化凸单调性DP优化 例题、[HAOI2011]problem a题面见P2519 思路将问题转化一下，一个人说的话如果为真说明从第$a_i+1$到第$n-b_i$个人的分数是一样的.如果我们把这样一个模型看成一条线段，那么在这$n$条线段中，相交且互不重合的线段一定不能同时为真话，所以问题就转化为选出尽可能多的不相交或完全重合的线段，且对于某条线段完全重合的个数要小于等于线段长。所以做法就很明显了，先求出说最多的说真话的人数，用总人数去剪。具体做法为：将每个人对应的线段放在一起进行双关键字排序，合并完全包含的线段，每一个线段上存一个权值$V_i$，现在就是要从$m$个线段中取出不相交的线段使得权值和最大，这就可以DP了。将所有线段按右端点排序，设$f_i$为到第$i$个线段的最优解。转移的时候先二分$[1,i)$之间满足$R_k&lt;L_i$的$f_k$最大的$k$，转移方程为$f_i=\max(f_{i-1},f_k+V_i)$最终答案为$n-f_m$ 一、数位DP数位DP常用来统计或查找一个区间满足条件的数，然后按数位顺序DP，一般需要仔细分情况讨论，常见处理如将区间拆为$[1, R], [1, L)$，记忆化，预处理等。 例题一、[SDOI2013]淘金题面见P3303 思路考虑对于一个$i$，有多少$j$满足$f_j=i$，记为$v_i$不难发现，$[1,n]$内的任何数各位相乘的结果最多只有4个质因子$2 ,3 ,5 ,7$，也就是说$i$可以被分解为$2^a\times 3^b\times5^c\times7^d$，这样的$i$在$n\le10^{12}$范围内其实是很少的这个个数设为$m$。所以我们可以设计状态$f_{i,j,0/1}$表示从低位到高位的第$i$位，各位的乘积为$j$（离散化后），最后一维表示是否小于等于$N$转移的时候枚举第$k$位，如果$k|j$那么$dp_{i,j,0/1}$可以从$dp_{i-1,\dfrac{j}{k},0/1}$转移过来最终我们是要求位置$(x,y)$的价值$v_x\times v_y$的前$K$大之和。考虑将$v$从小到大排序，用大根堆维护$m$个指针$p_i$，分别表示的是$v_1$到$v_m$，维护堆的关键字为$v_{p_i}\times v_i$，贪心选择$K$个求和得到答案。 二、概率和期望DP概率DP是一类求事件概率或期望的DP的总称。对于求概率问题，有时利用补集转化，或者将其转化为计数问题；而对于求期望则大多利用期望的线性性来解决问题。 贝叶斯公式条件概率$P(y|x)$联合概率$P(y,x)$$P(x,y)=P(x,y)=P(y|x)P(x)=P(x)P(y)$$P(x,y)=P(x|y)P(y)$贝叶斯公式：$P(y|x)=\dfrac{P(x|y)P(y)}{P(x)}$ 例题一、亚瑟王给你$N$张牌，每张牌有一个发动概率 $P_i$ 以及伤害 $D_i$，共有$R$回合，每回合会按编号从小到大依次考虑本次游戏中还未发动的卡牌，依次尝试发动，如果发动成功，进入下一回合，求期望伤害之和，共 $T$组数据。$T\le444,N\le220,R\le132$ 思路$dp_{i,j}$表示前$i$张牌发动了$j$张的概率求出每张牌发动的概率$sump_i=\sum\limits_{j=0}^rdp_{i-1,j}(1-(1-p_i)^{r-j})$$dp$可以DP求得$dp_{i,j}=\sum\limits_{j=0}^r(dp_{i-1,j}(1-p_i)^{r-j}+dp_{i-1,j-1}(1-(1-p_i)^{r-j+1}))$ 例题二、Museum题面见CF113D 思路解法一、设$ f_{i, j} $为第一个人在$ i$, 第二个人在$ j$,此时开始,之后在$ t $点相遇的概率.枚举终点, 做$ n $次高斯消元即可,不过直接这样做是$ O(n^7)$的.注意到每次高斯消元时,$ Ax = B $只有$ B $发生了变化.于是把$ B $改成一个矩阵就可以$ O(n^6)$了.最后通过$f_{i,j}=\sum\limits_{1\le i\le n}A_if_{i,i}$,令$f_{i,i}=1$就可以求出所有解 解法二、设$f(i,j)$为第一个人在$i$，第二个人在$j$这种情况的期望出现次数，因为终止状态只会出现0/1，于是期望就是概率了。 三、树形DP树形DP是指基于树的结构的动态规划，基础的有： 树的直径：DP记录子树内最长路 树的重心：DP记录子树大小 树上最大权独立集：DP记录子树的根是否选择 树形依赖背包：在dfs序上DP(即每次选择是否跳过子树)，或通过父节点的DP值传入孩子DP 虚树：在原树上只保留需要的点与他们的LCA的树称为虚树，建树方法为：将点按dfs序排序，一次将点加入，用一个栈维护树上的已加入的点和他们LCA的右链，每次加入一个点，与栈顶比较，便可以建出虚树 … 例题一、大工程题面见P4103 解答有着询问的和小于的限制的题是虚树的一个显著的特征。建出虚树, 然后直接在上面树形DP。设$ f_i $为以$ i $为根的子树内路径的代价和,$ size_i $为$ i $的子树中询问点的个数,$ max_i $为$i$子树内的到$ i $的最长路,$ min_i $为最短路，则：$f_i=f_{son_i}+size_i\times k-size_{son_i}$$max_i = \max\left\{max_{son_i} + 1\right\}$路径和答案是$ f_{root}$, 对于每个点,用它的最大与次大的儿子更新答案.如果他是被询问的点,则还可以用它每个儿子更新答案. 四、状态压缩DP基于状态压缩的DP是由于状态用单个简单的变量直接存储存在空间的浪费，而采用压缩的状态的动态规划，例如： 插头DP：维护当前已决策和未决策的一条$Z$字形的轮廓线的插头状态，用括号序列配对插头，每次只需分情况讨论即可，但是这类DP的显著特点就是情况繁多，使用时须细心 例题、给一个$N$个点$M$条边的无向图，每个点有点权$A_i$，保证任意两点之间距离不超过$10$。现在要你选取一些点，使得每个点要么自己被选，要么相邻的点被选。一个方案的代价定义为选取的点的点权和，求最小代价。$N\le20000,M\le25000,0\le A_i\le10000$ 解法考虑如何利用 “距离不超过10” 这个限制.不妨把生成树搞出来,那么这个树的深度$ \le 10$. 一个很显然的想法是DP时,对每个点设状态$ dp_{u, S}$, 表示以$ u $为根的子树,当$ u $到根这条路径上的点的选取情况是$S $时的最小代价.由于,一个点可能会对通过非树边覆盖祖先,对于$S$中每个未选取的点,我们可以再记录一下它是否已经被覆盖.对于一个点状态数是$3^{10}$的.用$3$进制来表示$S$. 规定一下$S$中某一位的值的意义: 0: 这个点被选取了 1: 这个点未被选取, 但已经被覆盖 2: 这个点未被选取, 且仍未被覆盖 在DFS序上做即可.转移并不困难,注意的是当DFS序中前一个点不是当前点的父亲时,要把$dp$值维护一下.使用滚动数组,空间复杂度$ O(N + M + 3^{10})$,时间复杂度$O(M + 3^{10}N)$.对每个连通块都要做一遍. 例题一、对于任意一个正整数$N\le10^5$，求出${1,2,…,N}$的满足”若$x$在该子集中，则$2x,3x$不能在该子集”的子集个数。答案对$10^9+1$取模。$N\le10^5$ 思路将题目转化为“一个网格图，相邻点不能选”的计数问题，枚举左上角就行了。 五、DP套DP某些DP问题的子判定问题不能简单的解决,而必须用另一个DP解决,此时就只能使用DP套DP的方法,即：外面的DP的状态是存的里层DP各个状态的值,利用里层的状态来判断外层的DP是否合法,类似的问题有LCS为定值的序列的方案数等等。 例题一、给你一个只由$ACGT$组成的字符串$S$，对于每个$0\le k\le |S|$，问有多少个只由$ACGT$组成的长度为$M$字符串$T$，使得$LCS(S,T)=k$.$|S|\le15,M\le10^3$ 思路DP套DP，算LCS的DP为$dp_{i,j}=max(dp_{i-1,j-1}+[T_i=S_i],dp_{i-1,j},dp_{i,j-1})$这题的$ |S| $很小,不妨对于每个$ i$, 将$ j $不同时的DP值都记录下来,计个数即可.但是直接记DP值状态数会爆内存,但是注意到相邻的DP值只会差$1$,所以我们可以用$ 2^{|S|} $的状态数将这些值记录下来. 六、DP的形式优化有时在做一个DP问题时将会遇到时间或者空间复杂度过高的问题,而在DP的形式上优化便是有效的优化技巧, 典型的有预处理, 分阶段DP等: 预处理: 我们可能发现, 在DP的过程中, 出现了重复的运算, 浪费了时间, 所以我们可以通过DP前预处理, 或者DP过程总处理出最值, 而达到为后面的DP提供便捷的功能与作用, 达到优化的目的 分阶段DP: 在某些DP中将DP拆为一个个有特点阶段也许比将整个DP放在一起更加节省时间与空间, 所以对于彼此相对无关的转移, 可以分开考虑 例题一、给定长度为$N,M$的数组$A,B$，求最长公共上升子序列。$N,M\le5000$ 思路状态设计：$dp_{i,j}$表示$A$考虑到$i$，$B$考虑到$j$且必须选$j$的长度当$A_i=B_j$时，有转移$dp_{i,j}=\max\left\{dp_{i-1,k}|k&lt;j,B_k&lt;B_j\right\}+1$由于$A_i=B_j$，这个限制事实上就是$B_k&lt;A_i$，对于同一个$i$限制是相同的。我们可以从小到大枚举$j$，维护$\max\left\{dp_{i-1,k}|k&lt;j,B_k&lt;A_i\right\}$，直接转移即可。 例题二、现在有$n$个活动，每个活动需要占用$[l_i,r_i)$的时间，现在有两个会场，两个会场不能同时有活动，但是一个会场可以同时举办多个活动。要求安排每个活动在哪个会场举行，或者不举行，使得举行活动较少的会场举行活动最多。同时，对$i\in[1,n] $求出如果强制活动$i$必须举行，那么所求答案是多少。$n\le200$ 思路第一问，预处理出$[l,r)$表示$[l,r)$包含多少段区间，设$f_{i,j}$表示考虑了$[0,i)$区间，第一个会场举办$j$个活动的前提下，第二个会场最多举办多少活动。第二问，处理出DP数组的前后缀，对于每个询问合并答案令$g_{i,j}$表示考虑了$[i,size)$这个区间时的DP数组，不难想到：处理出$max_{l,r}$表示$[l,r)$区间一定选时的答案，然后合并前后缀。考虑优化合并过程，我们发现前缀和后缀都具有单调性，双指针即可。最终复杂度$O(n^3)$ 七、决策单调性优化DP问题的转移往往需要大量的时间, 如果我们能发现一些性质, 找到一些规律来优化 DP 决策转移的过程, 那么在时间上我们便能得到很大的优化, 常见的有四边形不等式优化, 以及一些1D/1D动态规划的优化。 四边形不等式优化对于形如以下DP:$f_{i,j}=f_{i,k-1}+f_{k,j}+w_{i,j}$如果$w$满足四边形不等式： 任意$i\le i’\le j\le j’$，有$w_{i,j}+w_{i’,j’}\le w_{i’,j}+w_{i,j’}$ 任意$i’\le i\le j\le j’$，有$w_{i,j}\le w_{i’,j’}$ 那么也可证明：$f_{i,j}+f_{i’,j’}\le f_{i’,j}+f_{i,j’}$而如果得到了这样的式子, 则就可以证明$ f_{i, j} $的决策一定在$f_{i, j − 1} $与$ f_{i − 1, j} $的决策之间:$s_{i,j-1}\le s_{i,j}\le s_{i-1,j}$四边形不等式的证明：http://wenku.baidu.com/link?url=344UHCQdTP9z2dFTCCGB3eBYHnlBeF0IAYdFeLmA_p0QU9nGv3L-6AyISk4zUKcTMBDrokvx_i-5BHh7H5ZFfjS3hf2j9jHdPCgUXwQjqS 1D/1D动态规划方程的优化$f_i=\min\left\{f_j+w_{j,i}|j\le i\right\}$若$w$满足四边形不等式，则可证明$f_i$的决策也一定单调。 例题一、NOI2009 诗人小G题面见P1912 思路首先推出DP方程:$f_i=\min\left\{f_j+|sum_i-sum_j-l|^p\right\}$令$w_{i,j}=|sum_i-sum_j-l|^p$，可以证明（不会证）$w$满足四边形不等式。由上述结论，对于任意的$i\le j$，$f_i$的决策一定$\le f_j$的决策，于是我们用一个栈来维护DP的决策。 八、斜率优化斜率优化DP是当DP转移式形如$f_i = \min\left\{f_j + k_ix_j + c_i + b_j\right\}$将与$ j $无关的常数提出$ \min$，我们就是要求$\min\left\{k_ix_j + f_j + b_j\right\}$令$ y_j = f_j + b_j$，每次我们实际上是在所有过 $(x_j , y_j )$ 且斜率为$-k_i $的直线$y_j =-k_ix_j+B$中找到一个直线具有最小的$ B$，即纵截距最小。显然最优的$(x_j , y_j ) $一定在凸壳上。于是我们便可以使用维护凸壳来将时间复杂度变得更优。根据$ x_j $和$ k_i $的单调性，我们可以： $x_j $与$ k_i $同时单调: 单调队列/单调栈 (hdu 3507) $x_j $单调,$ k_i $不单调: 单调队列/单调栈+二分斜率 (bzoj 2726) $x_j $不单调: Splay维护凸壳 (bzoj 1492) 九、凸单调性DP优化例题一、IOI2016 aliens题面见uoj240 思路将主对角线一边的点翻到另一边，去除一些无用点，首先可以推出一个显然的DP方程 $dp_{i,j}=\max\limits_{k&lt;j}\left\{dp_{i-1,k}+(x_j-y_{k+1}+1)^2-\max(0,x_k-y_{k+1}+1)^2\right\} $其中$dp_{i,j}$表示用$i$个正方形覆盖$j$个点所需要的最小并面积。这个转移方程可以很容易斜率优化，时间复杂度就变成$O(nk)$当然这并不能满足题目要求。如果$dp_{k,n}$是一个关于$k$的凸函数，那么不妨二分$dp_{k-1,n}$和$dp_{k,n}$这两个状态之间的差值（用一个一次函数取切，得一个切点）。将DP方程改为$dp_i=\max\limits_j&lt;i\left\{dp_j+(x_i-y_{j+1}+1)^2-\max(0,x_j-y_{j+1}+1)^2\right\}+x$转移一次有$x$的代价，记录一下$dp_n$转移达到最优值所需要的最少转移次数，就可以二分了。 十、容斥DP例题一、给定$n$个数$a_1,a_2,…,a_n$，将这些数分成两组，使得两组中的元素$or$和相同，求方案数，答案对1e9+7取模。$n\le50,0\le a_i\le2^{20}$ 解法按位考虑, 如果所有的数在某一位上都为$ 0$, 显然可以不用考虑.对于其它的位, 如果要满足题目的要求, 则必须满足所有这一位为$ 1$的数不能全部在同一组里. 虽然这个条件不好计数, 但是它的反面是很好计数的!所以, 枚举至少有哪些二进制位不满足条件, 然后用并查集维护一下就行了. 例题二、给定一个$N$维超立方体，第$i$个维度的长度为$r_i$，同时给你一个$N$维超平面$x_1+x_2+…+x_n=S$。这个超平面把超立方体切成至多两部分，求圆点所在那一部分的面积。$N\le500,A_i\le500,S\le10^9$ 思路有点超纲。。。学了微积分再补 例题三、[ZJOI2016]小星星题面见P3349 思路首先考虑一个错误的树形DP. 设$ dp_{u, p} $表示考虑了以$ u $为根的这个子树, 并且根映射到原图的$ p $点. 这个显然可以$ O(n^3) $转移, 但是有什么问题呢?不同的点可能映射到同一个点. 于是考虑容斥.求出$ dp_S $表示映射的点集至多为$ S $时的答案, 然后就可以$O(2^nn^3) $做了. 容斥何时起作用 $=$和$\not=$ $\min$和$\max$ gcd和lcm “恰好”和”至少” … 容斥的理解给定一些条件，问全部满足的对象的个数答案$=$所有对象$-$至少不满足其中一个的$+$至少不满足其中两个的$-$至少不满足其中三个的…另一种理解：在所有物品中, 问在某个条件$C_0$下所有物品的贡献之和.构造一些相对容易计算贡献的条件$C_1,…,C_n$再对于每个条件构造容斥系数 $f_1,…,f_n$ 满足对于每个物品$\sum\limits_{i=1}^{n}s_{C_i}f_i=s_{C_0}$其中$s_{C_i}$表示这个物品在条件$C_i$下所产生的贡献.对于常见的计数问题, 物品的贡献只会是$0/1$, 表示这个物品是否满足此条件. 凑系数一个经典的错排问题求长度为$n$的排列$a_1,…,a_n$的个数，满足$a_i\not=i$错排数：排列的不动点，即$a_i=i$的位置. 例题四、小学奥数（雾）给定$m$个数$a_1,a_2,…,a_n$，统计$[1,n]$的整数中，满足$a_1,a_2,…,a_n$中有奇数个数整除它的个数。$n\le10^9,m\le15$ 思路枚举$m$个数的一个子集，算出$lcm$，容斥一下。对于每个数，如果它被$k$个数整除，则有$\sum\limits_{i=0}^{k}C^i_kf_i=k\mod 2$可以求出所有的$f_i$ 例题五、异或图题面见bzoj4671 思路容斥。首先枚举子集划分，强制连通性“至少”是这个划分，也就是说，不同子集的两个点之间一定没有边，相同子集的两个点则任意.对于一个有$m$个联通块的图，容斥系数需要满足$\sum\limits_{i=1}^{m}$ 例题六、[NOI2009]管道取珠题面见P1758 技巧：平方处理思路统计平方的和, 转化成统计有序对.即统计有多少对$(wayA, wayB)$使得$wayA, wayB$均能得到相同的结果. 例题七、给定$S, T, K,$求每次$+1, −1,$用不超过$K$次操作从$S$变成$T$的方案数.每一时刻都不能为负$S,T,K\le10^5$ 技巧：反射法在平面直角坐标系中画出图像($x $轴代表时间,$ y $轴代表当前的数值), 发现所有不合法的路径都可以沿$ y = −1 $反射到一条从$(-(S + 2), 0) $到$ (T, 0) $的路径.直接组合数计算即可. 当然直接减一下转化为不能穿过对角线也是一样的.]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day4]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day4%2F</url>
    <content type="text"><![CDATA[Day4 上午——数学一、BSGS给定质数$p$，给定$a$和$b$，$(a,p)=1$。求最小的非负整数$x$，使得$a^x\equiv b(mod\;p)$。 解法首先根据欧拉定理$a^{\phi(p)}\equiv1(mod\;p)$，当$a^x\equiv b(mod\;p)$有解，最小非负整数解一定在$[0,\phi(p))$中。令$m=\sqrt{\phi(p)}$，任意$x\in [0,\phi(p))$都可以分解成$im+j$的形式，其中$0\le i \le m,0 \le j &lt;m$。枚举$i$的值，$a^x\equiv b(mod\;p)\Leftrightarrow a^j\equiv a^{-im}b(mod\;p)$。将$a^0,a^1,a^2…$放到$hash$表中查询就可以了。复杂度：$O(\sqrt{\phi(p)})$另外，如果要解决$p$不为素数的情况，需要用到$exBSGS$ 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x)#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e2 + 5, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;ll mod;inl ll ksm(rg ll a, rg ll b)&#123; rg ll ans = 1; for (; b; b &gt;&gt;= 1, (a *= a) %= mod) if (b &amp; 1)(ans *= a) %= mod; return ans;&#125;inl ll BSGS(rg ll a, rg ll b)&#123; rg ll p = mod; a %= p, b %= p; map&lt;ll, ll&gt;mp; rg ll m = ceil(sqrt(p)), t = 1; for (rg int i = 0; i &lt; m; ++i) &#123; if (!mp.count(t)) mp[t] = i; (t *= a) %= p; &#125; rg ll k = ksm(t, p - 2), w = b; for (rg int i = 0; i &lt; m; ++i) &#123; if (mp.count(w))return i * m + mp[w]; (w *= k) %= p; &#125; return -1;&#125;int main(void)&#123; rg ll a, b; while (~scanf("%lld%lld%lld",&amp;mod, &amp;a, &amp;b)) &#123; rg ll ans = BSGS(a, b); if (~ans)fast_IO::write(ans), putchar('\n'); else puts("no solution"); &#125; return 0;&#125; exBSGS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#pragma GCC optimize("fast-math,unroll-loops")#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")#include &lt;bits/stdc++.h&gt;#include &lt;unordered_map&gt;#define lowbit(x) (x&amp;-x)#define jh(x, y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e2 + 5, mod = 998244353, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;unordered_map&lt;ll, ll&gt;mp;ll a, b, p;inl ll GCD(rg ll a, rg ll b) &#123; while (b ^= a ^= b ^= a %= b); return a; &#125;inl ll exBSGS(rg ll a, rg ll b, rg ll p)&#123; if (b == 1)return 0; rg ll gcd, add = 0, mul = 1; while ((gcd = GCD(a, p)) ^ 1) &#123; if (b%gcd)return -1; b /= gcd, p /= gcd, ++add; (mul *= a / gcd) %= p; if (mul == b)return add; &#125; rg ll m = sqrt(p) + 1, kt = 1; mp.clear(); for (rg int i = 0; i != m; ++i) &#123; mp[kt*b%p] = i; (kt *= a) %= p; &#125; (mul *= kt) %= p; for (rg int i = 1; i &lt;= m; ++i) &#123; if (mp.find(mul) != mp.end())return i * m - mp[mul] + add; (mul *= kt) %= p; &#125; return -1;&#125;int main(void)&#123; while (a = fast_IO::read(), p = fast_IO::read(), b = fast_IO::read()) &#123; rg ll ans = exBSGS(a, b, p); if (~ans)fast_IO::write(ans), putchar('\n'); else puts("No Solution"); &#125; return 0;&#125; 二、Miller-Rabin给定$n$，判定$n$是否为素数。 解法首先筛去偶数，我们只考虑奇数的情况。显然$\forall x\in[1,p-1],x^p\equiv x(mod\;p)$，但是有些合数也满足这个性质，所以不能直接用这个性质来判断一个数是不是素数。考虑$x^2\equiv 1(mod\;n)$的根，若$n$是奇素数，则只有$1$和$n-1$(即$-1$两根)，因为原式可以改写成$(x+1)(x-1)\equiv 0(mod\;n)$。设$n-1\equiv 2^r\times d$，其中$d$是奇数。$n$是合数当且仅当存在$0\le k&lt; r,a^{2^k\times d}\not\equiv1,-1(mod\;n)$，且$a^{2^{k+1}\times d}\equiv1(mod\;n)$。选取多个$a$进行二次探查，减小错误率。 模板（int64）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x)#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e2 + 5, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;ll num[11] = &#123; 0,2,3,5,7,11,13,17,19,23,29 &#125;;inl ll ksm(rg ll a, rg ll b, rg ll mod)&#123; rg ll ans = 1; for (; b; b &gt;&gt;= 1, (a *= a) %= mod)if (b &amp; 1)(ans *= a) %= mod; return ans;&#125;inl bool detective(rg ll x, rg ll n)&#123; rg int r = 0; rg ll d = n - 1; while (!(d &amp; 1))d &gt;&gt;= 1, ++r; for (rg ll a = ksm(x, d, n), b; r; --r) &#123; b = a * a%n; if (b == 1)return a == 1 || a == n - 1; a = b; &#125; return false;&#125;inl int Miller_Rabin(rg ll x)&#123; for (rg int i = 1; i &lt;= 10; ++i) &#123; if (x == num[i])return 1; if (x%num[i] == 0)return 0; if (!detective(num[i], x))return 0; &#125; return 1;&#125;int main(void)&#123; rg int m = fast_IO::read(); while (m--)puts(Miller_Rabin(fast_IO::read()) ? "Yes" : "No"); return 0;&#125; 实践结论对于$int32$范围内的数，我们选取$2,7,61$探测即可。对于$int64$范围内的数，我们选取前十个素数探测即可。 三、Pollard-rho给定$n$，将$n$质因数分解。 解法如果用Miller-Rabin测试出来$n$是素数，直接停止算法。随机基底$a$和$c$，，生成序列$x_0=a,x^2_{i-1}+c(mod\;n)$，可以说序列${x_i}$是一个随机序列。如果出现$(x_i-x_{2i+1},n)\not=1$，停止算法。令$d=(x_i-x_{2i+1},n)$，若$d\not=n$，那么$d$就是$n$的一个非平凡因子，$n$可以被分为$\dfrac{n}{d}$和$d$相乘的结果，递归下去对$\dfrac{n}{d}$和$d$分别求解。复杂度$O(N^{\dfrac{1}{4}})$ 四、Linear-Shaker给定$n$，筛出$n$以内的所有素数。 解法见线性筛模板P3383。 五、Chinese Reminder Thereom$x\;mod\;n_1=x_1$$x\;mod\;n_2=x_2$$x\;mod\;n_3=x_3$…其中$n_1,n_2,…,n_k$两两互质，求$x$的一个合法解。 解法令$N=\prod\limits_{i=1}^{k}n_i$，$m_i=\dfrac{N}{n_i}$，$t_i=m_i^{-1}(mod\;n)$。$x=\sum\limits_i x_im_it_i(mod\;n)$我们容易发现，当$j=i$时，$m_it_i\equiv1(mod\;n_j)$，当$j\not=i$时，$m_it_i\equiv0(mod\;n_j)$，因此$x$一定是方程组的一组解。 模板（UVA756）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x)#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e2 + 5, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;ll mod[3]&#123; 23,28,33 &#125;, x[3];ll exgcd(rg ll a, rg ll b, rg ll &amp;x, rg ll &amp;y)&#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; rg ll yu = exgcd(b, a%b, x, y); rg ll tmp = x; x = y; y = tmp - a / b * y; return yu;&#125;inl ll CRT(rg int n)&#123; rg ll sum = 1, ans = 0, m; for (rg int i = 0; i != n; ++i)sum *= mod[i]; for (rg int i = 0; i != n; ++i) &#123; rg ll xx, y; m = sum / mod[i]; exgcd(m, mod[i], xx, y); ans += m * xx *x[i]; &#125; return ans % sum;&#125;int main(void)&#123; rg int d, step = 0; while (~(x[0] = fast_IO::read())) &#123; x[1] = fast_IO::read(), x[2] = fast_IO::read(); rg ll ans = CRT(3) - fast_IO::read(); ((ans %= 21252) += 21252) %= 21252; ans = (ans - 1 + 21252) % 21252 + 1; printf("Case %d: the next triple peak occurs in %d days.\n", ++step, ans); &#125; return 0;&#125; exCRT模板（POJ2891）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//#pragma GCC optimize("fast-math,unroll-loops")//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x)#define jh(x, y) x^=y^=x^=y#define rg register#define inl inlinetypedef __int128 ll;const int N = 1e5 + 5, mod = 1e9 + 7, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;ll mo[N], yu[N];ll exGCD(rg ll a, rg ll b, rg ll &amp;x, rg ll &amp;y)&#123; if (!b)return x = 1, y = 0, a; rg ll gcd = exGCD(b, a%b, x, y); rg ll tmpx = x; x = y; y = tmpx - a / b * y; return gcd;&#125;inl ll exCRT()&#123; rg int n = fast_IO::read(); for (rg int i = 1; i &lt;= n; ++i)mo[i] = fast_IO::read(), yu[i] = fast_IO::read(); rg ll ans = yu[1], lcm = mo[1]; for (rg int i = 2; i &lt;= n; ++i) &#123; rg ll x, y, c = (yu[i] - ans % mo[i] + mo[i]) % mo[i]; rg ll gcd = exGCD(lcm, mo[i], x, y), b = mo[i] / gcd; if (c%gcd)return -1; (x *= c / gcd) %= b; ans += lcm * x; lcm *= b; ans = (ans%lcm + lcm) % lcm; &#125; return (ans%lcm + lcm) % lcm;;&#125;int main(void)&#123; fast_IO::write(exCRT()); return 0;&#125; 六、Quadratic residue给定$y$和奇素数$p$，求$x$，使得$x^2\equiv y(mod\;p)$。 欧拉判别法若$y^{\dfrac{p-1}{2}}\equiv1(mod\;p)$，则$y$在模奇素数$p$下有二次剩余若$y^{\dfrac{p-1}{2}}\equiv-1(mod\;p)$，则$y$在模奇素数$p$下没有二次剩余勒让德符号$(\dfrac{a}{p})\equiv a^{\dfrac{p-1}{2}}$$1,…,p-1$中有$\dfrac{p-1}{2}$个数的勒让德符号为$1$，另外$\dfrac{p-1}{2}$个数的勒让德符号为$-1$。 解法不断随机$a$，使得$(\dfrac{a^2-y}{p})=-1$令$\omega=\sqrt{a^2-y},x=(a+\omega)^{\dfrac{(p+1)}{2}}$由于$x^2\equiv(a+\omega)^p\times(a+\omega)\equiv(a+\omega)\sum\limits_{j}C^j_p\omega^{p-j}$$\equiv(a^p+\omega^p)(a+\omega)\equiv(a-\omega)(a+\omega)\equiv a^2-\omega^2\equiv y(mod\;p)$所以最终答案就是$(a+\sqrt{a^2-y})^{\dfrac{p+1}{2}}$ 例题给定长度为$n$的整数$a$，判断$a$是否是完全平方数。$n\le1000$ 思路选多组素数进行判别，考虑$x^2\equiv a(mod\;p)$成立，随机一些素数$p$判别就行了。 七、Multiplicative function狄利克雷卷积$(fg)(n)=\sum_{d|n}f(d)g(n/d)$ 积性函数积性函数的性质： $\forall (a,b)=1,f(ab)=f(a)f(b)$ 积性函数的卷积仍然是积性函数 所以其实我们可以把$n$看成$n=p_1^{k_1}p_2^{k_2}…p_m^{k_m}$常见的积性函数： 普通函数:$I(n)=1,id(n)=n,e(n)=[n=1]$ 除数函数:$\sigma_k(n)=\sum\limits_{d|n}d^k$ 欧拉函数:$\phi(n)=n\times\dfrac{p_1-1}{p_1}\times…\times\dfrac{p_m-1}{p_m}$ 莫比乌斯函数:$\mu(n)=[k_1\le1][k_2\le1]…k_m\le1^m$ $\sum\limits_{d|n}\mu(d)=[n=1]\Rightarrow\mu\times1=e$$\sum\limits_{d|n}\phi(d)=n\Rightarrow\phi\times1=id$ $\phi$和$\mu$的前$n$项与前缀和前$n$项可以在做线性筛的过程中求出，前缀和用杜教筛或者min25等算法解决 Day4 下午八、Primitive root（原根）给定$n$，若$a$满足$(a,n)=1$且$1,a,a^2,a^3,…,a^{\phi(n)-1}$在$mod\;n$下都互不相同，则称$a$是$n$的一个原根。 原根的性质 $2,4,p^n,2p^n$有原根，$p$是奇素数。 若$n$有原根，则原根数量为$\phi(\phi(n))$个。 阶最小的非零$x$使得$a^x\equiv 1(mod\;p)$，记为$$ 有关阶的定理①若$p&gt;1$且$(a,p)=1$，又满足$a^n\equiv1(mod\;p)$，则$|n$②$|\phi(p)$ 求法将$\phi(p)$质因数分解，$\phi(p)=p_1^{w_1}p_2^{w_2}…p_k^{w_k}$枚举$g$，如果恒满足$g^{\dfrac{\phi(m)}{p_i}} \not =1$，其中$i=1,2,…,k$则$g$是$m$的一个原根 九、Combination（组合数）求法：杨辉三角预处理阶乘及逆元 十、Recurrence relation（递推关系）矩阵乘法：$C_{i,j}=\sum A_{i,k}\times B_{k,j}$。 例题给定一张$N$个点$M$条边的有向图，$Q$次询问图中从每个点出发的长度为$K$的路径各有多少条。$N\le100,Q\le10,K\le100$ 思路分块矩乘。 十一、Principle of inclusion-exclusion（容斥原理）容斥原理$F(A\bigcup B\bigcup C)=F(A)+F(B)+F(C)-F(A\bigcap B)-F(B\bigcap C)-F(A\bigcap C)+F(A\bigcap B\bigcap C)$ 十二、Binomial inversion(二项式反演)$f_n=\sum\limits_{i=0}^{n}(-1)^iC^i_ng_i\Leftrightarrow g_n=\sum\limits_{i=0}^{n}(-1)^iC^i_nf_i$$f_n=\sum\limits_{i=0}^{n}C^i_ng_i\Leftrightarrow g_n=\sum\limits_{i=0}^{n}(-1)^{n-i}C^i_nf_i$ 例题、集合计数$n$个元素有$2^n$种不同的子集，现从$2^n$个子集中选取若干子集，求有多少种方案，使得选出集合的交元素个数为$K$。$n,k\le 10^6$，对$10^9+7$取模 思路令$g_k$表示选出集合的集合交为$k$时的方案数，$f_k$表示选出集合的集合交至少为$k$时的方案数。$f_i=C^i_n(2^{2^{n-i}}-1)$$f_i=\sum\limits_{j=i}^{n}g_jC^i_j$ 推出$g_i=\sum\limits_{j=i}^{n}C^j_n(2^{2^{n-j}}-1)(-1)^{j-k}C^k_j$ 十三、Probability Thereom（概率论）期望：$E(x)=\sum\limits_{i=1}^{n}a_iP(x=a_i)$期望具有线性性 例题、求逆序对长度为$n$的序列，求逆序对的期望个数。令$a_{i,j}$表示$i,j$是否逆序，逆序则为1，否则为0。 例题、Clear the room给定一个$n\times m$的网格，$(i,j)$中有物品价值$w_{i,j}$。现取$K$次，每次取走一个矩形内所有物品，问$K$次操作后拿走物品价值和期望。$n,m\le500,K\le10^9$ 思路求出每一个点被选中的概率$p$，不难想到我们要想选中一个点$(x,y)$，必须要使得选中的矩形包含$(x,y)$，也就是$x_1\le x\le x_2,y_1\le y \le y_2$，那么推出结论：选中一点$(x,y)$的概率$p=\dfrac{x\times(n-x+1)\times y\times(m-y+1)}{n^2\times m^2}$，答案就等于$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}w_{i,j}p_{i,j}^k$ 十四、Gaussian（高斯消元）模板。]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day3]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day3%2F</url>
    <content type="text"><![CDATA[Day3上午——图论一、强联通分量强联通分量即是环极大强联通子图：将原图中任何点加入这个子图都不能构成强联通分量的强联通分量。极大不一定最大。强联通分量针对有向图。途中每个点都属于且仅属于一个极大强联通分量。强联通分量与点的关系具有传递性。求强联通分量可以使用Tarjan算法或者Kosaraju算法，我们主要使用Tarjan算法。 二、Tarjan算法考虑当前dfs到某个点now,其余点只有三种：①可以访问到的点②不能访问到的点③未访问的点dfs的过程中，如果从某一点出发可以回到这个点，那么一定会存在一个强联通分量，而这个强联通分量就在dfs的栈里，所以我们可以用一个栈记录一下经过的点，去找强联通分量。定义dfn[x]为搜索到x的时间，即编号，low[x]为从x出发可以走到的最小点。我们发现如果从某点出发搜完之后low[x]==dfn[x]，说明此时从x出发有一个强联通分量，此时我们把记录的栈弹出至遇到x就是一个强联通分量。 缩点缩点后，新图为一个DAG。 例题一、The Cow Prom题面见P2863。tarjan裸题。 例题二、受欢迎的牛题面见P2341。 思路首先缩点，发现如果某个点只有入度且只有这个点是只有入度的，那么这个点就是要求的点，否则不存在。 例题三、稳定婚姻题面见P1407。 思路夫妻男连女，情人女连男，跑一边tarjan，如果一对夫妻在同一个强联通分量中，这段婚姻就是不稳定的。 三、双联通分量割点和桥将点$x$删掉后，图中联通分量个数增加，称$x$为割点。将边$e$删掉后，图中联通分量个数增加，称$e$为桥。点双联通分量：两点间的所有路径不经过同一点的联通分量。边双联通分量：两点间的所有路径不经过同一边的联通分量。 割点求法类似于tarjan，如果x有一个出点low值$\ge dfn[x]$说明x是割点，注意要特殊处理第一个搜索的点。 边双联通分量求法和求强联通分量几乎一样，判断一下不走回头路就行了，不能走走过的边。扔个模板1234567891011121314151617181920212223242526272829303132333435363738394041424344...int nt[N], b[N], p[N], num = 1, st[N], dfn[N], low[N], ltk[N], id;bool flag[N];inl void add(rg int x, rg int y)&#123; b[++num] = y, nt[num] = p[x], p[x] = num; b[++num] = x, nt[num] = p[y], p[y] = num;&#125;void tarjan(rg int x)&#123; dfn[x] = low[x] = ++id; st[++*st] = x; for (rg int e = p[x]; e; e = nt[e]) if (!flag[e]) &#123; rg int k = b[e]; if (!dfn[k]) &#123; flag[e] = flag[e ^ 1] = true; tarjan(k); flag[e] = flag[e ^ 1] = false; low[x] = fast_IO::min(low[x], low[k]); &#125; else low[x] = fast_IO::min(low[x], dfn[k]); &#125; if (dfn[x] == low[x]) &#123; ++*ltk; while (st[*st + 1] != x) &#123; ltk[st[*st]] = *ltk; --*st; &#125; &#125;&#125;int main(void)&#123; ... for (rg int i = 1; i &lt;= m; ++i)add(fast_IO::read(), fast_IO::read()); for (rg int i = 1; i &lt;= n; ++i)if (!dfn[i])*ltk = 0, tarjan(i); ... return 0;&#125; 例题一、冗余路径Redundant Paths题面见P2860。 思路先求边双联通分量，缩点后成了一颗树，这棵树的度数为1的点的数量sum，答案就是⌈$sum/2$⌉，答案的正确性显然，因为每个度数为1的节点肯定需要连边出去，贪心的想就很容易证明了。 点双联通分量求法在求割点的过程中就能求出，稍微改动一下就行，我们考虑将经过的边入栈而不是经过的点，在找到割点的时候，把边一个个从栈中取出直到遇到边$(u,v)$，取出的边与其关联的点构成一个点双联通分量。由于点双联通分量求法不太一样，扔个模板吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct Node &#123; int u, v;&#125;e[N], st[N], tp;int nt[N], p[N], top, dfn[N], low[N], id, gedian[N], bcc_cnt, belong[N];vector&lt;int&gt;bcc[N];void tarjan(rg int x, rg int fa)&#123; rg int child = 0; dfn[x] = low[x] = ++id; for (rg int k = p[x]; k; k = nt[k]) &#123; rg int to = e[k].v; st[++top] = e[k]; if (!dfn[to]) &#123; ++child; tarjan(to, x); low[x] = fast_IO::min(low[x], low[to]); if (low[to] &gt;= dfn[x]) &#123; gedian[x] = true; bcc[++bcc_cnt].clear(); do &#123; tp = st[top--]; if (belong[tp.u] != bcc_cnt) &#123; bcc[bcc_cnt].push_back(tp.u); belong[tp.u] = bcc_cnt; &#125; if (belong[tp.v] != bcc_cnt) &#123; bcc[bcc_cnt].push_back(tp.v); belong[tp.v] = bcc_cnt; &#125; &#125; while (tp.u != e[k].u || tp.v != e[k].v); &#125; else if (e[k].v != fa)low[x] = fast_IO::min(low[x], dfn[to]); &#125; &#125; if (!fa) &#123; if (child &gt; 1)gedian[x] = true; else gedian[x] = false; &#125;&#125;...int main()&#123; ... for (rg int i = 1; i &lt;= n; ++i) if (!dfn[i])tarjan(i, 0); ... return 0;&#125; 四、二分图二分图的判定对二分图黑白染色，如果产生矛盾说明不是二分图。（二分图中无奇环）。 Hall定理设二分图中$G=$中$\left| V1 \right|=m\le\left| V2 \right|=n$,$G$中存在从$V1$到$V2$的完全匹配当且仅当$V1$中任意$k(k=1,2,…,m)$个顶点至少与$V2$中$k$个顶点是相邻的。 匈牙利算法贪心，过程比较简单，扔个模板12345678910111213141516171819202122232425262728vector&lt;int&gt;e[N];int mat[N];bool flag[N];bool dfs(rg int x)&#123; for (rg int i = 0; i != e[x].size(); ++i) &#123; rg int j = e[x][i]; if (flag[j])continue; flag[j] = false; if (!mat[j] || dfs(mat[j]))return mat[j] = x; &#125; return false;&#125;...int main()&#123; ... for (rg int i = 1; i &lt;= n; ++i) &#123; if (dfs(i))++ans; memset(flag, 0, sizeof(flag)); &#125; ... return 0;&#125; 几个定理二分图最小点覆盖==二分图最大匹配点覆盖：在图中选取一些点，保证每条边至少有一个点在选取点中，称这些点是一个点覆盖。二分图最大点独立集==总点数-二分图最大匹配独立集：在图中选取一些点，保证每个点不相邻，则称这些点是一个独立集。 例题一、Asteroids 小行星题面见POJ3041。 思路行列分开，对于小行星的坐标$(x,y)$，连边$(x,y)$，跑二分图匹配求最小点覆盖即是答案。 例题二、Muddy Fields 泥泞的牧场题面见POJ2226 思路和前面那道例题类似，贪心的考虑，每块板子肯定是延伸到最长最好，所以我们把一些板子分成两部分：$A$部分是所有横着的木板，$B$为所有竖着的木板，将横竖交叉的木板连边，构成一个二分图，这样选择一个点就代表选择一个板子，求最小点覆盖就是我们要求的答案。 五、2-SATSAT问题是给出一些条件（元素经过逻辑运算的结果，如and or xor），SAT问题已经被证明是一个NP完全问题。2-SAT问题中最多有两个条件。 求法对于每个变量$x$，建立两个点$x_t$和$x_f$，分别表示$x$取TRUE和$x$取FALSE。对于所有的“A取x则B取y”，连边$(A_x,B_y)$，该图中如果P能到达Q，表示“若P成立，则Q一定成立”所以如果从$a_f$出发能到达$a_t$或者$a_t$出发能到达$a_f$，则矛盾。这一步的检验我们考虑用tarjan求联通分量，$O(N)$解决。如果没有这种情况出现，则一定存在合法方案。现在我们考虑如何构造一组可行解我们构造这样一种方案：缩点之后按照“逆拓扑序”挑选一个未被染色的强联通分量将其染成黑色，然后把所有与这个强联通分量里的点矛盾的点所在的联通分量染成白色。最后所有染成黑色的强联通分量里的点就是选择的方案。 例题一、NOI2017 游戏题面见P3825 思路对于$a,b,c$，就直接裸的2-SAT。对于$x$，如果直接枚举选$A,B,C$中的哪个，复杂度要乘上$3^d$，但是如果我们考虑枚举x不适合哪辆车，复杂度就乘上$2^d$。 Day3下午一、网络流除了源点和汇点，所有点的输入与输出平衡。 求法Ford-Fulkerson算法DinicSAP等等。。。个人觉得用dinic就够了…… 二、Dinic反向边：用于反悔，保证所有操作可撤销。 优化当前弧优化 三、最小割最小割定理最小割==最大流 例题一、吃饭Dining题面见P2891。 思路把牛拆成两个点，这两个点之间连容量为1的边，原点连食物，食物连牛，牛连饮料，饮料连汇点，跑最大流。 经典最小割模型——最大闭合子图图中的点有点权，点权可正可负，在图中选一些点，如果有边$(u,v)$则选u必选v。 解法建图：对于权值为正$x$的点，从源点连一条容量为$x$的边，权值为负$y$的点，向汇点连一条容量为$y$的边，原图边容量为正无穷（较大值）。 例题二、NOI2006 最大获利题面见P4174。 思路将题目中的边都看成点边对应的点依赖于原图中的点将边转化为点，则该图转化为一个二分图求这个二分图的最大闭合子图就行了。 经典最小割模型——二分图最小点权覆盖给出一个二分图，每个点有非负点权选出一些点构成一个覆盖，求最小点权和 解法源点向左边的点连容量为点权的边，右边的点向汇点连容量为点权的边，求最小割即可。 例题三、游戏一张图，删除每个点的入边有费用$w_i+$，删除每个点的出边有费用$w_i-$，求删除所有边需要的最小费用。 思路将所有入边和出边看成点，同一条边之间连容量无穷大的边，构成一个二分图，求这个二分图的最小点权覆盖就行了。 经典最小割模型——二分图最大点权覆盖给出一个二分图，每个点有非负点权选出一些点构成一个覆盖，求最大点权和 解法点权和减去最大流。 例题四、方格取数问题题面见P2774 思路黑白染色成一个二分图，跑最小割，用全局和-最小割即可。 四、费用流图中的边不仅有容量，还有费用。最小费用最大流：流量最大的情况下费用最小最小费用流：跑最短路，如果途中发现跑某条路径会使费用变大，就停止，最大费用流同理。 例题一、晨跑题面见P2153 思路拆点限流，连边直接跑费用流出解。 经典费用流模型——连续$M$个元素最多选$K$个给定$n$个元素，每个元素有权值$a_i$（可正可负），要求从中选出一些，满足其中任意相邻$M$个元素中只有最多$K$个元素被选出。 解法把题目转换为选$K$次，每次要求选出的点距离大于$M$，建图的时候从每个点$i$向$i+M$连边，容量为1，费用为$a_i$，相邻点之间连边，费用为0容量为$INF$，源点向第一个点连边，容量为$K$费用为0，最后一个点向汇点连边，容量为$INF$费用为0，跑费用流即可。 例题二、数字配对题面见P4068。 思路设$cnt_i$表示第i个数字质因数分解后各质因数的指数和。按照cnt的奇偶性，将这些数字分为两个集合。从源点向所有$cnt_i$为奇数的点连容量为$b_i$，费用为0的边。从所有$cnt_i$为偶数的点向汇点连容量为$b_i$，费用为0的边。对于一对$a_i$和$a_j$，如果$a_i$和$a_j$能匹配且$cnt_i$为奇数，连边，容量为$INF$，费用为$c_i\times c_j$。考虑贪心，跑最大费用最大流，每次跑最长路，在价值总和不小于0的情况下尽量增加流量，如果找不到增广路或者增广下去会使费用小于0则说明找到了答案。 例题三、方格取数问题题面见P2045。 思路拆点，两点之间连两条边，第一条边费用是该点权值，流量是1，另一条边费用是0，流量是$INF$。从源点向左上角连费用为0，流量为$K$的边，右下角向汇点连边，费用为0，流量为$INF$，跑最大费用最大流。 例题四、修车题面见P2053。 思路一个工人拆成$n$个点，表示n个时间段的工人，将$n$辆车与这$m \times n$个点都连起来，容量为1，费用为工人的时间段$\times$输入的时间，源点到车费用为0，流量为1，工人到汇点费用为0，流量为1，跑最小费用最大流即可，最后答案用总时间除以车数。 例题五、费用流题面见P3305。 思路二分最大的容量，跑dinic。 例题六、小M的作物题面见P1361。 思路按题目建图，一个点拆成两个点 五、上下界网络流每条边除了流量上界，还有流量下界。 解法这里借用了这篇博客 感觉总结的非常好①无源汇有上下界可行流（循环流）模型:一个网络,求出一个流,使得每条边的流量必须$\ge L_i$且$\le H_i$,每个点必须满足总流入量$=$总流出量(流量守恒)(这个流的特点是循环往复,无始无终)。可行流算法的核心是将一个不满足流量守恒的初始流调整成满足流量守恒（所有点的流入量$=$流出量）的流。我们可以令每条边的流量为该边的下界得到一个初始流，然后建出这个流的残量网络（每条边的上界与下界之差）。考虑在残量网络上求出一个附加流，使得附加流与可行流合并之后达到流量守恒，即：1)如果某个点在所有边流量等于下界的初始流中满足流量守恒,那么这个点在附加流中也满足流量守恒,2)如果某个点在初始流中的流入量比流出量多$x$,那么这个点在附加流中的流出量比流入量多$x$.3)如果某个点在初始流中的流入量比流出量少$x$,那么这个点在附加流中的流出量比流入量少$x$.$x$可以通过枚举点$i$的所有连边求出，开一个数组$A[]$，统计$i$点的流入量-流出量大小，根据$A_i$的正负表示流入量与流出量的大小关系。我们在残量网络中加入一些点和边，首先是虚拟超级源$ss$和虚拟超级汇$tt$。如果$A_i&lt;0$，从$i$向$tt$连一条容量为$-A_i$的边，反之从$ss$向$i$连一条容量为$A_i$的边。最后在建出的图上跑最大流，如果$ss$和$tt$连接的边都是满流的说明存在可行流，每条边在可行流中的流量$=$容量下界$+$附加流中它的流量（即反向边的权值）。 ②有源汇有上下界可行流模型:现在的网络有一个源点$s$和汇点$t$,求出一个流使得源点的总流出量等于汇点的总流入量,其他的点满足流量守恒,而且每条边的流量满足上界和下界限制。从$t$向$s$连一条下界为0，上界为$INF$的边，改成无源汇上下界可行流，跑完之后拆掉这条边就得到有源汇上下界可行流。最终的流量为这条边的反向边流量。 ③有源汇有上下界最大流模型:现在的网络有一个源点$s$和汇点$t$,求出一个流使得源点的总流出量等于汇点的总流入量,其他的点满足流量守恒,而且每条边的流量满足上界和下界限制。在这些前提下要求总流量最大。先跑出可行流，再在残量网络上跑出$s-t$最大流，最终的最大流$=$可行流流量$+$新增广出的$s-t$流量。 ④有源汇有上下界最小流模型:现在的网络有一个源点$s$和汇点$t$,求出一个流使得源点的总流出量等于汇点的总流入量,其他的点满足流量守恒,而且每条边的流量满足上界和下界限制。在这些前提下要求总流量最小。还是先跑出可行流，然后再残量网络上跑出$t-s$最大流，最终的最小流$=$可行流-$t-s$的最大流。]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day2]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day2%2F</url>
    <content type="text"><![CDATA[Day2上午一、基本分治例题一、归并排序如题…基础排序之一。 二、树分治①点分治原则上要尽量减小递归层，而考虑删去当前某节点之后，剩余节点数量最多的联通块尽量少，此时递归层数一定是最小的。这个节点就是“重心”。重心可以$O(n)$DP求得 例题一、IOI2011 Race给定一颗$n$个点的带边权的树，求一条路径使得权值和为$K$且边数量最少。$1\le n \le10^5,K\le10^6$ 思路点分治，记录到根路径长为dist[i]的最小边数即可 ②边分治选择一条边删去，得到两颗不相交的子树，统计这条边的信息。选边方法与点分治的选点几乎一致。 一个优化我们发现菊花图可以轻松卡掉边分，于是我们考虑重构这颗树，使得度数最大的点度数最小，采用的策略是加虚点（个人喜欢左孩子右兄弟）关键是两点间路径经过的实边不能变。 例题二、bzoj2870题面见bzoj2870 思路采用边分治。考虑删去一条边以后这条边的两端$a,b$，考虑将a端子树和b端子树中的链按点权最小值排序，对a端来说，每条链选b端中点权最小值不小于这条链且最长的链，b端同理，如此就可以做出这道题。 ③链分治（树链剖分）略（太过于模板） 三、CDQ分治普通分治：将区间分成两部分递归求解后合并。CDQ分治：在普通分治基础上需要加上左半区间对右半区间对贡献得到答案 例题一、二维偏序（上一篇好像有一样的题） 思路首先进行双关键字排序根据CDQ分治，不断递归至区间长度为1关键在于计算贡献考虑到子区间贡已经求出，我们将两个区间按第二维进行排序，如果左区间的一个有序对$(u,v)$对右区间的一个有序对$(a,b)$产生贡献，那么就等价于$v&lt;b$，双指针扫一遍即可。又考虑到我们按b排序，显然用归并复杂度比较优秀。 四、整体二分整体二分需要满足五个性质：①询问的答案具有可二分性（单调性）②修改对询问是独立互不影响的。③不同的修改贡献可叠加，不用重复计算④贡献满足交换律、结合律，有可加性⑤题目允许离线实现起来就是将所有询问一起二分 例题一、Meteors题面见SP10264 二分答案，线段树模拟当前区间的修改 五、三分用于求解凸函数（单峰函数） 六、分块整块整体做，边角暴力做 七、莫队将询问离线排序，优化暴力过程。 八、树上莫队借助欧拉序（括号序）将树上问题转换成区间问题，其余与莫队大致相同。 九、块状链表略 Day2下午今天下午是考试，结果…T1文件名写错，T2感觉没问题莫名wa掉，T3空间开小——完美爆0（解决上述问题后拿到60分暴力分）然后发现T2逆序对求错。。。总之以后细心更重要。题目暂时就不贴了。。。打完再来发]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day1]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day1%2F</url>
    <content type="text"><![CDATA[Day1 上午——高级数据结构一、树状数组基本功能1.单点修改，前缀信息查询2.区间修改可减信息，单点查询 对lowbit的理解保留x中最后一位1（由位运算实现）1#define lowbit(x) (x&amp;-x) 例题一:矩形数点给定$n$个点坐标($x_i$,$y_i$)，q次询问，每次询问给出一个矩形的右上角坐标和左下角坐标，求矩形内包含给定点的个数n, q $\leq$ $10^5$，0 $\leq$ $x_i$, $y_i$ $\leq$ $10^9$ 思路首先用容斥原理把矩形拆型四个二维偏序区域（形如$\sum$[$x_i$ $\leq$ $x$, $y_i$ $\leq$ $y$]）将数据离散化，排序，此时$x$自然满足偏序结构，用树状数组根据$y$值维护前缀和即可 复杂度O((n+q)logn) 例题二:逆序对给定一个长度为$n$的序列，可以将其中任意个数字取相反数，求可以得到的最少逆序对数$n$ $\le$ $10^5$，$\left|A_i \right|$ $\le$ $10^9$ 思路对于每个数字，我们发现$A_i$的正负只影响绝对值比$A_i$小的数，所以求出每个数$A_i$前后分别有多少数绝对值大于$A_i$，取较少的那一个就行了 二、线段树例题一、序列操作给定长度为$n$的序列$A$，执行$q$次操作，支持区间加、区间赋值、查询区间和、查询区间最大值 思路线段树模板 例题二、环上连续最大和给定一个长度为$n$的环形序列$A$，其中$A_1$与$A_n$是相邻的。$q$次操作，每次操作更改$A_x=v$。对于每次修改输出最大连续和$n,q\le10^5,1\le x\le n,\left|A_i\right|,\left|v\right|\le10^9$ 思路线段树维护一下最小前缀和，最小后缀和与最小连续和，考虑到题目中的序列为环形，最大环形序列可能是两段互不相交的前缀与后缀，用总和减去最小子序列就行了。 例题三、SDOI2016 游戏题面见P4069 思路树链剖分+李超线段树 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;bits/stdc++.h&gt;#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 2e5 + 5;const ll INF = 123456789123456789;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg ll num = 0; rg char ch; rg bool flag = false; while ((ch = getchar()) == ' ' || ch == '\n' || ch == '\r'); if (ch == EOF)return ch; if (ch == '-')flag = true; else num = ch ^ 48; while ((ch = getchar()) != ' '&amp;&amp;ch != '\n'&amp;&amp;ch != '\r'&amp;&amp;~ch) num = (num &lt;&lt; 1) + (num &lt;&lt; 3) + (ch ^ 48); if (flag)return -num; return num; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;ll pos[N], id, ssize[N], fa[N], p[N], w[N], b[N], h[N], nt[N], num, son[N], deep[N], belong[N], dist[N];inl void add(rg ll z, rg int y, rg int x)&#123; b[++num] = y, w[num] = z; nt[num] = p[x], p[x] = num; b[++num] = x, w[num] = z; nt[num] = p[y], p[y] = num;&#125;void dfs1(rg int x)&#123; ssize[x] = 1; for (rg int e = p[x]; e; e = nt[e]) &#123; rg int k = b[e]; if (k == fa[x])continue; fa[k] = x, deep[k] = deep[x] + 1; dist[k] = dist[x] + w[e]; dfs1(k); if (ssize[son[x]] &lt; ssize[k])son[x] = k; ssize[x] += ssize[k]; &#125;&#125;void dfs2(rg int x, rg int chain_number)&#123; belong[x] = chain_number; pos[x] = ++id; h[id] = x; if (son[x])dfs2(son[x], chain_number); for (rg int e = p[x]; e; e = nt[e]) &#123; rg int k = b[e]; if (k == fa[x] || k == son[x])continue; dfs2(k, k); &#125;&#125;struct Line &#123; ll k, b; Line() &#123; k = 0, b = INF; &#125; Line(rg ll k, rg ll b) :k(k), b(b) &#123;&#125;&#125;;struct Node &#123; int left, right; ll min, l, r; Line delta; Node() &#123; min = INF; delta.b = INF; &#125;&#125;tree[N &lt;&lt; 2];void build(rg int x, rg int l, rg int r)&#123; tree[x].left = l, tree[x].right = r; if (l == r) &#123; tree[x].l = tree[x].r = dist[h[l]]; return; &#125; rg int mid = l + r &gt;&gt; 1; build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r); tree[x].l = tree[x &lt;&lt; 1].l; tree[x].r = tree[x &lt;&lt; 1 | 1].r;&#125;inl ll f(rg ll x, rg ll k, rg ll b) &#123; return k * x + b; &#125;inl void apply(rg int x, rg ll k, rg ll b)&#123; rg ll nl = f(tree[x].l, k, b), nr = f(tree[x].r, k, b), l = f(tree[x].l, tree[x].delta.k, tree[x].delta.b), r = f(tree[x].r, tree[x].delta.k, tree[x].delta.b); if (nl &lt;= l &amp;&amp; nr &lt;= r) &#123; tree[x].delta = Line(k, b); tree[x].min = fast_IO::min(tree[x].min, fast_IO::min(nl, nr)); return; &#125; if (nl &gt; l&amp;&amp;nr &gt; r)return; rg ll tmp = (b - tree[x].delta.b) / (tree[x].delta.k - k); rg ll mid = tree[x &lt;&lt; 1].r; if (nl &lt;= l || tmp &lt;= mid)apply(x &lt;&lt; 1, k, b); if (nr &lt;= r || tmp &gt; mid)apply(x &lt;&lt; 1 | 1, k, b); tree[x].min = fast_IO::min(tree[x].min, fast_IO::min(tree[x &lt;&lt; 1].min, tree[x &lt;&lt; 1 | 1].min));&#125;void addline(rg int x, rg int l, rg int r, rg ll k, rg ll b)&#123; if (tree[x].left &gt;= l &amp;&amp; tree[x].right &lt;= r) &#123; apply(x, k, b); return; &#125; rg int mid = tree[x].left + tree[x].right &gt;&gt; 1; if (l &lt;= mid)addline(x &lt;&lt; 1, l, r, k, b); if (r &gt; mid)addline(x &lt;&lt; 1 | 1, l, r, k, b); tree[x].min = fast_IO::min(tree[x].min, fast_IO::min(tree[x &lt;&lt; 1].min, tree[x &lt;&lt; 1 | 1].min));&#125;inl void addLine(rg int x, rg int y, rg ll k, rg ll b)&#123; while (belong[x] != belong[y]) &#123; if (deep[belong[x]] &lt; deep[belong[y]])jh(x, y); addline(1, pos[belong[x]], pos[x], k, b); x = fa[belong[x]]; &#125; if (pos[x] &gt; pos[y])jh(x, y); addline(1, pos[x], pos[y], k, b);&#125;inl int LCA(rg int x, rg int y)&#123; while (belong[x] != belong[y]) &#123; if (deep[belong[x]] &lt; deep[belong[y]])jh(x, y); x = fa[belong[x]]; &#125; if (deep[x] &lt; deep[y])return x; return y;&#125;inl void tian()&#123; rg int s = fast_IO::read(), t = fast_IO::read(); rg ll k = fast_IO::read(), b = fast_IO::read(); rg int lca = LCA(s, t); addLine(s, lca, -k, k*dist[s] + b); addLine(lca, t, k, k*dist[s] - 2 * k*dist[lca] + b);&#125;ll querymin(rg int x, rg int l, rg int r)&#123; rg ll ans = INF, mid = tree[x].left + tree[x].right &gt;&gt; 1; if (l &lt;= tree[x].left&amp;&amp;r &gt;= tree[x].right)return tree[x].min; if (l &lt;= mid)ans = fast_IO::min(ans, querymin(x &lt;&lt; 1, l, r)); if (r &gt; mid)ans = fast_IO::min(ans, querymin(x &lt;&lt; 1 | 1, l, r)); l = fast_IO::max(l, tree[x].left), r = fast_IO::min(r, tree[x].right); ans = fast_IO::min(ans, f(dist[h[l]], tree[x].delta.k, tree[x].delta.b)); ans = fast_IO::min(ans, f(dist[h[r]], tree[x].delta.k, tree[x].delta.b)); return ans;&#125;inl ll queryMin(rg int x, rg int y)&#123; rg ll ans = INF; while (belong[x] != belong[y]) &#123; if (deep[belong[x]] &lt; deep[belong[y]])jh(x, y); ans = fast_IO::min(ans, querymin(1, pos[belong[x]], pos[x])); x = fa[belong[x]]; &#125; if (pos[x] &gt; pos[y])jh(x, y); return fast_IO::min(ans, querymin(1, pos[x], pos[y]));&#125;inl ll query()&#123; rg int s = fast_IO::read(), t = fast_IO::read(); return queryMin(s, t);&#125;int main(void)&#123; rg int n = fast_IO::read(), m = fast_IO::read(); for (rg int i = 1; i != n; ++i)add(fast_IO::read(), fast_IO::read(), fast_IO::read()); dfs1(1), dfs2(1, 1), build(1, 1, n); while (m--) switch (fast_IO::read()) &#123; case 1:tian(); break; case 2:printf("%lld\n", query()); break; &#125; return 0;&#125; 三、可并堆（左偏树）左偏树呈二叉树结构，除维护权值信息外，还需要维护子树内最近叶结点的距离$d_x$。 例题一、Dispatching题面见P1552。 思路考虑到如果某个忍者当管理员时不选$x$忍者，那么这个忍者的直接上级一定不会选$x$。使用左偏树维护以$x$为根子树内派遣忍者名单，它需要满足大根堆的性质，不断删除堆顶直到总和$\le m$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e5 + 5;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg ll num = 0; rg char ch; rg bool flag = false; while ((ch = getchar()) == ' ' || ch == '\n' || ch == '\r'); if (ch == EOF)return ch; if (ch == '-')flag = true; else num = ch ^ 48; while ((ch = getchar()) != ' '&amp;&amp;ch != '\n'&amp;&amp;ch != '\r'&amp;&amp;~ch) num = (num &lt;&lt; 1) + (num &lt;&lt; 3) + (ch ^ 48); if (flag)return -num; return num; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;int fa[N], n, lson[N], rson[N], d[N], root[N], ssize[N];ll c[N], m, l[N], sum[N], ans;int merge(rg int x, rg int y)&#123; if (!x || !y)return x | y; if (c[x] &lt; c[y])jh(x, y); rson[x] = merge(rson[x], y); if (d[lson[x]] &lt; d[rson[x]])jh(lson[x], rson[x]); d[x] = d[rson[x]] + 1; return x;&#125;int main(void)&#123; n = fast_IO::read(), m = fast_IO::read(); for (rg int i = 1; i &lt;= n; ++i) fa[i] = fast_IO::read(), sum[i] = c[i] = fast_IO::read(), l[i] = fast_IO::read(), root[i] = i, ssize[i] = 1, ans = fast_IO::max(ans, l[i]); for (rg int i = n; i != 1; --i) &#123; root[fa[i]] = merge(root[i], root[fa[i]]); sum[fa[i]] += sum[i]; ssize[fa[i]] += ssize[i]; while (sum[fa[i]] &gt; m) &#123; sum[fa[i]] -= c[root[fa[i]]]; root[fa[i]] = merge(lson[root[fa[i]]], rson[root[fa[i]]]); --ssize[fa[i]]; &#125; ans = fast_IO::max(ans, l[fa[i]] * ssize[fa[i]]); &#125; fast_IO::write(ans); return 0;&#125; 线段树的合并线段树要合并，必须要有相同的结构，均摊复杂度$O(log n)$。 四、平衡树Treap——Treep=Tree+HeapTreap通过单旋保持堆性质。树高期望$O(logn)$ 启发式合并合并两棵$Treap$的时候，只需要暴力遍历较小的 Treap 提取所有结点，然后依次插入到较大的$Treap$之中就好了。很多数据结构都可以用启发式合并 例题一、Peaks题面见P4197 思路将道路和询问混在一起排序，进行$Kruskal$算法的同时用$Treap $维护连通分量内所有山峰的高度。 SplaySplay借助双旋操作（zig_zag）。 例题二、序列终结者题面见P4146。 思路Splay维护翻转、子树最值、addv标记。 例题三、三维偏序思路线段树套平衡树 Day1 下午五、嵌套数据结构嵌套数据结构的思想是将普通的数据结构维护的信息拓展成另一种数据结构（可能与第一维数据结构相同） 树套树常见的有树状数组套平衡树，线段树套权值线段树等。注意，第一维的数据结构应该尽量简单，可以节约空间减小时间复杂度。 例题一、Mokia题面见P4390。 思路树状数组套Splay 六、可持久化线段树（主席树）可持久化数据结构可持久化数据结构就是利用函数式编程的思想使其支持询问历史版本，同时充分利用它们之间的共同数据来减少时间和空间消耗 大致的思想就是只新建不修改，保存历史版本 例题一、静态区间第k小题面见P3834。 思路主席树模板题 七、动态树（Link-Cut-Tree）不是很懂。。。弄明白以后再补 总结数据结构是很重要的基础。讲课好快…今天的例题只敲出来两个，其他的还得以后慢慢做]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2019%2F04%2F11%2Fhello%2F</url>
    <content type="text"><![CDATA[我的第一篇blogLaTeX测试$\sum\limits_{i=1}^{n}a_b^c$ 理综答题卡模板 答题卡物理选择题 题号 14 15 16 17 18 19 20 21 答案 非选择题22.23.24.25.33.化学选择题 题号 7 8 9 10 11 12 13 答案 非选择题26.27.28.36.生物选择题 题号 1 2 3 4 5 6 答案 非选择题29.30.31.32.37.数学答题卡模板选择题 题号 1 2 3 4 5 6 7 8 9 10 11 12 答案 填空题13.14.15.16. 解答题17.18.19.20.21.22.]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
