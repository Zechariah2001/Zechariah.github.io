<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构（二）]]></title>
    <url>%2F2020%2F10%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[树状数组树状数组用于维护前缀和，支持单点修改。树状数组的原理并不复杂：对于1 &lt;= i &lt; j &lt;= n，经过若干次i+=lowbit(i),j-=lowbit(j)，所得的i’和j’中必然会有唯一一对相等，所以我们只需要在修改时不断将a[i]加到c[i’]上，查询时将所有的c[i’]加起来就行了。下面简略地说明一下，为什么这样做是对的：首先，lowbit(x)指的是x在二进制下最低位的1，比如lowbit(3)=1,lowbit(4)=4,lowbit(6)=2。那么为什么一定会有i’和j’相等呢？当j的二进制位大于i时，设i二进制有k位，显然i’中会包含所有k’&gt;k,2^k’，也就是说，只要j将除最高位外所有的位都减成0，就会与某个i’相等。当j的二进制位等于i时，从高位往低位看，必然会有某一位k使得比k位以上i和j都是1，在第k位i是0而j是1，此时又要分两种情况： k位以下i全是0，那么只要j把k位一下全减掉，j’就与i相等 k位以下i有1，那么i’必然会有k位为1，k位以下全为0的情况，此时i’与j’相等 如此，就说明i’与j’必然会相等(注意:i’包含i,j’包含j)，且不难看出，按上述策略找出的i’和j’是唯一的一对。再来张树状数组的大致图像，帮助理解c[i]。 12345678910111213141516171819#define lowbit(x) (x &amp; -x)//为什么x &amp; -x就是x的最低位1呢？因为-x实际上是(~x) + 1，会使得x的最低位1为1，而比x高的位与x都相反void update(int x, int data) &#123; //将x位置加上data while (x &lt;= len) &#123; //len为区间长度 c[x] += data;//前面解释过c[x]的作用 x += lowbit(x); &#125;&#125;int query(int x) &#123; //查询x的前缀和 int ans = 0; while (x) &#123; ans += c[x]; x -= lowbit(x); &#125; return ans;&#125; 另外，对a的差分数组用树状数组可以实现a数组的区间修改和单点查询，只用update(l, delta),update(r+1, -delta)就行了。 线段树线段树是一种非常常用的数据结构，且变化极多，这里先说最基础的线段树。线段树，顾名思义，将区间分成一段一段，来达到区间操作的目的，那么如何分段呢？考虑将区间[l,r]分成两半[l,mid]、[mid+1,r]，这样相当于将区间对半分，那么很显然，对每个区间都这样分段，最终的段数为$O(n\log n)$。当我们进行区间操作时，从最大的区间开始，以此去找对应要操作的区间： [l,r]包含在当前区间的左区间内，就接着往左区间走 [l,r]包含在当前区间的右区间内，就接着往右区间走 [l,r]跨过中间的分界线，那么左边操作[l,mid]，右边操作[mid+1,r] 如此反复，直到找到的区间与当前操作的区间完全相同，就进行操作。大致图像如下 另外，如果我们的区间操作涉及对区间的修改，如加减、乘除、改值，我们可以在找到的区间上打上懒标记，这样我们不用每次往下遍历完整棵线段树，当然，在遍历过程中要注意标记的下传，如果有多个标记要注意多个标记之间的关系，如乘标记不仅改变区间上的值，还改变标记的值。 洛谷P3373 【模板】线段树 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;#define jh(x, y) x ^= y ^= x ^= y#define lowbit(x) (x &amp; -x)#define rg register#define inl inlineconst double pi = 3.141593;typedef long long ll;const int N = 1e5 + 5, INF = 0x3f3f3f3f, mod = 998244353;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r' &amp;&amp; ~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;ll p;struct Node &#123; int l, r; ll sum, add, mul = 1;&#125;tree[N &lt;&lt; 2];void pushup(int x) &#123; tree[x].sum = (tree[x &lt;&lt; 1].sum + tree[x &lt;&lt; 1 | 1].sum) % p; &#125;void build(int x, int l, int r) &#123;//建树 tree[x].l = l, tree[x].r = r; if (l == r) &#123; tree[x].sum = fast_IO::read() % p; return; &#125; int mid = l + r &gt;&gt; 1; build(x &lt;&lt; 1, l, mid); build(x &lt;&lt; 1 | 1, mid + 1, r); pushup(x);&#125;void pushdown(int x) &#123;//标记下传 if (tree[x].mul != 1) &#123; (tree[x &lt;&lt; 1].mul *= tree[x].mul) %= p; (tree[x &lt;&lt; 1 | 1].mul *= tree[x].mul) %= p; (tree[x &lt;&lt; 1].add *= tree[x].mul) %= p; (tree[x &lt;&lt; 1 | 1].add *= tree[x].mul) %= p; (tree[x &lt;&lt; 1].sum *= tree[x].mul) %= p; (tree[x &lt;&lt; 1 | 1].sum *= tree[x].mul) %= p; tree[x].mul = 1; &#125; if (tree[x].add) &#123; (tree[x &lt;&lt; 1].add += tree[x].add) %= p; (tree[x &lt;&lt; 1 | 1].add += tree[x].add) %= p; (tree[x &lt;&lt; 1].sum += (tree[x &lt;&lt; 1].r - tree[x &lt;&lt; 1].l + 1) * tree[x].add % p) %= p; (tree[x &lt;&lt; 1 | 1].sum += (tree[x &lt;&lt; 1 | 1].r - tree[x &lt;&lt; 1 | 1].l + 1) * tree[x].add % p) %= p; tree[x].add = 0; &#125;&#125;void update(int x, int l, int r, ll data) &#123;//添加加标记 if(tree[x].l == l &amp;&amp; tree[x].r == r) &#123; (tree[x].sum += (r - l + 1) * data % p) %= p; (tree[x].add += data) %= p; return; &#125; pushdown(x); int mid = tree[x].l + tree[x].r &gt;&gt; 1; if (r &lt;= mid)update(x &lt;&lt; 1, l, r, data); else if (l &gt; mid)update(x &lt;&lt; 1 | 1, l, r, data); else update(x &lt;&lt; 1, l, mid, data), update(x &lt;&lt; 1 | 1, mid + 1, r, data); pushup(x);&#125;void update2(int x, int l, int r, ll data) &#123;//添加乘标记 if (tree[x].l == l &amp;&amp; tree[x].r == r) &#123; (tree[x].mul *= data) %= p; (tree[x].sum *= data) %= p; (tree[x].add *= data) %= p;//别忘了加标记也要更新 return; &#125; pushdown(x); int mid = tree[x].l + tree[x].r &gt;&gt; 1; if (r &lt;= mid)update2(x &lt;&lt; 1, l, r, data); else if (l &gt; mid)update2(x &lt;&lt; 1 | 1, l, r, data); else update2(x &lt;&lt; 1, l, mid, data), update2(x &lt;&lt; 1 | 1, mid + 1, r, data); pushup(x);&#125;ll query(int x, int l, int r) &#123; if (tree[x].l == l &amp;&amp; tree[x].r == r)return tree[x].sum; pushdown(x); int mid = tree[x].l + tree[x].r &gt;&gt; 1; if (r &lt;= mid)return query(x &lt;&lt; 1, l, r); if (l &gt; mid)return query(x &lt;&lt; 1 | 1, l, r); return (query(x &lt;&lt; 1, l, mid) + query(x &lt;&lt; 1 | 1, mid + 1, r)) % p;&#125;int main() &#123; rg int n = fast_IO::read(), m = fast_IO::read(); p = fast_IO::read(); build(1, 1, n); while (m--) &#123; rg int opt = fast_IO::read(); if (opt == 1) &#123; rg int x = fast_IO::read(), y = fast_IO::read(); rg ll k = fast_IO::read(); update2(1, x, y, k); &#125; else if (opt == 2) &#123; rg int x = fast_IO::read(), y = fast_IO::read(); rg ll k = fast_IO::read(); update(1, x, y, k); &#125; else &#123; rg int x = fast_IO::read(), y = fast_IO::read(); fast_IO::write(query(1, x, y)); putchar('\n'); &#125; &#125; return 0;&#125; 主席树（可持久化线段树）咕咕咕 李超线段树咕咕咕 树链剖分树链剖分主要用于解决树上路径、子树相关问题。树链剖分的思想很简单：在树上划出一些链，使得每个节点都属于且仅属于一条链，记录链的顶部，那么只需要O(1)的时间就能处理整条链的信息，从而达到缩短时间的目的。如何划分这些链？我们采用轻重链剖分，也就是说，找到以节点x的子节点中子树大小最大的节点y（称为重儿子），将x和y划分到同一条链中。 这样的话，基本就可以保证我们划分出的链尽量长，从而减少的时间更多。树链剖分的代码实现比较麻烦，我们分步看。首先，来看看我们需要用到什么变量和数组。12345int sz[N],//子树的大小，用于求重儿子dep[N],//节点的深度bel[N],//节点所在链的顶部son[N],//节点的重儿子fa[N];//节点的父节点 我们需要求出每个点的重儿子以及深度，使用dfs。1234567891011121314//dfs1从根节点开始void dfs1(int x) &#123; sz[x] = 1;//本身大小是1 for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x])continue; fa[k] = x;//k父节点是x dep[k] = dep[x] + 1;//记录深度 dfs1(k); if (sz[k] &gt; sz[son[x]])son[x] = k; //找到sz最大的子树，令其为重儿子 sz[x] += sz[k];//所有子树的大小加本身就是x子树的大小 &#125;&#125; 到目前为止做的都是准备工作，接下来才是链的划分。123456789101112void dfs2(int x, int chain_number) &#123; bel[x] = chain_number;//chain_number存的就是当前链的顶部，也代表着这条链 if (son[x])//如果有子节点，将重儿子划分到同一条链中 dfs2(son[x], chain_number); for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x] || k == son[x])continue; //son[x]已经划分了，要跳过 dfs2(k, k); //由于我们是自顶向下dfs的，k与x又不属于同一条链，k所在的链顶部就是k本身 &#125;&#125; 至此，我们就完成了树链剖分，那么如何使用呢？比如，求LCA：123456789101112int LCA(int x, int y) &#123; //求x和y的LCA //x和y反复往上跳，直到跳到同一条链 while (bel[x] != bel[y]) &#123; if (dep[bel[x]] &gt; dep[bel[y]])swap(x, y); //我们希望x和y都尽量往上跳，这样最节省时间，于是我们就跳链顶部的dep较小的那个 x = fa[bel[x]];//从bel[x]链跳到另一条链 &#125; //最终x和y在同一条链上，dep小的那一个显然就是LCA if (dep[x] &lt; dep[y])return x; else return y;&#125; 那如果，要引入路径及子树内的修改、查询怎么办？我们当然希望同一条链上的东西可以一起操作，这样与x和y向上跳的步骤就是一致的，那么具体怎么办呢？考虑引入dfs序，在dfs2中，因为我们优先dfs了重儿子的分支，因此同一条链上的dfs序是连续的，同时，一棵子树内的dfs序显然也是连续的，因此我们可以在dfs序上建立线段树。12345678910111213141516171819void dfs2(int x, int chain_number) &#123; bel[x] = chain_number;//chain_number存的就是当前链的顶部，也代表着这条链 dfn[x] = ++tot;//x的dfs序 ct[x] = dfn[x];//x子树内最大的dfs序 if (son[x]) &#123;//如果有子节点，将重儿子划分到同一条链中 dfs2(son[x], chain_number); ct[x] = max(ct[x], ct[son[x]]); &#125; for (int e = p[x]; e; e = nt[e]) &#123; int k = b[e]; if (k == fa[x] || k == son[x])continue; //son[x]已经划分了，要跳过 dfs2(k, k); //由于我们是自顶向下dfs的，k与x又不属于同一条链，k所在的链顶部就是k本身 ct[x] = max(ct[x], ct[k]); &#125; //显然，从dfn[x]到ct[x]的dfs序对应的节点与x子树内的节点一一对应&#125;//其他操作都是与LCA类似的过程，对dfn[bel[x]]到dfn[x]进行操作，最后对dfn[x]到dfn[y] (dfn[x]&lt;=dfn[y])操作]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>树状数组</tag>
        <tag>树链剖分</tag>
        <tag>可持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构（一）]]></title>
    <url>%2F2020%2F10%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基本数据结构栈栈是一种遵循先进后出原则的数据结构，数据在同一端入栈和出栈。 手动实现如下：123456789int stk[100005], top;//stk用于存放栈内的数据，top为栈顶，入栈和出栈都是在栈顶进行操作void ins(int x) &#123; stk[++top] = x; //新加入一个元素x&#125;int del() &#123; return stk[top--]; //返回并删除一个元素， 出栈&#125; 是不是很简单呢？ C++的STL提供了stack给我们直接使用，它支持如下基本操作：123456stack&lt;dataType&gt;name;//创建一个元素类型为dataType的栈namename.top();//返回顶部元素的引用name.push(x);//将x压入栈中name.pop();//弹出栈顶元素name.size();//返回栈中的元素个数name.empty();//栈为空时返回true 单调栈在栈的基础上，我们规定元素出栈的顺序必须是单调不降或单调不增的，对栈内元素的顺序没有要求。对于单调不降的单调栈，入栈前把比要入栈的元素小的元素全部出栈。对于单调不增的单调栈，入栈前把比要入栈的元素大的元素全部出栈。12345678void ins(int x) &#123; //此处以单调不降的单调栈为例 while (top &amp;&amp; stk[top] &lt; x) &#123; fun(stk[top--]);//出栈的元素可能要进行一些操作 //top--出栈 &#125; stk[++top] = x;&#125; 队列队列是一种遵循先进先出原则的数据结构，数据在一段入队，在另一端出队。 手动实现如下123456789int q[100005], head = 1, tail;void ins(int x) &#123; q[++tail] = x; //从尾部入队&#125;int del() &#123; return q[head++]; //从头部出队&#125; C++的STL中同样提供了queue供我们使用，它支持如下基本操作：1234567queue&lt;dataType&gt;name;//创建一个元素类型为dataType的队列namename.front();//返回队列中第一个元素的引用name.back();//返回队列中最后一个元素的引用name.push(x);//x从队列尾部入队name.pop();//删除队列的尾部name.size();//返回队列中元素的个数name.empty();//队列为空时返回true 单调队列与单调栈不同，单调队列要求队内的元素要是单调不降或单调不增的，且队首队尾都可以进行出队操作，只有队尾可以进行入队操作。一般来说，单调队列会有一个限制的大小m，即最多只能有m个元素。单调队列主要用于维护不同段区间内的最值，每次元素要入队时，与单调栈类似地，要让一些元素出队。123456void ins(int x) &#123; //以单调不降的单调队列为例 while (head &lt;= tail &amp;&amp; q[tail] &lt;= x)--tail;//删除比x小的元素 q[++tail] = x;//x入队 while (tail - head &gt;= m)++head;&#125; 链表先鸽着 简单数据结构优先队列（二叉堆）首先，优先队列并不是用队列实现的，一般我们用二叉堆来实现优先队列。那么什么是优先队列？就是队列中的元素被赋予的优先级，当我们访问优先队列时优先访问优先级高的元素。二叉堆，其实就是一棵二叉树，它满足父节点的优先级一定大于子节点的性质，换句话说，在二叉堆中，以任意节点x为根的子树中，x的优先级是最高的，这样的话，只要构建一个二叉堆，它的根节点就是优先级最高的点。12345678910111213141516171819202122232425262728293031323334//这里我们用一种比较方便的方法表示节点的左右孩子//x * 2表示x的左孩子，x * 2 + 1表示x的右孩子，可以证明这种表示方法是不会重复的//这样的话x / 2就可以表示x的父节点//f[x]表示x的优先级void shift1(int now, int len) &#123; //删除了堆顶，将一个优先级小的元素放到堆顶后，通过该操作维护堆的结构 //从顶向下去更新 int father = now , child = father &lt;&lt; 1; while (child &lt;= len) &#123; if (child &lt; len &amp;&amp; f[pq[child]] &lt; f[pq[child + 1]])++child; if (f[pq[child]] &gt; f[pq[father]])swap(pq[child], pq[father]); father = child, child &lt;&lt;= 1; &#125;&#125;void shift2(int now) &#123; //加入一个元素后，从加入的元素起向上更新，维护堆的结构 int child = now, father = child &gt;&gt; 1; while (father) &#123; if (f[pq[farther]] &gt;= f[pq[child]])break;//此时说明已经满足了堆的性质 //因为加入元素前堆是成立的，只有加入的元素破坏了堆的结构 swap(pq[father], pq[child]); child = father, father &gt;&gt;= 1; &#125;&#125;void add(int x) &#123; pq[++tot] = x; shift2(tot);&#125;dataType del() &#123; dataType x = pq[1]; pq[1] = pq[tot--];//将优先级小的放到堆顶 shift1(1, tot); return x;&#125; 手动实现起来相当麻烦，当然，C++的STL提供了priority_queue供我们直接使用，它支持以下基本操作：123456priority&lt;dataType&gt;pq;pq.top();//访问堆顶元素pq.push(x);//将x入队pq.pop();//将堆顶出队pq.size();//返回优先队列的元素个数pq.empty();//优先队列为空返回true ST表ST表用于求静态区间最值，构建复杂度$O(n\log n)$，查询复杂度只有$O(1)$!那么ST表是怎么实现的呢？显然区间[L,R]的最值可以拆成[L,L+x]与[R-x+1,R]的最值取最值，只要L+x&gt;=R-x+1即可。那么我们考虑求对于区间内每个位置i，从i开始往后$2^k$个元素中的最值ST[i][k]，于是构建ST表的算法就出来了。123456//以求最大值为例//注意，这里ST[i][0]为位置i上本来的这个数for (int j = 1; j &lt;= log2(n) + 1; ++j) for (int i = 1; i + (1 &lt;&lt; j - 1) &lt;= n; ++i) ST[i][j] = max(ST[i][j - 1], ST[i + (1 &lt;&lt; j - 1)][j - 1]);//显然是两段的最值中取最值 查询也好说：1234int query(int l, int r) &#123; int k = log2(r - l + 1); return max(ST[l][k], ST[r - (1 &lt;&lt; k) + 1][k]);&#125; 并查集并查集用于维护集合的关系。普通的并查集操作非常简单，直接上代码。123456789//用fa[x]表示x所在的集合//fa[x]初始化为x本身int findf(int x) &#123; if (x == fa[x])return x;//fa[x] == x说明当前的x已经表示了一个最大的集合 return fa[x] = findf(fa[x]);//如果fa[x] != x说明当前的集合被包含在另一个集合里&#125;//如此就能找到x所在的集合fa[findf(x)] = findf(y);//将x所在的集合合并到y所在的集合 不难看出，findf最多递归小常数次，因此并查集的复杂度是非常小的。]]></content>
      <categories>
        <category>小结</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>单调栈</tag>
        <tag>单调队列</tag>
        <tag>链表</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 1166D Cute Sequences]]></title>
    <url>%2F2019%2F05%2F18%2FCodeForces-1166D-Cute-Sequences%2F</url>
    <content type="text"><![CDATA[写篇题解祭一下因为脑子短路而逝去的几个小时 Description给定一个正整数$m$，定义一个正整数序列$x_1,x_2,x_3,…,x_n$，满足对于$2\le i\le n$有$x_i=x_{i-1}+x_{i-2}+…+x_1+r_i$，其中$1\le r_i\le m$现在给出$q$个询问，每个询问给出$a,b,m$，强制要求$x_1=a$，$x_n=b$，要求构造出一个长度不超过$50$的$x$序列 Input第一行一个正整数$q(1\le q\le 10^3)$表示询问数接下来$q$行，每行三个正整数$a,b,m(1\le a,b,m\le 10^{14},a\le b)$，意义见题面 Output没有合法序列输出$-1$有合法序列则先输出序列长度$k(k\le 50)$，然后$k$个数$x_1,x_2,…,x_k(1\le x_i\le 10^{14})$，其中$x_1=a,x_k=b$ Sample Input12325 26 23 9 1 Sample Output124 5 6 13 26-1 Solution又被sb题整弱智了.jpg很容易推出$b=2^{k-2}\cdot a+2^{k-3}\cdot r_2+…+2^{k-i-1}\cdot r_i+…+r_{k-1}+r_k$首先特殊情况是$a=b$，这时候直接输出$1\;a$考虑到$k$很小，先枚举长度$k$这时候$a$是确定的，因此可以先把$a$的部分减掉，同时把每个$r_i$都减$1$，这样来保证求出的$r_i$都是$\ge0$的，那么此时$0\le r_i\le m-1$定义$cha=n-2^{k-2}\cdot a-2^{k-2}$从$r_2$到$r_{k-1}$贪心考虑，系数大的尽量大，同时要注意不能超过$m-1$这样构造出来，最后剩余的$r_k=cha$如果在$m$以内，就是合法的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x &amp; -x)#define jh(x, y) x ^= y ^= x ^= y#define loc(x, y) (x - 1) * m + y#define rg register#define inl inline#define PI 3.141592654typedef long long ll;const int N = 6e2 + 5, INF = 0x3f3f3f3f, mod = 998244353;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r' &amp;&amp; ~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;ll r[N];int main(void) &#123; rg int q = fast_IO::read(); while (q--) &#123; rg ll a = fast_IO::read(), b = fast_IO::read(), m = fast_IO::read(); if (a == b) &#123; printf("1 %I64d\n", a); continue; &#125; rg bool can = false; r[1] = a; rg int len; for (rg int k = 2; k &lt;= 50 &amp;&amp; !can; ++k) &#123; rg ll cha = b - a * (1ll &lt;&lt; k - 2) - (1ll &lt;&lt; k - 2); if (cha &lt; 0)break; for (rg int i = 2; i &lt; k; ++i) r[i] = fast_IO::min(m - 1, cha / (1ll &lt;&lt; k - i - 1)), cha -= r[i] * (1ll &lt;&lt; k - i - 1); if (cha &lt; m) &#123; can = true, len = k, r[len] = cha; break; &#125; &#125; if (!can)puts("-1"); else &#123; rg ll sum = a; for (rg int i = 2; i &lt;= len; ++i)++r[i], r[i] += sum, sum += r[i]; fast_IO::write(len); for (rg int i = 1; i &lt;= len; ++i)putchar(' '), fast_IO::write(r[i]); putchar('\n'); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>思路</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ5480:路径的条数]]></title>
    <url>%2F2019%2F04%2F13%2FBZOJ5480-%E8%B7%AF%E5%BE%84%E7%9A%84%E6%9D%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Description给一棵$n$个点的有标号无根树，你需要找到满足条件的路径$u−v$的条数。我们称路径$u-v$满足条件当且仅当$u\not=v$且路径$u-v$上不存在点对$(a,b)$,$a,b$满足$gcd(a,b)=a$。注意：路径$u−v$和$v−u$是同一条路径。 Input第一行一个整数$n\le10^5$接下来$n−1$行，每行两个用空格隔开的整数$a,b$，表示边$(a,b)$ Output一行一个整数，代表要求的答案。 Sample Input43 13 23 4 Sample Output2//只有路径$2 − 3$和$3 − 4$满足条件 Solution这个题的转换很有意思我们考虑用总路径数-不合法的路径数来得到合法的路径数那么现在问题就在于，如何求不合法的路径数首先根据题意，枚举起点$u$，可以通过枚举$u$的倍数来得到一些不合法的路径，我们可以称之为“限制”，很容易得出：每一个不合法的路径必定至少包含一个“限制”知道这个有什么用呢？重头戏来了：设$dfn[x]$为$x$点的dfs序，$cover[x]$为$x$子树中最大的dfs序考虑不合法路径$a-b$，假设$a-b$包含路径$u-v$且$dfn[u]&lt;dfn[v]$，$dfn[a]&lt;dfn[b]$分两种情况讨论： $u$是$v$的一个祖先 $u$不是$v$的祖先 对于第一种情况这时候$a,b$和$u,v$有怎样的关系呢？我们来看下面这张图 这时我们发现，$a$可以是$g$子树外的任意一点，$b$可以是$v$子树内的任意一点，他们对应的dfs序关系为$dfn[a]$ $&lt;$ $dfn[g]\;\;and\;\;dfn[v]\le dfn[b] \le cover[v]$当然你可能会问：那如果我们先遍历图中$g$的那棵子树，上面这个关系就不成立了！（注意我们的前提条件，$a$的dfs序小于$b$）没错，所以我们还要讨论把上图中把$a,b$交换的情况，此时关系为$dfn[v]\le dfn[a] \le cover[v]\;\;and\;\;dfn[b] &gt; cover[g]$ 对于第二种情况这种情况相对较简单，还是先上图此时$a$是$u$子树中的任意一点，$b$是$v$子树中的任意一点所以对应的关系就是$dfn[u]\le dfn[a] \le cover[u]\;\;and\;\;dfn[v]\le dfn[b]\le cover[v]$ 说了这么多，这有什么用啊？ 考虑这样一个坐标系这个坐标系的横轴是$dfn[a]$，纵轴是$dfn[b]$再看看上面我们列出的条件，$dfn[a]$对应一个横轴上的区间，$dfn[b]$对应一个纵轴上的区间这不是矩形嘛！大致乱画一下，其实一堆条件（关系）就成了下面这个东西这些矩形内的每一个整点$(dfn[a],dfn[b])$，都是满足我们要求的东西，也就是不合法而每一个dfs序对应唯一节点，这样我们计算这些矩形内的整点个数就能得到不合法的路径数如何计算？线段树维护扫描线即可，只不过把求面积改成求矩形内点的个数，如果具体不清楚可以直接看代码，代码还算是比较简明的最终统计答案，由于我们这样求出的路径是无向的，设求出的路径数为$ans$答案就是$\dfrac{n*(n-1)}{2}-ans$ 复杂度：枚举$u,v$是$O(n\ln n)$的，线段树还要再乘个$\log n$，所以总复杂度应该是$O(n\ln n\log n)$ 最后献上本人丑陋的代码，现在是2019年3月28日22:06:10，目前在BZOJ是最快的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/************************************************************** Problem: 5480 User: Zechariah Language: C++ Result: Accepted Time:13152 ms Memory:193400 kb****************************************************************/ #include &lt;bits/stdc++.h&gt;#define lowbit(x) (x &amp; -x)#define jh(x, y) x ^= y ^=x ^= y#define loc(x, y) (x - 1) * m + y#define rg register#define inl inline#define PI 3.141592654typedef long long ll;const int N = 8e5 + 5, mod = 998244353, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;int cover[N], dfn[N], nt[N], b[N], p[N], num, id, fa[N][18], deep[N], tot, n;struct Node &#123; int left, right, min; ll sum;&#125;tree[N &lt;&lt; 2];struct Line &#123; int l, r, v, y; Line(rg int l = 0, rg int r = 0, rg int y = 0, rg int v = 0) :l(l), r(r), y(y), v(v) &#123;&#125; bool operator &lt;(const rg Line &amp;s)const &#123; return y &lt; s.y; &#125;&#125;e[N &lt;&lt; 2];inl void add(rg int x, rg int y) &#123; b[++num] = y, nt[num] = p[x], p[x] = num; b[++num] = x, nt[num] = p[y], p[y] = num;&#125;inl bool is(rg int x, rg int y) &#123; return dfn[x] &lt;= dfn[y] &amp;&amp; cover[x] &gt;= cover[y]; &#125;void dfs(rg int x) &#123; dfn[x] = ++id; for (rg int e= p[x]; e; e = nt[e]) &#123; if (b[e] == fa[x][0])continue; fa[b[e]][0] = x; deep[b[e]] = deep[x] + 1; dfs(b[e]); &#125; cover[x] = id;&#125;void build(rg int x, rg int l, rg int r) &#123; tree[x].left = l, tree[x].right = r; if (l == r)return; rg int mid = l + r &gt;&gt; 1; build(x &lt;&lt; 1, l, mid); build(x &lt;&lt; 1 | 1, mid + 1, r);&#125;inl void pushup(rg int x) &#123; if (tree[x].min)tree[x].sum = tree[x].right - tree[x].left + 1; else tree[x].sum = tree[x &lt;&lt; 1].sum + tree[x &lt;&lt; 1 | 1].sum;&#125;void update(rg int x, rg int l, rg int r, rg ll data) &#123; if (tree[x].left == l &amp;&amp; tree[x].right == r) &#123; tree[x].min += data; pushup(x); return; &#125; rg int mid = tree[x].left + tree[x].right &gt;&gt; 1; if (r &lt;= mid)update(x &lt;&lt; 1, l, r, data); else if (l &gt; mid)update(x &lt;&lt; 1 | 1, l, r, data); else &#123; update(x &lt;&lt; 1, l, mid, data); update(x &lt;&lt; 1 | 1, mid + 1, r, data); &#125; pushup(x);&#125;inl ll query() &#123; sort(e + 1, e + tot + 1); rg ll ans = 0; for (rg int i = 1; i &lt; tot; ++i) &#123; update(1, e[i].l, e[i].r, e[i].v); ans += tree[1].sum * (e[i + 1].y - e[i].y); &#125; return ans;&#125;inl int getfa(rg int x, rg int d) &#123; for (rg int j = 17; ~j; --j) if (d &amp; (1 &lt;&lt; j)) x = fa[x][j]; return x;&#125;inl void addedge(rg int x1, rg int x2, rg int y1, rg int y2) &#123; if (1 &lt;= x1 &amp;&amp; x1 &lt;= x2 &amp;&amp; x2 &lt;= n &amp;&amp; 1 &lt;= y1 &amp;&amp; y1 &lt;= y2 &amp;&amp; y2 &lt;= n) e[++tot] = Line(x1, x2, y1, 1), e[++tot] = Line(x1, x2, y2 + 1, -1);&#125; int main(void) &#123; n = fast_IO::read(); for (rg int i = 1; i != n; ++i)add(fast_IO::read(), fast_IO::read()); dfs(1); build(1, 1, n); for (rg int j = 1; j != 18; ++j) for (rg int i = 1; i &lt;= n; ++i) fa[i][j] = fa[fa[i][j - 1]][j - 1]; for (rg int i = 1; i &lt;= n; ++i) &#123; for (rg int j = i &lt;&lt; 1; j &lt;= n; j += i) &#123; rg int x = i, y = j; if (dfn[x] &gt; dfn[y])jh(x, y); if (is(x, y)) &#123; rg int node = getfa(y, deep[y] - deep[x] - 1); addedge(1, dfn[node] - 1, dfn[y], cover[y]); addedge(dfn[y], cover[y], cover[node] + 1, n); &#125; else addedge(dfn[x], cover[x], dfn[y], cover[y]); &#125; &#125; fast_IO::write((ll)n * (n - 1) / 2 - query()); return 0;&#125;]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>思路</tag>
        <tag>扫描线</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day6]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day6%2F</url>
    <content type="text"><![CDATA[Day 6——字符串一、哈希（哈希）把信息量大的东西压缩成信息量小的表达。 例题一、给出两个排列$a,b$，长度分别为$n,m$，你需要计算有多少个$x$，使得$a_1+x,a_2+x,a_3+x,…,a_n+x$是$b$的子序列。$n\le m\le2\times 10^5$ 思路枚举$b$中与$a$匹配的最大值$x$，把$x-n+1$ 例题二、你可以通过交换字母来修改字符串。如果两个字符串经过这样的变换之后可以相等，则称它们相似。给出一个文本串$T$与一个模式串$P$，询问$T$中有哪些子串与$P$一模一样或相似。$|T|,|P|\le10^6$ 思路考虑如何判断两个字符串相似。记录$last_i$表示上一次出现$p_i$的位置，我们发现两个字符串的$last$数组相同，他们就是相似的。然后直接KMP比较（或者哈希）。 二、KMP求出$next$数组，$next_i$表示当第$i$个位置失配的时候，应该从后面的什么位置开始匹配。求最长公共前后缀，这样就可以求出$next$数组。 模板1234567891011121314151617181920212223242526272829char s[N], t[N];int nt[N];inl void getnext()&#123;//模式串与自己匹配求出next数组 rg int len = strlen(t), i = 0, j = -1; while (i &lt; len) &#123; if (j == -1 || t[i] == t[j])nt[++i] = ++j; else j = nt[j]; &#125;&#125;inl void kmp()&#123; getnext(); rg int lens = strlen(s),lent=strlen(t), i = 0, j = 0; while (i &lt; lens) &#123; if (j == -1 || s[i] == t[j]) &#123; ++i, ++j; if (j == lent) &#123; j = nt[j]; //此时[i-lent+1,i-1]的子串是与t串匹配的 &#125; &#125; else j = nt[j]; &#125;&#125; 例题一、给出一个长度为$n$的串$S$，判断$S$的每个前缀是不是循环串，如果是输出最大循环次数。循环串的定义：由一个相同的串重复至少两次拼成。$n\le10^6$ 思路如果一个串是循环串，那么这个串就是$m$个小串的拼接，他的$next$就是$m-1$个小串。由于$s_{1…next}$与$S_{n-next…next}$是相同的两串，那么只要$i\mod(i-next)=0$，那么该串是一个以$i-next$为最小循环节的串。 例题二、给出一个长度为$n$的串$S$，你需要选取$S$的一个前缀$T$，使得$T$重复若干次可以拼出$S$（拼合可以有部分重复，但是重复部分必须相同）。最小化$T$的长度$n\le10^6$ 思路根据$next$建出$fail$树，贪心即可。 三、AC自动机（Aho-Corasick automation）例题一、给出含有$n$个单词的词典，你需要计算对于所有长度为$m$的字符串，有多少个至少包含一个单词。字符集为大写字母。$n\le60,m\le100,$每个单词长度$\le100$ 思路建出AC自动机，将每个单词结尾设为不可通行，计算从根节点开始走$m$步的总方案数，用总字符串数$-$总方案数即可。 例题二、给出$n$个字符串和$m$个询问，每次询问$i,j,k,l$，求第$i$个串的$j$长前缀和第$k$个串的$l$长前缀的最长公共后缀。$\sum S_i\le10^6$ 思路建出AC自动机，求所求两个前缀在$fail$树上的LCA即可。 例题、三给定$n$个字符串$s_i$，问最多能从中选择多少个串，使得其中不存在一个串是另一个串的子串。$n\le750,\sum|s_i|\le10^7,s_i\in\left\{a,b\right\}$ 思路四、后缀数组（SA）模板1234567891011121314151617181920212223242526272829303132333435363738int rk[N], sa[N], b[N], m, n, tong[N], height[N];char s[N];inl void radix_sort()&#123; memset(tong, 0, sizeof(tong)); for (rg int i = 1; i &lt;= n; ++i)++tong[rk[b[i]]]; for (rg int i = 1; i &lt;= m; +i)tong[i] += tong[i - 1]; for (rg int i = n; i &gt;= 1; --i)sa[tong[rk[b[i]]]--] = b[i];&#125;inl void getsa()&#123; for (rg int i = 1; i &lt;= n; ++i)rk[i] = s[i] - 'a' + 1, b[i] = i; radix_sort(); for (rg int k = 1; k &lt;= n; k &lt;&lt;= 1) &#123; rg int tot = 0; for (rg int i = n - k + 1; i &lt;= n; ++i)b[+tot] = i; for (rg int i = 1; i &lt;= n; ++i)if (sa[i] &gt; k)b[++tot] = sa[i] - k; radix_sort(); memcpy(b, rk, sizeof(b)); rk[sa[tot = 1]] = 1; for (rg int i = 2; i &lt;= n; ++i) if (b[sa[i]] == b[sa[i - 1]] &amp;&amp; b[sa[i] + k] == b[sa[i - 1] + k])rk[sa[i]] = tot; else rk[sa[i]] = ++tot; if (tot == n)break; m = tot; &#125;&#125;inl void getheight()&#123; rg int k = 0; for (rg int i = 1; i &lt;= n; ++i)rk[sa[i]] = i; for (rg int i = 1; i &lt;= n; ++i) &#123; if (rk[i] == 1)continue; rg int j = sa[rk[i] - 1]; while (j + k &lt;= n &amp;&amp; i + k &lt;= n &amp;&amp; s[j + k] == s[i + k])++k; height[rk[i]] = k; &#125;&#125; 例题一、给出$n$个串，找出一个最长的子串，至少在$\dfrac{n}{2}$个串中出现过。$\sum S_i\le10^5$ 思路将所有字符串拼起来，求$SA$和$Height$，做滑动窗口，求RMQ。 结论一个字符串的不同子串个数为$\dfrac{n(n-1)}{2}\sum\limits_{i=1}^{n}Height_i$ 例题二、给出一个小写字符串$S$以及$m$个询问，每个询问给出两个正整数$x,y$（$x\le y\le$字符串$S$本质不同的子串个数），表示询问$s$的所有本质不同的子串中，字典序排名为$x$到$y$之间的所有字符串的哈希值总和（包括$x$和$y$）。$|S|,m\le10^5$ 思路考虑转化为对前缀的查询，避免对两个子串的相同前缀重复计算，我们只用对不相同的部分二分求 例题三、给出一个字符串，将其划分为不超过$k$个连续子串。设第$i$个子串为$s_i$，对于每个$s_i$，找到其中字典序最大的连续子串$c_i$。你需要找到一种划分，使得字典序最大的$c_i$字典序最小。$|S|\le10^6$ 思路二分字典序，每次从后往前考虑，使得每个子串字典序不超过二分的答案，统计字典序的方法：二分一个后缀，再在后缀上二分。 例题四、给定一个字符串$S$，有$m$个询问，每组询问形如$(a,b,c,d)$，询问$S_{a…b}$的所有子串中与$S_{c…d}$的最长公共前缀的最大值是多少。$|S|\le10^5m\le10^5$ 思路二分答案$x$，找到$SA$中与后缀$c$LCP大于$x$的部分，查询是否含有$[a,b]$中的元素，二维数点问题，主席树求解。 例题五、给出一个长度为$n$的数组$a_i=i$，把它进行$m$次操作，每次操作可以是以下两种： 把某一段提到开头 区间翻转 现在问后缀数组为$a$的字符串$S$有多少种可能。限制$S$为字符串中出现的都是正整数，且最大元素等于不同元素的个数。$n\le10^9,m\le10^5$ 思路考虑后缀数组的定义$suf_{a_i}&lt;suf_{a_{i+1}}$于是推出$S_{a_i}\le S_{a_{i+1}}$可以发现确定每一个$\le$为$&lt;$或$=$，就能唯一确定整个数组。取$&lt;$一定合法，取$=$要求$suf_{a_{i+1}}&lt;suf_{a_{i+1}+1}$ 五、后缀自动机（SAM）字符串$S$的后缀自动机是一个能接受$S$的所有子串的有限状态自动机。 Right集所有该字符串的右端点组成的集合称为该串的$Right$集，$Right$集不同的串即为本质不同的串子串的$Right$集只有包含与并列关系由于这样的性质，我们可以建出一棵树，这棵树称为$fail$树。 建立SAM$last$:已经建立好的$SAM$因为新后缀而创建的最后一个节点。]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day5]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day5%2F</url>
    <content type="text"><![CDATA[Day5 上午——动态规划大纲DP的类型序列DP数位DP概率DP树形DP状态压缩DPDP套DP DP的优化形式优化决策单调性优化斜率优化凸单调性DP优化 例题、[HAOI2011]problem a题面见P2519 思路将问题转化一下，一个人说的话如果为真说明从第$a_i+1$到第$n-b_i$个人的分数是一样的.如果我们把这样一个模型看成一条线段，那么在这$n$条线段中，相交且互不重合的线段一定不能同时为真话，所以问题就转化为选出尽可能多的不相交或完全重合的线段，且对于某条线段完全重合的个数要小于等于线段长。所以做法就很明显了，先求出说最多的说真话的人数，用总人数去剪。具体做法为：将每个人对应的线段放在一起进行双关键字排序，合并完全包含的线段，每一个线段上存一个权值$V_i$，现在就是要从$m$个线段中取出不相交的线段使得权值和最大，这就可以DP了。将所有线段按右端点排序，设$f_i$为到第$i$个线段的最优解。转移的时候先二分$[1,i)$之间满足$R_k&lt;L_i$的$f_k$最大的$k$，转移方程为$f_i=\max(f_{i-1},f_k+V_i)$最终答案为$n-f_m$ 一、数位DP数位DP常用来统计或查找一个区间满足条件的数，然后按数位顺序DP，一般需要仔细分情况讨论，常见处理如将区间拆为$[1, R], [1, L)$，记忆化，预处理等。 例题一、[SDOI2013]淘金题面见P3303 思路考虑对于一个$i$，有多少$j$满足$f_j=i$，记为$v_i$不难发现，$[1,n]$内的任何数各位相乘的结果最多只有4个质因子$2 ,3 ,5 ,7$，也就是说$i$可以被分解为$2^a\times 3^b\times5^c\times7^d$，这样的$i$在$n\le10^{12}$范围内其实是很少的这个个数设为$m$。所以我们可以设计状态$f_{i,j,0/1}$表示从低位到高位的第$i$位，各位的乘积为$j$（离散化后），最后一维表示是否小于等于$N$转移的时候枚举第$k$位，如果$k|j$那么$dp_{i,j,0/1}$可以从$dp_{i-1,\dfrac{j}{k},0/1}$转移过来最终我们是要求位置$(x,y)$的价值$v_x\times v_y$的前$K$大之和。考虑将$v$从小到大排序，用大根堆维护$m$个指针$p_i$，分别表示的是$v_1$到$v_m$，维护堆的关键字为$v_{p_i}\times v_i$，贪心选择$K$个求和得到答案。 二、概率和期望DP概率DP是一类求事件概率或期望的DP的总称。对于求概率问题，有时利用补集转化，或者将其转化为计数问题；而对于求期望则大多利用期望的线性性来解决问题。 贝叶斯公式条件概率$P(y|x)$联合概率$P(y,x)$$P(x,y)=P(x,y)=P(y|x)P(x)=P(x)P(y)$$P(x,y)=P(x|y)P(y)$贝叶斯公式：$P(y|x)=\dfrac{P(x|y)P(y)}{P(x)}$ 例题一、亚瑟王给你$N$张牌，每张牌有一个发动概率 $P_i$ 以及伤害 $D_i$，共有$R$回合，每回合会按编号从小到大依次考虑本次游戏中还未发动的卡牌，依次尝试发动，如果发动成功，进入下一回合，求期望伤害之和，共 $T$组数据。$T\le444,N\le220,R\le132$ 思路$dp_{i,j}$表示前$i$张牌发动了$j$张的概率求出每张牌发动的概率$sump_i=\sum\limits_{j=0}^rdp_{i-1,j}(1-(1-p_i)^{r-j})$$dp$可以DP求得$dp_{i,j}=\sum\limits_{j=0}^r(dp_{i-1,j}(1-p_i)^{r-j}+dp_{i-1,j-1}(1-(1-p_i)^{r-j+1}))$ 例题二、Museum题面见CF113D 思路解法一、设$ f_{i, j} $为第一个人在$ i$, 第二个人在$ j$,此时开始,之后在$ t $点相遇的概率.枚举终点, 做$ n $次高斯消元即可,不过直接这样做是$ O(n^7)$的.注意到每次高斯消元时,$ Ax = B $只有$ B $发生了变化.于是把$ B $改成一个矩阵就可以$ O(n^6)$了.最后通过$f_{i,j}=\sum\limits_{1\le i\le n}A_if_{i,i}$,令$f_{i,i}=1$就可以求出所有解 解法二、设$f(i,j)$为第一个人在$i$，第二个人在$j$这种情况的期望出现次数，因为终止状态只会出现0/1，于是期望就是概率了。 三、树形DP树形DP是指基于树的结构的动态规划，基础的有： 树的直径：DP记录子树内最长路 树的重心：DP记录子树大小 树上最大权独立集：DP记录子树的根是否选择 树形依赖背包：在dfs序上DP(即每次选择是否跳过子树)，或通过父节点的DP值传入孩子DP 虚树：在原树上只保留需要的点与他们的LCA的树称为虚树，建树方法为：将点按dfs序排序，一次将点加入，用一个栈维护树上的已加入的点和他们LCA的右链，每次加入一个点，与栈顶比较，便可以建出虚树 … 例题一、大工程题面见P4103 解答有着询问的和小于的限制的题是虚树的一个显著的特征。建出虚树, 然后直接在上面树形DP。设$ f_i $为以$ i $为根的子树内路径的代价和,$ size_i $为$ i $的子树中询问点的个数,$ max_i $为$i$子树内的到$ i $的最长路,$ min_i $为最短路，则：$f_i=f_{son_i}+size_i\times k-size_{son_i}$$max_i = \max\left\{max_{son_i} + 1\right\}$路径和答案是$ f_{root}$, 对于每个点,用它的最大与次大的儿子更新答案.如果他是被询问的点,则还可以用它每个儿子更新答案. 四、状态压缩DP基于状态压缩的DP是由于状态用单个简单的变量直接存储存在空间的浪费，而采用压缩的状态的动态规划，例如： 插头DP：维护当前已决策和未决策的一条$Z$字形的轮廓线的插头状态，用括号序列配对插头，每次只需分情况讨论即可，但是这类DP的显著特点就是情况繁多，使用时须细心 例题、给一个$N$个点$M$条边的无向图，每个点有点权$A_i$，保证任意两点之间距离不超过$10$。现在要你选取一些点，使得每个点要么自己被选，要么相邻的点被选。一个方案的代价定义为选取的点的点权和，求最小代价。$N\le20000,M\le25000,0\le A_i\le10000$ 解法考虑如何利用 “距离不超过10” 这个限制.不妨把生成树搞出来,那么这个树的深度$ \le 10$. 一个很显然的想法是DP时,对每个点设状态$ dp_{u, S}$, 表示以$ u $为根的子树,当$ u $到根这条路径上的点的选取情况是$S $时的最小代价.由于,一个点可能会对通过非树边覆盖祖先,对于$S$中每个未选取的点,我们可以再记录一下它是否已经被覆盖.对于一个点状态数是$3^{10}$的.用$3$进制来表示$S$. 规定一下$S$中某一位的值的意义: 0: 这个点被选取了 1: 这个点未被选取, 但已经被覆盖 2: 这个点未被选取, 且仍未被覆盖 在DFS序上做即可.转移并不困难,注意的是当DFS序中前一个点不是当前点的父亲时,要把$dp$值维护一下.使用滚动数组,空间复杂度$ O(N + M + 3^{10})$,时间复杂度$O(M + 3^{10}N)$.对每个连通块都要做一遍. 例题一、对于任意一个正整数$N\le10^5$，求出${1,2,…,N}$的满足”若$x$在该子集中，则$2x,3x$不能在该子集”的子集个数。答案对$10^9+1$取模。$N\le10^5$ 思路将题目转化为“一个网格图，相邻点不能选”的计数问题，枚举左上角就行了。 五、DP套DP某些DP问题的子判定问题不能简单的解决,而必须用另一个DP解决,此时就只能使用DP套DP的方法,即：外面的DP的状态是存的里层DP各个状态的值,利用里层的状态来判断外层的DP是否合法,类似的问题有LCS为定值的序列的方案数等等。 例题一、给你一个只由$ACGT$组成的字符串$S$，对于每个$0\le k\le |S|$，问有多少个只由$ACGT$组成的长度为$M$字符串$T$，使得$LCS(S,T)=k$.$|S|\le15,M\le10^3$ 思路DP套DP，算LCS的DP为$dp_{i,j}=max(dp_{i-1,j-1}+[T_i=S_i],dp_{i-1,j},dp_{i,j-1})$这题的$ |S| $很小,不妨对于每个$ i$, 将$ j $不同时的DP值都记录下来,计个数即可.但是直接记DP值状态数会爆内存,但是注意到相邻的DP值只会差$1$,所以我们可以用$ 2^{|S|} $的状态数将这些值记录下来. 六、DP的形式优化有时在做一个DP问题时将会遇到时间或者空间复杂度过高的问题,而在DP的形式上优化便是有效的优化技巧, 典型的有预处理, 分阶段DP等: 预处理: 我们可能发现, 在DP的过程中, 出现了重复的运算, 浪费了时间, 所以我们可以通过DP前预处理, 或者DP过程总处理出最值, 而达到为后面的DP提供便捷的功能与作用, 达到优化的目的 分阶段DP: 在某些DP中将DP拆为一个个有特点阶段也许比将整个DP放在一起更加节省时间与空间, 所以对于彼此相对无关的转移, 可以分开考虑 例题一、给定长度为$N,M$的数组$A,B$，求最长公共上升子序列。$N,M\le5000$ 思路状态设计：$dp_{i,j}$表示$A$考虑到$i$，$B$考虑到$j$且必须选$j$的长度当$A_i=B_j$时，有转移$dp_{i,j}=\max\left\{dp_{i-1,k}|k&lt;j,B_k&lt;B_j\right\}+1$由于$A_i=B_j$，这个限制事实上就是$B_k&lt;A_i$，对于同一个$i$限制是相同的。我们可以从小到大枚举$j$，维护$\max\left\{dp_{i-1,k}|k&lt;j,B_k&lt;A_i\right\}$，直接转移即可。 例题二、现在有$n$个活动，每个活动需要占用$[l_i,r_i)$的时间，现在有两个会场，两个会场不能同时有活动，但是一个会场可以同时举办多个活动。要求安排每个活动在哪个会场举行，或者不举行，使得举行活动较少的会场举行活动最多。同时，对$i\in[1,n] $求出如果强制活动$i$必须举行，那么所求答案是多少。$n\le200$ 思路第一问，预处理出$[l,r)$表示$[l,r)$包含多少段区间，设$f_{i,j}$表示考虑了$[0,i)$区间，第一个会场举办$j$个活动的前提下，第二个会场最多举办多少活动。第二问，处理出DP数组的前后缀，对于每个询问合并答案令$g_{i,j}$表示考虑了$[i,size)$这个区间时的DP数组，不难想到：处理出$max_{l,r}$表示$[l,r)$区间一定选时的答案，然后合并前后缀。考虑优化合并过程，我们发现前缀和后缀都具有单调性，双指针即可。最终复杂度$O(n^3)$ 七、决策单调性优化DP问题的转移往往需要大量的时间, 如果我们能发现一些性质, 找到一些规律来优化 DP 决策转移的过程, 那么在时间上我们便能得到很大的优化, 常见的有四边形不等式优化, 以及一些1D/1D动态规划的优化。 四边形不等式优化对于形如以下DP:$f_{i,j}=f_{i,k-1}+f_{k,j}+w_{i,j}$如果$w$满足四边形不等式： 任意$i\le i’\le j\le j’$，有$w_{i,j}+w_{i’,j’}\le w_{i’,j}+w_{i,j’}$ 任意$i’\le i\le j\le j’$，有$w_{i,j}\le w_{i’,j’}$ 那么也可证明：$f_{i,j}+f_{i’,j’}\le f_{i’,j}+f_{i,j’}$而如果得到了这样的式子, 则就可以证明$ f_{i, j} $的决策一定在$f_{i, j − 1} $与$ f_{i − 1, j} $的决策之间:$s_{i,j-1}\le s_{i,j}\le s_{i-1,j}$四边形不等式的证明：http://wenku.baidu.com/link?url=344UHCQdTP9z2dFTCCGB3eBYHnlBeF0IAYdFeLmA_p0QU9nGv3L-6AyISk4zUKcTMBDrokvx_i-5BHh7H5ZFfjS3hf2j9jHdPCgUXwQjqS 1D/1D动态规划方程的优化$f_i=\min\left\{f_j+w_{j,i}|j\le i\right\}$若$w$满足四边形不等式，则可证明$f_i$的决策也一定单调。 例题一、NOI2009 诗人小G题面见P1912 思路首先推出DP方程:$f_i=\min\left\{f_j+|sum_i-sum_j-l|^p\right\}$令$w_{i,j}=|sum_i-sum_j-l|^p$，可以证明（不会证）$w$满足四边形不等式。由上述结论，对于任意的$i\le j$，$f_i$的决策一定$\le f_j$的决策，于是我们用一个栈来维护DP的决策。 八、斜率优化斜率优化DP是当DP转移式形如$f_i = \min\left\{f_j + k_ix_j + c_i + b_j\right\}$将与$ j $无关的常数提出$ \min$，我们就是要求$\min\left\{k_ix_j + f_j + b_j\right\}$令$ y_j = f_j + b_j$，每次我们实际上是在所有过 $(x_j , y_j )$ 且斜率为$-k_i $的直线$y_j =-k_ix_j+B$中找到一个直线具有最小的$ B$，即纵截距最小。显然最优的$(x_j , y_j ) $一定在凸壳上。于是我们便可以使用维护凸壳来将时间复杂度变得更优。根据$ x_j $和$ k_i $的单调性，我们可以： $x_j $与$ k_i $同时单调: 单调队列/单调栈 (hdu 3507) $x_j $单调,$ k_i $不单调: 单调队列/单调栈+二分斜率 (bzoj 2726) $x_j $不单调: Splay维护凸壳 (bzoj 1492) 九、凸单调性DP优化例题一、IOI2016 aliens题面见uoj240 思路将主对角线一边的点翻到另一边，去除一些无用点，首先可以推出一个显然的DP方程 $dp_{i,j}=\max\limits_{k&lt;j}\left\{dp_{i-1,k}+(x_j-y_{k+1}+1)^2-\max(0,x_k-y_{k+1}+1)^2\right\} $其中$dp_{i,j}$表示用$i$个正方形覆盖$j$个点所需要的最小并面积。这个转移方程可以很容易斜率优化，时间复杂度就变成$O(nk)$当然这并不能满足题目要求。如果$dp_{k,n}$是一个关于$k$的凸函数，那么不妨二分$dp_{k-1,n}$和$dp_{k,n}$这两个状态之间的差值（用一个一次函数取切，得一个切点）。将DP方程改为$dp_i=\max\limits_j&lt;i\left\{dp_j+(x_i-y_{j+1}+1)^2-\max(0,x_j-y_{j+1}+1)^2\right\}+x$转移一次有$x$的代价，记录一下$dp_n$转移达到最优值所需要的最少转移次数，就可以二分了。 十、容斥DP例题一、给定$n$个数$a_1,a_2,…,a_n$，将这些数分成两组，使得两组中的元素$or$和相同，求方案数，答案对1e9+7取模。$n\le50,0\le a_i\le2^{20}$ 解法按位考虑, 如果所有的数在某一位上都为$ 0$, 显然可以不用考虑.对于其它的位, 如果要满足题目的要求, 则必须满足所有这一位为$ 1$的数不能全部在同一组里. 虽然这个条件不好计数, 但是它的反面是很好计数的!所以, 枚举至少有哪些二进制位不满足条件, 然后用并查集维护一下就行了. 例题二、给定一个$N$维超立方体，第$i$个维度的长度为$r_i$，同时给你一个$N$维超平面$x_1+x_2+…+x_n=S$。这个超平面把超立方体切成至多两部分，求圆点所在那一部分的面积。$N\le500,A_i\le500,S\le10^9$ 思路有点超纲。。。学了微积分再补 例题三、[ZJOI2016]小星星题面见P3349 思路首先考虑一个错误的树形DP. 设$ dp_{u, p} $表示考虑了以$ u $为根的这个子树, 并且根映射到原图的$ p $点. 这个显然可以$ O(n^3) $转移, 但是有什么问题呢?不同的点可能映射到同一个点. 于是考虑容斥.求出$ dp_S $表示映射的点集至多为$ S $时的答案, 然后就可以$O(2^nn^3) $做了. 容斥何时起作用 $=$和$\not=$ $\min$和$\max$ gcd和lcm “恰好”和”至少” … 容斥的理解给定一些条件，问全部满足的对象的个数答案$=$所有对象$-$至少不满足其中一个的$+$至少不满足其中两个的$-$至少不满足其中三个的…另一种理解：在所有物品中, 问在某个条件$C_0$下所有物品的贡献之和.构造一些相对容易计算贡献的条件$C_1,…,C_n$再对于每个条件构造容斥系数 $f_1,…,f_n$ 满足对于每个物品$\sum\limits_{i=1}^{n}s_{C_i}f_i=s_{C_0}$其中$s_{C_i}$表示这个物品在条件$C_i$下所产生的贡献.对于常见的计数问题, 物品的贡献只会是$0/1$, 表示这个物品是否满足此条件. 凑系数一个经典的错排问题求长度为$n$的排列$a_1,…,a_n$的个数，满足$a_i\not=i$错排数：排列的不动点，即$a_i=i$的位置. 例题四、小学奥数（雾）给定$m$个数$a_1,a_2,…,a_n$，统计$[1,n]$的整数中，满足$a_1,a_2,…,a_n$中有奇数个数整除它的个数。$n\le10^9,m\le15$ 思路枚举$m$个数的一个子集，算出$lcm$，容斥一下。对于每个数，如果它被$k$个数整除，则有$\sum\limits_{i=0}^{k}C^i_kf_i=k\mod 2$可以求出所有的$f_i$ 例题五、异或图题面见bzoj4671 思路容斥。首先枚举子集划分，强制连通性“至少”是这个划分，也就是说，不同子集的两个点之间一定没有边，相同子集的两个点则任意.对于一个有$m$个联通块的图，容斥系数需要满足$\sum\limits_{i=1}^{m}$ 例题六、[NOI2009]管道取珠题面见P1758 技巧：平方处理思路统计平方的和, 转化成统计有序对.即统计有多少对$(wayA, wayB)$使得$wayA, wayB$均能得到相同的结果. 例题七、给定$S, T, K,$求每次$+1, −1,$用不超过$K$次操作从$S$变成$T$的方案数.每一时刻都不能为负$S,T,K\le10^5$ 技巧：反射法在平面直角坐标系中画出图像($x $轴代表时间,$ y $轴代表当前的数值), 发现所有不合法的路径都可以沿$ y = −1 $反射到一条从$(-(S + 2), 0) $到$ (T, 0) $的路径.直接组合数计算即可. 当然直接减一下转化为不能穿过对角线也是一样的.]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day4]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day4%2F</url>
    <content type="text"><![CDATA[Day4 上午——数学一、BSGS给定质数$p$，给定$a$和$b$，$(a,p)=1$。求最小的非负整数$x$，使得$a^x\equiv b(mod\;p)$。 解法首先根据欧拉定理$a^{\phi(p)}\equiv1(mod\;p)$，当$a^x\equiv b(mod\;p)$有解，最小非负整数解一定在$[0,\phi(p))$中。令$m=\sqrt{\phi(p)}$，任意$x\in [0,\phi(p))$都可以分解成$im+j$的形式，其中$0\le i \le m,0 \le j &lt;m$。枚举$i$的值，$a^x\equiv b(mod\;p)\Leftrightarrow a^j\equiv a^{-im}b(mod\;p)$。将$a^0,a^1,a^2…$放到$hash$表中查询就可以了。复杂度：$O(\sqrt{\phi(p)})$另外，如果要解决$p$不为素数的情况，需要用到$exBSGS$ 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x)#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e2 + 5, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;ll mod;inl ll ksm(rg ll a, rg ll b)&#123; rg ll ans = 1; for (; b; b &gt;&gt;= 1, (a *= a) %= mod) if (b &amp; 1)(ans *= a) %= mod; return ans;&#125;inl ll BSGS(rg ll a, rg ll b)&#123; rg ll p = mod; a %= p, b %= p; map&lt;ll, ll&gt;mp; rg ll m = ceil(sqrt(p)), t = 1; for (rg int i = 0; i &lt; m; ++i) &#123; if (!mp.count(t)) mp[t] = i; (t *= a) %= p; &#125; rg ll k = ksm(t, p - 2), w = b; for (rg int i = 0; i &lt; m; ++i) &#123; if (mp.count(w))return i * m + mp[w]; (w *= k) %= p; &#125; return -1;&#125;int main(void)&#123; rg ll a, b; while (~scanf("%lld%lld%lld",&amp;mod, &amp;a, &amp;b)) &#123; rg ll ans = BSGS(a, b); if (~ans)fast_IO::write(ans), putchar('\n'); else puts("no solution"); &#125; return 0;&#125; exBSGS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#pragma GCC optimize("fast-math,unroll-loops")#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")#include &lt;bits/stdc++.h&gt;#include &lt;unordered_map&gt;#define lowbit(x) (x&amp;-x)#define jh(x, y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e2 + 5, mod = 998244353, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;unordered_map&lt;ll, ll&gt;mp;ll a, b, p;inl ll GCD(rg ll a, rg ll b) &#123; while (b ^= a ^= b ^= a %= b); return a; &#125;inl ll exBSGS(rg ll a, rg ll b, rg ll p)&#123; if (b == 1)return 0; rg ll gcd, add = 0, mul = 1; while ((gcd = GCD(a, p)) ^ 1) &#123; if (b%gcd)return -1; b /= gcd, p /= gcd, ++add; (mul *= a / gcd) %= p; if (mul == b)return add; &#125; rg ll m = sqrt(p) + 1, kt = 1; mp.clear(); for (rg int i = 0; i != m; ++i) &#123; mp[kt*b%p] = i; (kt *= a) %= p; &#125; (mul *= kt) %= p; for (rg int i = 1; i &lt;= m; ++i) &#123; if (mp.find(mul) != mp.end())return i * m - mp[mul] + add; (mul *= kt) %= p; &#125; return -1;&#125;int main(void)&#123; while (a = fast_IO::read(), p = fast_IO::read(), b = fast_IO::read()) &#123; rg ll ans = exBSGS(a, b, p); if (~ans)fast_IO::write(ans), putchar('\n'); else puts("No Solution"); &#125; return 0;&#125; 二、Miller-Rabin给定$n$，判定$n$是否为素数。 解法首先筛去偶数，我们只考虑奇数的情况。显然$\forall x\in[1,p-1],x^p\equiv x(mod\;p)$，但是有些合数也满足这个性质，所以不能直接用这个性质来判断一个数是不是素数。考虑$x^2\equiv 1(mod\;n)$的根，若$n$是奇素数，则只有$1$和$n-1$(即$-1$两根)，因为原式可以改写成$(x+1)(x-1)\equiv 0(mod\;n)$。设$n-1\equiv 2^r\times d$，其中$d$是奇数。$n$是合数当且仅当存在$0\le k&lt; r,a^{2^k\times d}\not\equiv1,-1(mod\;n)$，且$a^{2^{k+1}\times d}\equiv1(mod\;n)$。选取多个$a$进行二次探查，减小错误率。 模板（int64）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x)#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e2 + 5, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;ll num[11] = &#123; 0,2,3,5,7,11,13,17,19,23,29 &#125;;inl ll ksm(rg ll a, rg ll b, rg ll mod)&#123; rg ll ans = 1; for (; b; b &gt;&gt;= 1, (a *= a) %= mod)if (b &amp; 1)(ans *= a) %= mod; return ans;&#125;inl bool detective(rg ll x, rg ll n)&#123; rg int r = 0; rg ll d = n - 1; while (!(d &amp; 1))d &gt;&gt;= 1, ++r; for (rg ll a = ksm(x, d, n), b; r; --r) &#123; b = a * a%n; if (b == 1)return a == 1 || a == n - 1; a = b; &#125; return false;&#125;inl int Miller_Rabin(rg ll x)&#123; for (rg int i = 1; i &lt;= 10; ++i) &#123; if (x == num[i])return 1; if (x%num[i] == 0)return 0; if (!detective(num[i], x))return 0; &#125; return 1;&#125;int main(void)&#123; rg int m = fast_IO::read(); while (m--)puts(Miller_Rabin(fast_IO::read()) ? "Yes" : "No"); return 0;&#125; 实践结论对于$int32$范围内的数，我们选取$2,7,61$探测即可。对于$int64$范围内的数，我们选取前十个素数探测即可。 三、Pollard-rho给定$n$，将$n$质因数分解。 解法如果用Miller-Rabin测试出来$n$是素数，直接停止算法。随机基底$a$和$c$，，生成序列$x_0=a,x^2_{i-1}+c(mod\;n)$，可以说序列${x_i}$是一个随机序列。如果出现$(x_i-x_{2i+1},n)\not=1$，停止算法。令$d=(x_i-x_{2i+1},n)$，若$d\not=n$，那么$d$就是$n$的一个非平凡因子，$n$可以被分为$\dfrac{n}{d}$和$d$相乘的结果，递归下去对$\dfrac{n}{d}$和$d$分别求解。复杂度$O(N^{\dfrac{1}{4}})$ 四、Linear-Shaker给定$n$，筛出$n$以内的所有素数。 解法见线性筛模板P3383。 五、Chinese Reminder Thereom$x\;mod\;n_1=x_1$$x\;mod\;n_2=x_2$$x\;mod\;n_3=x_3$…其中$n_1,n_2,…,n_k$两两互质，求$x$的一个合法解。 解法令$N=\prod\limits_{i=1}^{k}n_i$，$m_i=\dfrac{N}{n_i}$，$t_i=m_i^{-1}(mod\;n)$。$x=\sum\limits_i x_im_it_i(mod\;n)$我们容易发现，当$j=i$时，$m_it_i\equiv1(mod\;n_j)$，当$j\not=i$时，$m_it_i\equiv0(mod\;n_j)$，因此$x$一定是方程组的一组解。 模板（UVA756）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x)#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e2 + 5, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;ll mod[3]&#123; 23,28,33 &#125;, x[3];ll exgcd(rg ll a, rg ll b, rg ll &amp;x, rg ll &amp;y)&#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; rg ll yu = exgcd(b, a%b, x, y); rg ll tmp = x; x = y; y = tmp - a / b * y; return yu;&#125;inl ll CRT(rg int n)&#123; rg ll sum = 1, ans = 0, m; for (rg int i = 0; i != n; ++i)sum *= mod[i]; for (rg int i = 0; i != n; ++i) &#123; rg ll xx, y; m = sum / mod[i]; exgcd(m, mod[i], xx, y); ans += m * xx *x[i]; &#125; return ans % sum;&#125;int main(void)&#123; rg int d, step = 0; while (~(x[0] = fast_IO::read())) &#123; x[1] = fast_IO::read(), x[2] = fast_IO::read(); rg ll ans = CRT(3) - fast_IO::read(); ((ans %= 21252) += 21252) %= 21252; ans = (ans - 1 + 21252) % 21252 + 1; printf("Case %d: the next triple peak occurs in %d days.\n", ++step, ans); &#125; return 0;&#125; exCRT模板（POJ2891）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//#pragma GCC optimize("fast-math,unroll-loops")//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")#include &lt;bits/stdc++.h&gt;#define lowbit(x) (x&amp;-x)#define jh(x, y) x^=y^=x^=y#define rg register#define inl inlinetypedef __int128 ll;const int N = 1e5 + 5, mod = 1e9 + 7, INF = 0x3f3f3f3f;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg char c; rg ll x = 0; rg bool flag = false; while ((c = getchar()) == ' ' || c == '\n' || c == '\r'); if (c == EOF)return c; if (c == '-')flag = true; else x = c ^ 48; while ((c = getchar()) != ' ' &amp;&amp; c != '\n' &amp;&amp; c != '\r'&amp;&amp;~c) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); if (flag)return -x; return x; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg ll x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;ll mo[N], yu[N];ll exGCD(rg ll a, rg ll b, rg ll &amp;x, rg ll &amp;y)&#123; if (!b)return x = 1, y = 0, a; rg ll gcd = exGCD(b, a%b, x, y); rg ll tmpx = x; x = y; y = tmpx - a / b * y; return gcd;&#125;inl ll exCRT()&#123; rg int n = fast_IO::read(); for (rg int i = 1; i &lt;= n; ++i)mo[i] = fast_IO::read(), yu[i] = fast_IO::read(); rg ll ans = yu[1], lcm = mo[1]; for (rg int i = 2; i &lt;= n; ++i) &#123; rg ll x, y, c = (yu[i] - ans % mo[i] + mo[i]) % mo[i]; rg ll gcd = exGCD(lcm, mo[i], x, y), b = mo[i] / gcd; if (c%gcd)return -1; (x *= c / gcd) %= b; ans += lcm * x; lcm *= b; ans = (ans%lcm + lcm) % lcm; &#125; return (ans%lcm + lcm) % lcm;;&#125;int main(void)&#123; fast_IO::write(exCRT()); return 0;&#125; 六、Quadratic residue给定$y$和奇素数$p$，求$x$，使得$x^2\equiv y(mod\;p)$。 欧拉判别法若$y^{\dfrac{p-1}{2}}\equiv1(mod\;p)$，则$y$在模奇素数$p$下有二次剩余若$y^{\dfrac{p-1}{2}}\equiv-1(mod\;p)$，则$y$在模奇素数$p$下没有二次剩余勒让德符号$(\dfrac{a}{p})\equiv a^{\dfrac{p-1}{2}}$$1,…,p-1$中有$\dfrac{p-1}{2}$个数的勒让德符号为$1$，另外$\dfrac{p-1}{2}$个数的勒让德符号为$-1$。 解法不断随机$a$，使得$(\dfrac{a^2-y}{p})=-1$令$\omega=\sqrt{a^2-y},x=(a+\omega)^{\dfrac{(p+1)}{2}}$由于$x^2\equiv(a+\omega)^p\times(a+\omega)\equiv(a+\omega)\sum\limits_{j}C^j_p\omega^{p-j}$$\equiv(a^p+\omega^p)(a+\omega)\equiv(a-\omega)(a+\omega)\equiv a^2-\omega^2\equiv y(mod\;p)$所以最终答案就是$(a+\sqrt{a^2-y})^{\dfrac{p+1}{2}}$ 例题给定长度为$n$的整数$a$，判断$a$是否是完全平方数。$n\le1000$ 思路选多组素数进行判别，考虑$x^2\equiv a(mod\;p)$成立，随机一些素数$p$判别就行了。 七、Multiplicative function狄利克雷卷积$(fg)(n)=\sum_{d|n}f(d)g(n/d)$ 积性函数积性函数的性质： $\forall (a,b)=1,f(ab)=f(a)f(b)$ 积性函数的卷积仍然是积性函数 所以其实我们可以把$n$看成$n=p_1^{k_1}p_2^{k_2}…p_m^{k_m}$常见的积性函数： 普通函数:$I(n)=1,id(n)=n,e(n)=[n=1]$ 除数函数:$\sigma_k(n)=\sum\limits_{d|n}d^k$ 欧拉函数:$\phi(n)=n\times\dfrac{p_1-1}{p_1}\times…\times\dfrac{p_m-1}{p_m}$ 莫比乌斯函数:$\mu(n)=[k_1\le1][k_2\le1]…k_m\le1^m$ $\sum\limits_{d|n}\mu(d)=[n=1]\Rightarrow\mu\times1=e$$\sum\limits_{d|n}\phi(d)=n\Rightarrow\phi\times1=id$ $\phi$和$\mu$的前$n$项与前缀和前$n$项可以在做线性筛的过程中求出，前缀和用杜教筛或者min25等算法解决 Day4 下午八、Primitive root（原根）给定$n$，若$a$满足$(a,n)=1$且$1,a,a^2,a^3,…,a^{\phi(n)-1}$在$mod\;n$下都互不相同，则称$a$是$n$的一个原根。 原根的性质 $2,4,p^n,2p^n$有原根，$p$是奇素数。 若$n$有原根，则原根数量为$\phi(\phi(n))$个。 阶最小的非零$x$使得$a^x\equiv 1(mod\;p)$，记为$$ 有关阶的定理①若$p&gt;1$且$(a,p)=1$，又满足$a^n\equiv1(mod\;p)$，则$|n$②$|\phi(p)$ 求法将$\phi(p)$质因数分解，$\phi(p)=p_1^{w_1}p_2^{w_2}…p_k^{w_k}$枚举$g$，如果恒满足$g^{\dfrac{\phi(m)}{p_i}} \not =1$，其中$i=1,2,…,k$则$g$是$m$的一个原根 九、Combination（组合数）求法：杨辉三角预处理阶乘及逆元 十、Recurrence relation（递推关系）矩阵乘法：$C_{i,j}=\sum A_{i,k}\times B_{k,j}$。 例题给定一张$N$个点$M$条边的有向图，$Q$次询问图中从每个点出发的长度为$K$的路径各有多少条。$N\le100,Q\le10,K\le100$ 思路分块矩乘。 十一、Principle of inclusion-exclusion（容斥原理）容斥原理$F(A\bigcup B\bigcup C)=F(A)+F(B)+F(C)-F(A\bigcap B)-F(B\bigcap C)-F(A\bigcap C)+F(A\bigcap B\bigcap C)$ 十二、Binomial inversion(二项式反演)$f_n=\sum\limits_{i=0}^{n}(-1)^iC^i_ng_i\Leftrightarrow g_n=\sum\limits_{i=0}^{n}(-1)^iC^i_nf_i$$f_n=\sum\limits_{i=0}^{n}C^i_ng_i\Leftrightarrow g_n=\sum\limits_{i=0}^{n}(-1)^{n-i}C^i_nf_i$ 例题、集合计数$n$个元素有$2^n$种不同的子集，现从$2^n$个子集中选取若干子集，求有多少种方案，使得选出集合的交元素个数为$K$。$n,k\le 10^6$，对$10^9+7$取模 思路令$g_k$表示选出集合的集合交为$k$时的方案数，$f_k$表示选出集合的集合交至少为$k$时的方案数。$f_i=C^i_n(2^{2^{n-i}}-1)$$f_i=\sum\limits_{j=i}^{n}g_jC^i_j$ 推出$g_i=\sum\limits_{j=i}^{n}C^j_n(2^{2^{n-j}}-1)(-1)^{j-k}C^k_j$ 十三、Probability Thereom（概率论）期望：$E(x)=\sum\limits_{i=1}^{n}a_iP(x=a_i)$期望具有线性性 例题、求逆序对长度为$n$的序列，求逆序对的期望个数。令$a_{i,j}$表示$i,j$是否逆序，逆序则为1，否则为0。 例题、Clear the room给定一个$n\times m$的网格，$(i,j)$中有物品价值$w_{i,j}$。现取$K$次，每次取走一个矩形内所有物品，问$K$次操作后拿走物品价值和期望。$n,m\le500,K\le10^9$ 思路求出每一个点被选中的概率$p$，不难想到我们要想选中一个点$(x,y)$，必须要使得选中的矩形包含$(x,y)$，也就是$x_1\le x\le x_2,y_1\le y \le y_2$，那么推出结论：选中一点$(x,y)$的概率$p=\dfrac{x\times(n-x+1)\times y\times(m-y+1)}{n^2\times m^2}$，答案就等于$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}w_{i,j}p_{i,j}^k$ 十四、Gaussian（高斯消元）模板。]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day3]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day3%2F</url>
    <content type="text"><![CDATA[Day3上午——图论一、强联通分量强联通分量即是环极大强联通子图：将原图中任何点加入这个子图都不能构成强联通分量的强联通分量。极大不一定最大。强联通分量针对有向图。途中每个点都属于且仅属于一个极大强联通分量。强联通分量与点的关系具有传递性。求强联通分量可以使用Tarjan算法或者Kosaraju算法，我们主要使用Tarjan算法。 二、Tarjan算法考虑当前dfs到某个点now,其余点只有三种：①可以访问到的点②不能访问到的点③未访问的点dfs的过程中，如果从某一点出发可以回到这个点，那么一定会存在一个强联通分量，而这个强联通分量就在dfs的栈里，所以我们可以用一个栈记录一下经过的点，去找强联通分量。定义dfn[x]为搜索到x的时间，即编号，low[x]为从x出发可以走到的最小点。我们发现如果从某点出发搜完之后low[x]==dfn[x]，说明此时从x出发有一个强联通分量，此时我们把记录的栈弹出至遇到x就是一个强联通分量。 缩点缩点后，新图为一个DAG。 例题一、The Cow Prom题面见P2863。tarjan裸题。 例题二、受欢迎的牛题面见P2341。 思路首先缩点，发现如果某个点只有入度且只有这个点是只有入度的，那么这个点就是要求的点，否则不存在。 例题三、稳定婚姻题面见P1407。 思路夫妻男连女，情人女连男，跑一边tarjan，如果一对夫妻在同一个强联通分量中，这段婚姻就是不稳定的。 三、双联通分量割点和桥将点$x$删掉后，图中联通分量个数增加，称$x$为割点。将边$e$删掉后，图中联通分量个数增加，称$e$为桥。点双联通分量：两点间的所有路径不经过同一点的联通分量。边双联通分量：两点间的所有路径不经过同一边的联通分量。 割点求法类似于tarjan，如果x有一个出点low值$\ge dfn[x]$说明x是割点，注意要特殊处理第一个搜索的点。 边双联通分量求法和求强联通分量几乎一样，判断一下不走回头路就行了，不能走走过的边。扔个模板1234567891011121314151617181920212223242526272829303132333435363738394041424344...int nt[N], b[N], p[N], num = 1, st[N], dfn[N], low[N], ltk[N], id;bool flag[N];inl void add(rg int x, rg int y)&#123; b[++num] = y, nt[num] = p[x], p[x] = num; b[++num] = x, nt[num] = p[y], p[y] = num;&#125;void tarjan(rg int x)&#123; dfn[x] = low[x] = ++id; st[++*st] = x; for (rg int e = p[x]; e; e = nt[e]) if (!flag[e]) &#123; rg int k = b[e]; if (!dfn[k]) &#123; flag[e] = flag[e ^ 1] = true; tarjan(k); flag[e] = flag[e ^ 1] = false; low[x] = fast_IO::min(low[x], low[k]); &#125; else low[x] = fast_IO::min(low[x], dfn[k]); &#125; if (dfn[x] == low[x]) &#123; ++*ltk; while (st[*st + 1] != x) &#123; ltk[st[*st]] = *ltk; --*st; &#125; &#125;&#125;int main(void)&#123; ... for (rg int i = 1; i &lt;= m; ++i)add(fast_IO::read(), fast_IO::read()); for (rg int i = 1; i &lt;= n; ++i)if (!dfn[i])*ltk = 0, tarjan(i); ... return 0;&#125; 例题一、冗余路径Redundant Paths题面见P2860。 思路先求边双联通分量，缩点后成了一颗树，这棵树的度数为1的点的数量sum，答案就是⌈$sum/2$⌉，答案的正确性显然，因为每个度数为1的节点肯定需要连边出去，贪心的想就很容易证明了。 点双联通分量求法在求割点的过程中就能求出，稍微改动一下就行，我们考虑将经过的边入栈而不是经过的点，在找到割点的时候，把边一个个从栈中取出直到遇到边$(u,v)$，取出的边与其关联的点构成一个点双联通分量。由于点双联通分量求法不太一样，扔个模板吧。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct Node &#123; int u, v;&#125;e[N], st[N], tp;int nt[N], p[N], top, dfn[N], low[N], id, gedian[N], bcc_cnt, belong[N];vector&lt;int&gt;bcc[N];void tarjan(rg int x, rg int fa)&#123; rg int child = 0; dfn[x] = low[x] = ++id; for (rg int k = p[x]; k; k = nt[k]) &#123; rg int to = e[k].v; st[++top] = e[k]; if (!dfn[to]) &#123; ++child; tarjan(to, x); low[x] = fast_IO::min(low[x], low[to]); if (low[to] &gt;= dfn[x]) &#123; gedian[x] = true; bcc[++bcc_cnt].clear(); do &#123; tp = st[top--]; if (belong[tp.u] != bcc_cnt) &#123; bcc[bcc_cnt].push_back(tp.u); belong[tp.u] = bcc_cnt; &#125; if (belong[tp.v] != bcc_cnt) &#123; bcc[bcc_cnt].push_back(tp.v); belong[tp.v] = bcc_cnt; &#125; &#125; while (tp.u != e[k].u || tp.v != e[k].v); &#125; else if (e[k].v != fa)low[x] = fast_IO::min(low[x], dfn[to]); &#125; &#125; if (!fa) &#123; if (child &gt; 1)gedian[x] = true; else gedian[x] = false; &#125;&#125;...int main()&#123; ... for (rg int i = 1; i &lt;= n; ++i) if (!dfn[i])tarjan(i, 0); ... return 0;&#125; 四、二分图二分图的判定对二分图黑白染色，如果产生矛盾说明不是二分图。（二分图中无奇环）。 Hall定理设二分图中$G=$中$\left| V1 \right|=m\le\left| V2 \right|=n$,$G$中存在从$V1$到$V2$的完全匹配当且仅当$V1$中任意$k(k=1,2,…,m)$个顶点至少与$V2$中$k$个顶点是相邻的。 匈牙利算法贪心，过程比较简单，扔个模板12345678910111213141516171819202122232425262728vector&lt;int&gt;e[N];int mat[N];bool flag[N];bool dfs(rg int x)&#123; for (rg int i = 0; i != e[x].size(); ++i) &#123; rg int j = e[x][i]; if (flag[j])continue; flag[j] = false; if (!mat[j] || dfs(mat[j]))return mat[j] = x; &#125; return false;&#125;...int main()&#123; ... for (rg int i = 1; i &lt;= n; ++i) &#123; if (dfs(i))++ans; memset(flag, 0, sizeof(flag)); &#125; ... return 0;&#125; 几个定理二分图最小点覆盖==二分图最大匹配点覆盖：在图中选取一些点，保证每条边至少有一个点在选取点中，称这些点是一个点覆盖。二分图最大点独立集==总点数-二分图最大匹配独立集：在图中选取一些点，保证每个点不相邻，则称这些点是一个独立集。 例题一、Asteroids 小行星题面见POJ3041。 思路行列分开，对于小行星的坐标$(x,y)$，连边$(x,y)$，跑二分图匹配求最小点覆盖即是答案。 例题二、Muddy Fields 泥泞的牧场题面见POJ2226 思路和前面那道例题类似，贪心的考虑，每块板子肯定是延伸到最长最好，所以我们把一些板子分成两部分：$A$部分是所有横着的木板，$B$为所有竖着的木板，将横竖交叉的木板连边，构成一个二分图，这样选择一个点就代表选择一个板子，求最小点覆盖就是我们要求的答案。 五、2-SATSAT问题是给出一些条件（元素经过逻辑运算的结果，如and or xor），SAT问题已经被证明是一个NP完全问题。2-SAT问题中最多有两个条件。 求法对于每个变量$x$，建立两个点$x_t$和$x_f$，分别表示$x$取TRUE和$x$取FALSE。对于所有的“A取x则B取y”，连边$(A_x,B_y)$，该图中如果P能到达Q，表示“若P成立，则Q一定成立”所以如果从$a_f$出发能到达$a_t$或者$a_t$出发能到达$a_f$，则矛盾。这一步的检验我们考虑用tarjan求联通分量，$O(N)$解决。如果没有这种情况出现，则一定存在合法方案。现在我们考虑如何构造一组可行解我们构造这样一种方案：缩点之后按照“逆拓扑序”挑选一个未被染色的强联通分量将其染成黑色，然后把所有与这个强联通分量里的点矛盾的点所在的联通分量染成白色。最后所有染成黑色的强联通分量里的点就是选择的方案。 例题一、NOI2017 游戏题面见P3825 思路对于$a,b,c$，就直接裸的2-SAT。对于$x$，如果直接枚举选$A,B,C$中的哪个，复杂度要乘上$3^d$，但是如果我们考虑枚举x不适合哪辆车，复杂度就乘上$2^d$。 Day3下午一、网络流除了源点和汇点，所有点的输入与输出平衡。 求法Ford-Fulkerson算法DinicSAP等等。。。个人觉得用dinic就够了…… 二、Dinic反向边：用于反悔，保证所有操作可撤销。 优化当前弧优化 三、最小割最小割定理最小割==最大流 例题一、吃饭Dining题面见P2891。 思路把牛拆成两个点，这两个点之间连容量为1的边，原点连食物，食物连牛，牛连饮料，饮料连汇点，跑最大流。 经典最小割模型——最大闭合子图图中的点有点权，点权可正可负，在图中选一些点，如果有边$(u,v)$则选u必选v。 解法建图：对于权值为正$x$的点，从源点连一条容量为$x$的边，权值为负$y$的点，向汇点连一条容量为$y$的边，原图边容量为正无穷（较大值）。 例题二、NOI2006 最大获利题面见P4174。 思路将题目中的边都看成点边对应的点依赖于原图中的点将边转化为点，则该图转化为一个二分图求这个二分图的最大闭合子图就行了。 经典最小割模型——二分图最小点权覆盖给出一个二分图，每个点有非负点权选出一些点构成一个覆盖，求最小点权和 解法源点向左边的点连容量为点权的边，右边的点向汇点连容量为点权的边，求最小割即可。 例题三、游戏一张图，删除每个点的入边有费用$w_i+$，删除每个点的出边有费用$w_i-$，求删除所有边需要的最小费用。 思路将所有入边和出边看成点，同一条边之间连容量无穷大的边，构成一个二分图，求这个二分图的最小点权覆盖就行了。 经典最小割模型——二分图最大点权覆盖给出一个二分图，每个点有非负点权选出一些点构成一个覆盖，求最大点权和 解法点权和减去最大流。 例题四、方格取数问题题面见P2774 思路黑白染色成一个二分图，跑最小割，用全局和-最小割即可。 四、费用流图中的边不仅有容量，还有费用。最小费用最大流：流量最大的情况下费用最小最小费用流：跑最短路，如果途中发现跑某条路径会使费用变大，就停止，最大费用流同理。 例题一、晨跑题面见P2153 思路拆点限流，连边直接跑费用流出解。 经典费用流模型——连续$M$个元素最多选$K$个给定$n$个元素，每个元素有权值$a_i$（可正可负），要求从中选出一些，满足其中任意相邻$M$个元素中只有最多$K$个元素被选出。 解法把题目转换为选$K$次，每次要求选出的点距离大于$M$，建图的时候从每个点$i$向$i+M$连边，容量为1，费用为$a_i$，相邻点之间连边，费用为0容量为$INF$，源点向第一个点连边，容量为$K$费用为0，最后一个点向汇点连边，容量为$INF$费用为0，跑费用流即可。 例题二、数字配对题面见P4068。 思路设$cnt_i$表示第i个数字质因数分解后各质因数的指数和。按照cnt的奇偶性，将这些数字分为两个集合。从源点向所有$cnt_i$为奇数的点连容量为$b_i$，费用为0的边。从所有$cnt_i$为偶数的点向汇点连容量为$b_i$，费用为0的边。对于一对$a_i$和$a_j$，如果$a_i$和$a_j$能匹配且$cnt_i$为奇数，连边，容量为$INF$，费用为$c_i\times c_j$。考虑贪心，跑最大费用最大流，每次跑最长路，在价值总和不小于0的情况下尽量增加流量，如果找不到增广路或者增广下去会使费用小于0则说明找到了答案。 例题三、方格取数问题题面见P2045。 思路拆点，两点之间连两条边，第一条边费用是该点权值，流量是1，另一条边费用是0，流量是$INF$。从源点向左上角连费用为0，流量为$K$的边，右下角向汇点连边，费用为0，流量为$INF$，跑最大费用最大流。 例题四、修车题面见P2053。 思路一个工人拆成$n$个点，表示n个时间段的工人，将$n$辆车与这$m \times n$个点都连起来，容量为1，费用为工人的时间段$\times$输入的时间，源点到车费用为0，流量为1，工人到汇点费用为0，流量为1，跑最小费用最大流即可，最后答案用总时间除以车数。 例题五、费用流题面见P3305。 思路二分最大的容量，跑dinic。 例题六、小M的作物题面见P1361。 思路按题目建图，一个点拆成两个点 五、上下界网络流每条边除了流量上界，还有流量下界。 解法这里借用了这篇博客 感觉总结的非常好①无源汇有上下界可行流（循环流）模型:一个网络,求出一个流,使得每条边的流量必须$\ge L_i$且$\le H_i$,每个点必须满足总流入量$=$总流出量(流量守恒)(这个流的特点是循环往复,无始无终)。可行流算法的核心是将一个不满足流量守恒的初始流调整成满足流量守恒（所有点的流入量$=$流出量）的流。我们可以令每条边的流量为该边的下界得到一个初始流，然后建出这个流的残量网络（每条边的上界与下界之差）。考虑在残量网络上求出一个附加流，使得附加流与可行流合并之后达到流量守恒，即：1)如果某个点在所有边流量等于下界的初始流中满足流量守恒,那么这个点在附加流中也满足流量守恒,2)如果某个点在初始流中的流入量比流出量多$x$,那么这个点在附加流中的流出量比流入量多$x$.3)如果某个点在初始流中的流入量比流出量少$x$,那么这个点在附加流中的流出量比流入量少$x$.$x$可以通过枚举点$i$的所有连边求出，开一个数组$A[]$，统计$i$点的流入量-流出量大小，根据$A_i$的正负表示流入量与流出量的大小关系。我们在残量网络中加入一些点和边，首先是虚拟超级源$ss$和虚拟超级汇$tt$。如果$A_i&lt;0$，从$i$向$tt$连一条容量为$-A_i$的边，反之从$ss$向$i$连一条容量为$A_i$的边。最后在建出的图上跑最大流，如果$ss$和$tt$连接的边都是满流的说明存在可行流，每条边在可行流中的流量$=$容量下界$+$附加流中它的流量（即反向边的权值）。 ②有源汇有上下界可行流模型:现在的网络有一个源点$s$和汇点$t$,求出一个流使得源点的总流出量等于汇点的总流入量,其他的点满足流量守恒,而且每条边的流量满足上界和下界限制。从$t$向$s$连一条下界为0，上界为$INF$的边，改成无源汇上下界可行流，跑完之后拆掉这条边就得到有源汇上下界可行流。最终的流量为这条边的反向边流量。 ③有源汇有上下界最大流模型:现在的网络有一个源点$s$和汇点$t$,求出一个流使得源点的总流出量等于汇点的总流入量,其他的点满足流量守恒,而且每条边的流量满足上界和下界限制。在这些前提下要求总流量最大。先跑出可行流，再在残量网络上跑出$s-t$最大流，最终的最大流$=$可行流流量$+$新增广出的$s-t$流量。 ④有源汇有上下界最小流模型:现在的网络有一个源点$s$和汇点$t$,求出一个流使得源点的总流出量等于汇点的总流入量,其他的点满足流量守恒,而且每条边的流量满足上界和下界限制。在这些前提下要求总流量最小。还是先跑出可行流，然后再残量网络上跑出$t-s$最大流，最终的最小流$=$可行流-$t-s$的最大流。]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day2]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day2%2F</url>
    <content type="text"><![CDATA[Day2上午一、基本分治例题一、归并排序如题…基础排序之一。 二、树分治①点分治原则上要尽量减小递归层，而考虑删去当前某节点之后，剩余节点数量最多的联通块尽量少，此时递归层数一定是最小的。这个节点就是“重心”。重心可以$O(n)$DP求得 例题一、IOI2011 Race给定一颗$n$个点的带边权的树，求一条路径使得权值和为$K$且边数量最少。$1\le n \le10^5,K\le10^6$ 思路点分治，记录到根路径长为dist[i]的最小边数即可 ②边分治选择一条边删去，得到两颗不相交的子树，统计这条边的信息。选边方法与点分治的选点几乎一致。 一个优化我们发现菊花图可以轻松卡掉边分，于是我们考虑重构这颗树，使得度数最大的点度数最小，采用的策略是加虚点（个人喜欢左孩子右兄弟）关键是两点间路径经过的实边不能变。 例题二、bzoj2870题面见bzoj2870 思路采用边分治。考虑删去一条边以后这条边的两端$a,b$，考虑将a端子树和b端子树中的链按点权最小值排序，对a端来说，每条链选b端中点权最小值不小于这条链且最长的链，b端同理，如此就可以做出这道题。 ③链分治（树链剖分）略（太过于模板） 三、CDQ分治普通分治：将区间分成两部分递归求解后合并。CDQ分治：在普通分治基础上需要加上左半区间对右半区间对贡献得到答案 例题一、二维偏序（上一篇好像有一样的题） 思路首先进行双关键字排序根据CDQ分治，不断递归至区间长度为1关键在于计算贡献考虑到子区间贡已经求出，我们将两个区间按第二维进行排序，如果左区间的一个有序对$(u,v)$对右区间的一个有序对$(a,b)$产生贡献，那么就等价于$v&lt;b$，双指针扫一遍即可。又考虑到我们按b排序，显然用归并复杂度比较优秀。 四、整体二分整体二分需要满足五个性质：①询问的答案具有可二分性（单调性）②修改对询问是独立互不影响的。③不同的修改贡献可叠加，不用重复计算④贡献满足交换律、结合律，有可加性⑤题目允许离线实现起来就是将所有询问一起二分 例题一、Meteors题面见SP10264 二分答案，线段树模拟当前区间的修改 五、三分用于求解凸函数（单峰函数） 六、分块整块整体做，边角暴力做 七、莫队将询问离线排序，优化暴力过程。 八、树上莫队借助欧拉序（括号序）将树上问题转换成区间问题，其余与莫队大致相同。 九、块状链表略 Day2下午今天下午是考试，结果…T1文件名写错，T2感觉没问题莫名wa掉，T3空间开小——完美爆0（解决上述问题后拿到60分暴力分）然后发现T2逆序对求错。。。总之以后细心更重要。题目暂时就不贴了。。。打完再来发]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBXT Jinan Day1]]></title>
    <url>%2F2019%2F04%2F13%2FQBXT-Jinan-Day1%2F</url>
    <content type="text"><![CDATA[Day1 上午——高级数据结构一、树状数组基本功能1.单点修改，前缀信息查询2.区间修改可减信息，单点查询 对lowbit的理解保留x中最后一位1（由位运算实现）1#define lowbit(x) (x&amp;-x) 例题一:矩形数点给定$n$个点坐标($x_i$,$y_i$)，q次询问，每次询问给出一个矩形的右上角坐标和左下角坐标，求矩形内包含给定点的个数n, q $\leq$ $10^5$，0 $\leq$ $x_i$, $y_i$ $\leq$ $10^9$ 思路首先用容斥原理把矩形拆型四个二维偏序区域（形如$\sum$[$x_i$ $\leq$ $x$, $y_i$ $\leq$ $y$]）将数据离散化，排序，此时$x$自然满足偏序结构，用树状数组根据$y$值维护前缀和即可 复杂度O((n+q)logn) 例题二:逆序对给定一个长度为$n$的序列，可以将其中任意个数字取相反数，求可以得到的最少逆序对数$n$ $\le$ $10^5$，$\left|A_i \right|$ $\le$ $10^9$ 思路对于每个数字，我们发现$A_i$的正负只影响绝对值比$A_i$小的数，所以求出每个数$A_i$前后分别有多少数绝对值大于$A_i$，取较少的那一个就行了 二、线段树例题一、序列操作给定长度为$n$的序列$A$，执行$q$次操作，支持区间加、区间赋值、查询区间和、查询区间最大值 思路线段树模板 例题二、环上连续最大和给定一个长度为$n$的环形序列$A$，其中$A_1$与$A_n$是相邻的。$q$次操作，每次操作更改$A_x=v$。对于每次修改输出最大连续和$n,q\le10^5,1\le x\le n,\left|A_i\right|,\left|v\right|\le10^9$ 思路线段树维护一下最小前缀和，最小后缀和与最小连续和，考虑到题目中的序列为环形，最大环形序列可能是两段互不相交的前缀与后缀，用总和减去最小子序列就行了。 例题三、SDOI2016 游戏题面见P4069 思路树链剖分+李超线段树 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;bits/stdc++.h&gt;#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 2e5 + 5;const ll INF = 123456789123456789;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg ll num = 0; rg char ch; rg bool flag = false; while ((ch = getchar()) == ' ' || ch == '\n' || ch == '\r'); if (ch == EOF)return ch; if (ch == '-')flag = true; else num = ch ^ 48; while ((ch = getchar()) != ' '&amp;&amp;ch != '\n'&amp;&amp;ch != '\r'&amp;&amp;~ch) num = (num &lt;&lt; 1) + (num &lt;&lt; 3) + (ch ^ 48); if (flag)return -num; return num; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;ll pos[N], id, ssize[N], fa[N], p[N], w[N], b[N], h[N], nt[N], num, son[N], deep[N], belong[N], dist[N];inl void add(rg ll z, rg int y, rg int x)&#123; b[++num] = y, w[num] = z; nt[num] = p[x], p[x] = num; b[++num] = x, w[num] = z; nt[num] = p[y], p[y] = num;&#125;void dfs1(rg int x)&#123; ssize[x] = 1; for (rg int e = p[x]; e; e = nt[e]) &#123; rg int k = b[e]; if (k == fa[x])continue; fa[k] = x, deep[k] = deep[x] + 1; dist[k] = dist[x] + w[e]; dfs1(k); if (ssize[son[x]] &lt; ssize[k])son[x] = k; ssize[x] += ssize[k]; &#125;&#125;void dfs2(rg int x, rg int chain_number)&#123; belong[x] = chain_number; pos[x] = ++id; h[id] = x; if (son[x])dfs2(son[x], chain_number); for (rg int e = p[x]; e; e = nt[e]) &#123; rg int k = b[e]; if (k == fa[x] || k == son[x])continue; dfs2(k, k); &#125;&#125;struct Line &#123; ll k, b; Line() &#123; k = 0, b = INF; &#125; Line(rg ll k, rg ll b) :k(k), b(b) &#123;&#125;&#125;;struct Node &#123; int left, right; ll min, l, r; Line delta; Node() &#123; min = INF; delta.b = INF; &#125;&#125;tree[N &lt;&lt; 2];void build(rg int x, rg int l, rg int r)&#123; tree[x].left = l, tree[x].right = r; if (l == r) &#123; tree[x].l = tree[x].r = dist[h[l]]; return; &#125; rg int mid = l + r &gt;&gt; 1; build(x &lt;&lt; 1, l, mid), build(x &lt;&lt; 1 | 1, mid + 1, r); tree[x].l = tree[x &lt;&lt; 1].l; tree[x].r = tree[x &lt;&lt; 1 | 1].r;&#125;inl ll f(rg ll x, rg ll k, rg ll b) &#123; return k * x + b; &#125;inl void apply(rg int x, rg ll k, rg ll b)&#123; rg ll nl = f(tree[x].l, k, b), nr = f(tree[x].r, k, b), l = f(tree[x].l, tree[x].delta.k, tree[x].delta.b), r = f(tree[x].r, tree[x].delta.k, tree[x].delta.b); if (nl &lt;= l &amp;&amp; nr &lt;= r) &#123; tree[x].delta = Line(k, b); tree[x].min = fast_IO::min(tree[x].min, fast_IO::min(nl, nr)); return; &#125; if (nl &gt; l&amp;&amp;nr &gt; r)return; rg ll tmp = (b - tree[x].delta.b) / (tree[x].delta.k - k); rg ll mid = tree[x &lt;&lt; 1].r; if (nl &lt;= l || tmp &lt;= mid)apply(x &lt;&lt; 1, k, b); if (nr &lt;= r || tmp &gt; mid)apply(x &lt;&lt; 1 | 1, k, b); tree[x].min = fast_IO::min(tree[x].min, fast_IO::min(tree[x &lt;&lt; 1].min, tree[x &lt;&lt; 1 | 1].min));&#125;void addline(rg int x, rg int l, rg int r, rg ll k, rg ll b)&#123; if (tree[x].left &gt;= l &amp;&amp; tree[x].right &lt;= r) &#123; apply(x, k, b); return; &#125; rg int mid = tree[x].left + tree[x].right &gt;&gt; 1; if (l &lt;= mid)addline(x &lt;&lt; 1, l, r, k, b); if (r &gt; mid)addline(x &lt;&lt; 1 | 1, l, r, k, b); tree[x].min = fast_IO::min(tree[x].min, fast_IO::min(tree[x &lt;&lt; 1].min, tree[x &lt;&lt; 1 | 1].min));&#125;inl void addLine(rg int x, rg int y, rg ll k, rg ll b)&#123; while (belong[x] != belong[y]) &#123; if (deep[belong[x]] &lt; deep[belong[y]])jh(x, y); addline(1, pos[belong[x]], pos[x], k, b); x = fa[belong[x]]; &#125; if (pos[x] &gt; pos[y])jh(x, y); addline(1, pos[x], pos[y], k, b);&#125;inl int LCA(rg int x, rg int y)&#123; while (belong[x] != belong[y]) &#123; if (deep[belong[x]] &lt; deep[belong[y]])jh(x, y); x = fa[belong[x]]; &#125; if (deep[x] &lt; deep[y])return x; return y;&#125;inl void tian()&#123; rg int s = fast_IO::read(), t = fast_IO::read(); rg ll k = fast_IO::read(), b = fast_IO::read(); rg int lca = LCA(s, t); addLine(s, lca, -k, k*dist[s] + b); addLine(lca, t, k, k*dist[s] - 2 * k*dist[lca] + b);&#125;ll querymin(rg int x, rg int l, rg int r)&#123; rg ll ans = INF, mid = tree[x].left + tree[x].right &gt;&gt; 1; if (l &lt;= tree[x].left&amp;&amp;r &gt;= tree[x].right)return tree[x].min; if (l &lt;= mid)ans = fast_IO::min(ans, querymin(x &lt;&lt; 1, l, r)); if (r &gt; mid)ans = fast_IO::min(ans, querymin(x &lt;&lt; 1 | 1, l, r)); l = fast_IO::max(l, tree[x].left), r = fast_IO::min(r, tree[x].right); ans = fast_IO::min(ans, f(dist[h[l]], tree[x].delta.k, tree[x].delta.b)); ans = fast_IO::min(ans, f(dist[h[r]], tree[x].delta.k, tree[x].delta.b)); return ans;&#125;inl ll queryMin(rg int x, rg int y)&#123; rg ll ans = INF; while (belong[x] != belong[y]) &#123; if (deep[belong[x]] &lt; deep[belong[y]])jh(x, y); ans = fast_IO::min(ans, querymin(1, pos[belong[x]], pos[x])); x = fa[belong[x]]; &#125; if (pos[x] &gt; pos[y])jh(x, y); return fast_IO::min(ans, querymin(1, pos[x], pos[y]));&#125;inl ll query()&#123; rg int s = fast_IO::read(), t = fast_IO::read(); return queryMin(s, t);&#125;int main(void)&#123; rg int n = fast_IO::read(), m = fast_IO::read(); for (rg int i = 1; i != n; ++i)add(fast_IO::read(), fast_IO::read(), fast_IO::read()); dfs1(1), dfs2(1, 1), build(1, 1, n); while (m--) switch (fast_IO::read()) &#123; case 1:tian(); break; case 2:printf("%lld\n", query()); break; &#125; return 0;&#125; 三、可并堆（左偏树）左偏树呈二叉树结构，除维护权值信息外，还需要维护子树内最近叶结点的距离$d_x$。 例题一、Dispatching题面见P1552。 思路考虑到如果某个忍者当管理员时不选$x$忍者，那么这个忍者的直接上级一定不会选$x$。使用左偏树维护以$x$为根子树内派遣忍者名单，它需要满足大根堆的性质，不断删除堆顶直到总和$\le m$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define jh(x,y) x^=y^=x^=y#define rg register#define inl inlinetypedef long long ll;const int N = 1e5 + 5;using namespace std;namespace fast_IO &#123; inl ll read() &#123; rg ll num = 0; rg char ch; rg bool flag = false; while ((ch = getchar()) == ' ' || ch == '\n' || ch == '\r'); if (ch == EOF)return ch; if (ch == '-')flag = true; else num = ch ^ 48; while ((ch = getchar()) != ' '&amp;&amp;ch != '\n'&amp;&amp;ch != '\r'&amp;&amp;~ch) num = (num &lt;&lt; 1) + (num &lt;&lt; 3) + (ch ^ 48); if (flag)return -num; return num; &#125; inl ll max(rg ll a, rg ll b) &#123; if (a &gt; b)return a; return b; &#125; inl ll min(rg ll a, rg ll b) &#123; if (a &lt; b)return a; return b; &#125; void write(rg long long x) &#123; if (x &lt; 0)putchar('-'), x = -x; if (x &gt;= 10)write(x / 10); putchar(x % 10 ^ 48); &#125;&#125;;int fa[N], n, lson[N], rson[N], d[N], root[N], ssize[N];ll c[N], m, l[N], sum[N], ans;int merge(rg int x, rg int y)&#123; if (!x || !y)return x | y; if (c[x] &lt; c[y])jh(x, y); rson[x] = merge(rson[x], y); if (d[lson[x]] &lt; d[rson[x]])jh(lson[x], rson[x]); d[x] = d[rson[x]] + 1; return x;&#125;int main(void)&#123; n = fast_IO::read(), m = fast_IO::read(); for (rg int i = 1; i &lt;= n; ++i) fa[i] = fast_IO::read(), sum[i] = c[i] = fast_IO::read(), l[i] = fast_IO::read(), root[i] = i, ssize[i] = 1, ans = fast_IO::max(ans, l[i]); for (rg int i = n; i != 1; --i) &#123; root[fa[i]] = merge(root[i], root[fa[i]]); sum[fa[i]] += sum[i]; ssize[fa[i]] += ssize[i]; while (sum[fa[i]] &gt; m) &#123; sum[fa[i]] -= c[root[fa[i]]]; root[fa[i]] = merge(lson[root[fa[i]]], rson[root[fa[i]]]); --ssize[fa[i]]; &#125; ans = fast_IO::max(ans, l[fa[i]] * ssize[fa[i]]); &#125; fast_IO::write(ans); return 0;&#125; 线段树的合并线段树要合并，必须要有相同的结构，均摊复杂度$O(log n)$。 四、平衡树Treap——Treep=Tree+HeapTreap通过单旋保持堆性质。树高期望$O(logn)$ 启发式合并合并两棵$Treap$的时候，只需要暴力遍历较小的 Treap 提取所有结点，然后依次插入到较大的$Treap$之中就好了。很多数据结构都可以用启发式合并 例题一、Peaks题面见P4197 思路将道路和询问混在一起排序，进行$Kruskal$算法的同时用$Treap $维护连通分量内所有山峰的高度。 SplaySplay借助双旋操作（zig_zag）。 例题二、序列终结者题面见P4146。 思路Splay维护翻转、子树最值、addv标记。 例题三、三维偏序思路线段树套平衡树 Day1 下午五、嵌套数据结构嵌套数据结构的思想是将普通的数据结构维护的信息拓展成另一种数据结构（可能与第一维数据结构相同） 树套树常见的有树状数组套平衡树，线段树套权值线段树等。注意，第一维的数据结构应该尽量简单，可以节约空间减小时间复杂度。 例题一、Mokia题面见P4390。 思路树状数组套Splay 六、可持久化线段树（主席树）可持久化数据结构可持久化数据结构就是利用函数式编程的思想使其支持询问历史版本，同时充分利用它们之间的共同数据来减少时间和空间消耗 大致的思想就是只新建不修改，保存历史版本 例题一、静态区间第k小题面见P3834。 思路主席树模板题 七、动态树（Link-Cut-Tree）不是很懂。。。弄明白以后再补 总结数据结构是很重要的基础。讲课好快…今天的例题只敲出来两个，其他的还得以后慢慢做]]></content>
      <categories>
        <category>游记</category>
        <category>2019清北学堂</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2019%2F04%2F11%2Fhello%2F</url>
    <content type="text"><![CDATA[我的第一篇blogLaTeX测试$\sum\limits_{i=1}^{n}a_b^c$ 理综答题卡模板 答题卡物理选择题 题号 14 15 16 17 18 19 20 21 答案 非选择题22.23.24.25.33.化学选择题 题号 7 8 9 10 11 12 13 答案 非选择题26.27.28.36.生物选择题 题号 1 2 3 4 5 6 答案 非选择题29.30.31.32.37.数学答题卡模板选择题 题号 1 2 3 4 5 6 7 8 9 10 11 12 答案 填空题13.14.15.16. 解答题17.18.19.20.21.22.]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
